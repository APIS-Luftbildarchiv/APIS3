# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QTableView, QAbstractItemView, QComboBox
from PyQt5.QtSql import QSqlRelationalTableModel, QSqlQuery
from PyQt5.QtCore import QItemSelection, QItemSelectionModel, Qt

from APIS.src.apis_utils import SetWindowSize, GetWindowSize

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_weather.ui'), resource_suffix='')


class APISWeather(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, parent=None):
        """Constructor."""
        super(APISWeather, self).__init__(parent)

        self.iface = iface
        self.dbm = dbm

        self.setupUi(self)

        # Initial window size/pos last saved. Use default values for first time
        if GetWindowSize("weather"):
            self.resize(GetWindowSize("weather"))

        self.setMode = False

        self.accepted.connect(self.onClose)
        self.rejected.connect(self.onClose)

        self.comboBoxMaps = {
            "lowcloudamount": {
                "editor": self.uiLowCloudAmountCombo,
                "codelbl": self.uiLowCloudAmountValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Low Cloud Amount",
                "index": 0
            },
            "visibilitykilometres": {
                "editor": self.uiVisibilityCombo,
                "codelbl": self.uiVisibilityValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Visibility Kilometres",
                "index": 1
            },
            "lowcloudheight": {
                "editor": self.uiLowCloudHeightCombo,
                "codelbl": self.uiLowCloudHeightValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Low Cloud Height",
                "index": 2
            },
            "weather": {
                "editor": self.uiWeatherCombo,
                "codelbl": self.uiWeatherValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Weather",
                "index": 3
            },
            "remarksmission": {
                "editor": self.uiRemarksMissionCombo,
                "codelbl": self.uiRemarksMissionValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Remarks Mission",
                "index": 4
            },
            "remarksweather": {
                "editor": self.uiRemarksTableV,
                "codelbl": self.uiRemarksValueLbl,
                "table": "wetter",
                "modelcolumn": 2,
                "category": "Remarks Weather",
                "indexstart": 5
            }
        }
        for key, item in self.comboBoxMaps.items():
            if "index" in item:
                self.setupComboBox(item["editor"], item["table"], item["modelcolumn"], item["category"])
                item["editor"].currentIndexChanged.connect(self.generateWeatherCode)
            if "indexstart" in item:
                pass

        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable("wetter")
        model.setFilter("category = '{0}'".format("Remarks Weather"))
        model.select()
        self.uiRemarksTableV.setModel(model)

        #self.uiRemarksTableV.setSelectionMode(QAbstractItemView.SingleSelection)
        self.uiRemarksTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiRemarksTableV.verticalHeader().setVisible(False)
        self.uiRemarksTableV.hideColumn(0)
        #self.uiRemarksTableV.model().insertColumn(0)

        self.uiRemarksTableV.resizeRowsToContents()
        self.uiRemarksTableV.resizeColumnsToContents()
        self.uiRemarksTableV.horizontalHeader().setStretchLastSection(True)

        self.uiRemarksTableV.selectionModel().selectionChanged.connect(self.generateWeatherCode)

    def generateWeatherCode(self):
        if not self.setMode:
            code = [None] * 5
            for key, item in self.comboBoxMaps.items():
                if "index" in item:
                    mIdx = item["editor"].model().createIndex(item["editor"].currentIndex(), item["editor"].model().fieldIndex("code"))
                    c = str(item["editor"].model().data(mIdx))
                    code[item["index"]] = c
                    item["codelbl"].setText(c)
                if "indexstart" in item:
                    remarks = []
                    if item["editor"].selectionModel().hasSelection():
                        selIdcs = item["editor"].selectionModel().selectedRows(item["editor"].model().fieldIndex("code"))
                        for i in selIdcs:
                            remarks.append(item["editor"].model().data(i))
                        remarks.sort()
                        item["codelbl"].setText("".join(remarks))
                    else:
                        item["codelbl"].setText("-")

            self.uiCodeEdit.setText("".join(code) + "".join(remarks))
            self.generateWeatherDescription()

    def setWeatherCode(self, weatherCode):
        self.setMode = True

        if not weatherCode:
            weatherCode = "9990X"

        self.uiCodeEdit.setText(weatherCode)

        for key, item in self.comboBoxMaps.items():
            if "index" in item:
                code = weatherCode[item["index"]]
                item["codelbl"].setText(code)
                m = item["editor"].model()
                rC = m.rowCount()
                for r in range(rC):
                    mIdx = m.createIndex(r, m.fieldIndex("code"))
                    if m.data(mIdx) == code:
                        idx = r
                item["editor"].setCurrentIndex(idx)
            if "indexstart" in item:
                item["editor"].selectionModel().clearSelection()
                if len(weatherCode) >= item["indexstart"]:
                    item["codelbl"].setText(weatherCode[item["indexstart"]:])
                    m = item["editor"].model()
                    rC = m.rowCount()
                    selection = QItemSelection()
                    for i in range(item["indexstart"], len(weatherCode)):
                        #QMessageBox.warning(None, "FilmNumber", weatherCode[i])
                        for r in range(rC):
                            mIdx = m.createIndex(r, m.fieldIndex("code"))
                            #QMessageBox.warning(None, "WeatherCode", "{0}={1}".format(m.data(mIdx), weatherCode[i]))
                            if m.data(mIdx) == weatherCode[i]:
                                lIdx = m.createIndex(r, 0)
                                rIdx = m.createIndex(r, item["editor"].model().columnCount() - 1)
                                rowSelection = QItemSelection(lIdx, rIdx)
                                selection.merge(rowSelection, QItemSelectionModel.Select)
                                break
                    item["editor"].selectionModel().select(selection,  QItemSelectionModel.Select)
                else:
                    item["codelbl"].setText("-")

        self.setMode = False
        self.generateWeatherDescription()

    def generateWeatherDescription(self):
        weatherCode = self.uiCodeEdit.text()
        code = []
        idx = 0
        query = QSqlQuery(self.dbm.db)
        for c in weatherCode:
            for key, item in self.comboBoxMaps.items():
                if "index" in item:
                    if idx == item["index"]:
                        code.append({'code': c, 'category': item["category"]})
                        break
                elif "indexstart" in item:
                    if idx >= item["indexstart"]:
                        code.append({'code': c, 'category': item["category"]})
                        break
            idx += 1
        self.uiDescriptionPTxt.clear()
        pos = 0
        for c in code:
            pos += 1
            qryStr = "select description from wetter where category = '{0}' and code = '{1}' limit 1".format(c['category'], c['code'])
            query.exec_(qryStr)
            query.first()
            fn = query.value(0)
            if pos <= 6:
                self.uiDescriptionPTxt.appendPlainText(c['category'] + ': ' + fn)
            else:
                self.uiDescriptionPTxt.insertPlainText('; ' + fn)

    def weatherCode(self):
        return str(self.uiCodeEdit.text())

    def weatherDescription(self):
        return str(self.uiDescriptionPTxt.toPlainText())

    def setupComboBox(self, editor, table, modelColumn, category):
        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable(table)
        model.setFilter("category = '{0}'".format(category))
        model.select()

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)

        editor.setModel(model)

        editor.setModelColumn(modelColumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.hideColumn(0)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)
        tv.setMinimumWidth(tv.horizontalHeader().length())

        #FIXME PyQt5 AutoCompletion
        #editor.setAutoCompletion(True)

        #TODO - Info next two lines were disables
        #editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), self))
        #self.uiProducerCombo.lineEdit().editingFinished.connect(self.cbValidate)

    def onClose(self):
        SetWindowSize("weather", self.size())
