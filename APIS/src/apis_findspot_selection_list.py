# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QAbstractItemView, QHeaderView, QFileDialog, QPushButton, QMenu
from PyQt5.QtCore import QSettings, Qt, QDateTime, QDir, QFile
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QIcon

from qgis.core import (QgsProject, QgsVectorLayer, QgsDataSourceUri, QgsFeature, QgsVectorFileWriter)

from APIS.src.apis_findspot import APISFindspot
from APIS.src.apis_utils import OpenFileOrFolder

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_findspot_selection_list.ui'), resource_suffix='')


class APISFindspotSelectionList(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISFindspotSelectionList, self).__init__(parent)
        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer
        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)
        self.setupUi(self)

        self.query = None

        self.uiFindspotListTableV.doubleClicked.connect(self.openFindspotDialog)

        self.uiResetSelectionBtn.clicked.connect(self.uiFindspotListTableV.clearSelection)

        mLayer = QMenu()
        mLayer.addSection("In QGIS laden")
        aLayerLoadFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n)")
        aLayerLoadFindspot.triggered.connect(self.loadFindspotInQgis)
        mLayer.addSection("SHP Export")
        aLayerExportFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "Fundstelle(n)")
        aLayerExportFindspot.triggered.connect(self.exportFindspotAsShp)
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportFindspotList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstellenliste")
        aPdfExportFindspotList.triggered.connect(self.exportListAsPdf)  # TODO: use lambda: to send mode
        aPdfExportFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        aPdfExportFindspot.triggered.connect(self.exportFindspotAsPdf)  # TODO: use lambda: to send mode
        aPdfExportFindspotAndSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle und Fundort")
        aPdfExportFindspotAndSite.triggered.connect(self.exportFindspotAsPdf)  # TODO: use lambda: to send mode
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        self.findspotDlg = None

    def hideEvent(self,event):
        self.query = None

    def loadFindspotListBySpatialQuery(self, query=None, info=None, update=False):
        if self.query == None:
            self.query = query

        self.model = self.dbm.queryToQStandardItemModel(self.query)

        if self.model is None or self.model.rowCount() < 1:
            if not update:
                QMessageBox.warning(None, "Fundstellen Auswahl", u"Es wurden keine Fundstellen gefunden!")
            self.query = None
            self.done(1)
            return False

        self.setupTable()

        self.uiItemCountLbl.setText(str(self.model.rowCount()))
        if info != None:
            self.uiInfoLbl.setText(info)

        return True

    def setupTable(self):
        self.uiFindspotListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiFindspotListTableV.setModel(self.model)
        self.uiFindspotListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.uiFindspotListTableV.resizeColumnsToContents()
        self.uiFindspotListTableV.resizeRowsToContents()
        self.uiFindspotListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.uiFindspotListTableV.selectionModel().selectionChanged.connect(self.onSelectionChanged)

    def onSelectionChanged(self):
        self.uiSelectionCountLbl.setText("{0}".format(len(self.uiFindspotListTableV.selectionModel().selectedRows())))

    def openFindspotDialog(self, idx):
        findspotNumber = self.model.item(idx.row(), 1).text()
        siteNumber = self.model.item(idx.row(), 0).text()
        if self.findspotDlg == None:
            self.findspotDlg = APISFindspot(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self)
            self.findspotDlg.findspotEditsSaved.connect(self.reloadTable)
            self.findspotDlg.findspotDeleted.connect(self.reloadTable)
        self.findspotDlg.openInViewMode(siteNumber, findspotNumber)
        self.findspotDlg.show()
        # Run the dialog event loop

        if self.findspotDlg.exec_():
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        self.findspotDlg.uiDatingTimeCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodContent)
        self.findspotDlg.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodDetailsContent)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"For Site: {0}".format(siteNumber)))

    def reloadTable(self, editsSaved):
        self.query.exec_()
        self.loadFindspotListBySpatialQuery(self.query, None, True)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"Reload Table Now"))


    def loadFindspotInQgis(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = self.askForGeometryType()
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))

                # get PolygonLayer
                subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" IN ('
                for findspotNumber in findspotList:
                    subsetString += u'\'{0}\','.format(findspotNumber)
                subsetString = subsetString[:-1]
                subsetString += u')'
                findspotLayer = self.getSpatialiteLayer('fundstelle', subsetString)

                if polygon:
                    # load PolygonLayer
                    self.loadLayer(findspotLayer)

                if point:
                    # generate PointLayer
                    centerPointLayer = self.generateCenterPointLayer(findspotLayer)
                    # load PointLayer
                    self.loadLayer(centerPointLayer)

                self.close()


    def exportFindspotAsShp(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = self.askForGeometryType()
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))

                # get PolygonLayer
                subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" IN ('
                for findspotNumber in findspotList:
                    subsetString += u'\'{0}\','.format(findspotNumber)
                subsetString = subsetString[:-1]
                subsetString += u')'
                findspotLayer = self.getSpatialiteLayer('fundstelle', subsetString)

                now = QDateTime.currentDateTime()
                time = now.toString("yyyyMMdd_hhmmss")
                if polygon:
                    # save PolygonLayer
                    self.exportLayer(findspotLayer, time)

                if point:
                    # generate PointLayer
                    centerPointLayer = self.generateCenterPointLayer(findspotLayer)
                    # save PointLayer
                    self.exportLayer(centerPointLayer, time)


    def exportFindspotAsPdf(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
            timeStamp = QDateTime.currentDateTime().toString("yyyyMMdd_hhmmss")

            if len(findspotList) == 1:
                saveDialogTitle = u"Fundstelle"
                targetFileNameTemplate = u"Fundstelle_{0}_{1}".format(findspotList[0], timeStamp)
            else:
                saveDialogTitle = u"Fundstellen Sammlung"
                targetFileNameTemplate = u"Fundstellen_Sammlung_{0}".format(timeStamp)

            targetFileName = QFileDialog.getSaveFileName(self, saveDialogTitle, os.path.join(saveDir, targetFileNameTemplate), "*.pdf")[0]

            if targetFileName:
                fsDetailsPrinter = ApisFindspotPrinter(self, self.dbm, self.imageRegistry)

                if len(findspotList) == 1:

                    # print file
                    pdfFiles = fsDetailsPrinter.exportDetailsPdf(findspotList, targetFileName, timeStamp, False)

                    # open file, open location?
                    for key in pdfFiles:
                        for pdfFile in pdfFiles[key]:
                            OpenFileOrFolder(pdfFile)

                else:
                    targetDirName = os.path.join(os.path.dirname(os.path.abspath(targetFileName)), u"temp_apis_print")
                    try:
                        os.makedirs(targetDirName)
                    except OSError:
                        if not os.path.isdir(targetDirName):
                            raise

                    # print files (temp)
                    pdfFiles = fsDetailsPrinter.exportDetailsPdf(findspotList, targetDirName, timeStamp, False)

                    # merge to collection
                    pdfFilesList = []
                    for key in pdfFiles:
                        for pdfFile in pdfFiles[key]:
                            pdfFilesList.append(pdfFile)

                    MergePdfFiles(targetFileName, pdfFilesList)

                    # open file, open location?
                    OpenFileOrFolder(targetFileName)


    def exportListAsPdf(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            qryStr = u"SELECT fs.fundortnummer || '.' || fs.fundstellenummer AS Fundstellenummer, fo.katastralgemeindenummer AS 'KG Nummer', fo.katastralgemeinde AS 'KG Name', datierung_zeit || ',' || datierung_periode || ',' || datierung_periode_detail || ',' || phase_von || '-' || phase_bis AS Datierung, fundart AS Fundart FROM fundstelle fs, fundort fo WHERE fs.fundortnummer = fo.fundortnummer AND fs.fundortnummer || '.' || fs.fundstellenummer IN ({0}) ORDER BY fo.land, fo.katastralgemeindenummer, fo.fundortnummer_nn, fs.fundstellenummer".format(u",".join(u"'{0}'".format(findspot) for findspot in findspotList))
            printer = ApisListPrinter(self, self.dbm, self.imageRegistry, True, False, None, 1)
            printer.setupInfo(u"Fundstellenliste", u"Fundstellenliste speichern", u"Fundstellenliste", 22)
            printer.setQuery(qryStr)
            printer.printList()


    def askForFindspotList(self):
        if self.uiFindspotListTableV.selectionModel().hasSelection():
            # Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Fundstellen')
            msgBox.setText(u'Wollen Sie die ausgewählten Funstellen oder die gesamte Liste verwenden?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                findspotList = self.getFindspotList(False)
            elif ret == 1:
                findspotList = self.getFindspotList(True)
            else:
                return None
        else:
            findspotList = self.getFindspotList(True)

        return findspotList


    def getFindspotList(self, getAll):
        findspotList = []
        if self.uiFindspotListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiFindspotListTableV.selectionModel().selectedRows()
            for row in rows:
                if not self.uiFindspotListTableV.isRowHidden(row.row()):
                    findspotList.append(u"{0}.{1}".format(self.model.item(row.row(), 0).text(), self.model.item(row.row(), 1).text()))
        else:
            for row in range(self.model.rowCount()):
                if not self.uiFindspotListTableV.isRowHidden(row):
                    findspotList.append(u"{0}.{1}".format(self.model.item(row, 0).text(), self.model.item(row, 1).text()))

        return findspotList


    def askForGeometryType(self):
        # Abfrage ob Fundstellen der selektierten Bilder Exportieren oder alle
        msgBox = QMessageBox()
        msgBox.setWindowTitle(u'Fundstellen')
        msgBox.setText(u'Wollen Sie für die Fundstellen Polygone, Punkte oder beide Layer verwenden?')
        msgBox.addButton(QPushButton(u'Polygone'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Punkte'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Polygone und Punkte'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
        ret = msgBox.exec_()

        if ret == 0:
            polygon = True
            point = False
        elif ret == 1:
            polygon = False
            point = True
        elif ret == 2:
            polygon = True
            point = True
        else:
            return None, None

        return polygon, point


    def getSpatialiteLayer(self, layerName, subsetString=None, displayName=None):
        if not displayName:
            displayName = layerName
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbm.db.databaseName())
        uri.setDataSource('', layerName, 'geometry')
        layer = QgsVectorLayer(uri.uri(), displayName, 'spatialite')
        if subsetString:
            layer.setSubsetString(subsetString)

        return layer

        # symbol_layer = QgsSimpleLineSymbolLayerV2()
        # symbol_layer.setWidth(0.6)
        # symbol_layer.setColor(QColor(100, 50, 140, 255))
        # self.siteLayer.rendererV2().symbols()[0].changeSymbolLayer(0, symbol_layer)


    def loadLayer(self, layer):
        QgsProject.instance().addMapLayer(layer)


    def exportLayer(self, layer, time):
        geomType = "Punkt" if layer.geometryType() == 0 else "Polygon"
        saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
        layerName = QFileDialog.getSaveFileName(self, u'Fundstellen {0} Export Speichern'.format(geomType), saveDir + "\\" + 'Fundstellen_{0}_{1}'.format(geomType, time), '*.shp')[0]
        if layerName:
            check = QFile(layerName)
            if check.exists():
                if not QgsVectorFileWriter.deleteShapeFile(layerName):
                    QMessageBox.warning(None, "Fundstelle Export",
                                        u"Es ist nicht möglich die SHP Datei {0} zu überschreiben!".format(layerName))
                    return

            error = QgsVectorFileWriter.writeAsVectorFormat(layer, layerName, "UTF-8", layer.crs(), "ESRI Shapefile")

            if error == QgsVectorFileWriter.NoError:
                # QMessageBox.information(None, "Fundorte Export", u"Die ausgewählten Fundorte wurden in eine SHP Datei exportiert.")
                msgBox = QMessageBox()
                msgBox.setWindowTitle(u'Fundtelle Export')
                msgBox.setText(u"Die ausgewählten Fundstellen wurden in eine SHP Datei exportiert.")
                msgBox.addButton(QPushButton(u'SHP Datei laden'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Ordner öffnen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'SHP Datei laden und Ordner öffnen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'OK'), QMessageBox.AcceptRole)
                ret = msgBox.exec_()

                if ret == 0 or ret == 2:
                    # Load Shp File in QGIS
                    self.iface.addVectorLayer(layerName, "", 'ogr')

                if ret == 1 or ret == 2:
                    # Open Folder
                    OpenFileOrFolder(os.path.split(layerName)[0])

            else:
                QMessageBox.warning(None, "Fundstelle Export", u"Beim erstellen der SHP Datei ist ein Fehler aufgetreten.")


    def generateCenterPointLayer(self, polygonLayer, displayName=None):
        if not displayName:
            displayName = polygonLayer.name()
        epsg = polygonLayer.crs().authid()
        # QMessageBox.warning(None, "EPSG", u"{0}".format(epsg))
        layer = QgsVectorLayer("Point?crs={0}".format(epsg), displayName, "memory")
        layer.setCrs(polygonLayer.crs())
        provider = layer.dataProvider()
        provider.addAttributes(polygonLayer.dataProvider().fields())

        layer.updateFields()

        pointFeatures = []
        for polygonFeature in polygonLayer.getFeatures():
            polygonGeom = polygonFeature.geometry()
            pointGeom = polygonGeom.centroid()
            # if center point is not on polygon get the nearest Point
            if not polygonGeom.contains(pointGeom):
                pointGeom = polygonGeom.pointOnSurface()

            pointFeature = QgsFeature()
            pointFeature.setGeometry(pointGeom)
            pointFeature.setAttributes(polygonFeature.attributes())
            pointFeatures.append(pointFeature)

        provider.addFeatures(pointFeatures)

        layer.updateExtents()

        return layer