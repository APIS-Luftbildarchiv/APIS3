# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, math, glob, shutil

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QDataWidgetMapper, QTableView, QAbstractItemView, QComboBox, QHeaderView, QMessageBox, QPushButton, QFileDialog, QGraphicsScene, QGraphicsTextItem, QMenu
from PyQt5.QtSql import QSqlRelationalTableModel, QSqlQuery, QSqlRelationalDelegate
from PyQt5.QtCore import pyqtSignal, QSettings, Qt, QTime, QDate, QDateTime, QFile, QDir, QRectF
from PyQt5.QtGui import QValidator, QIntValidator, QDoubleValidator, QStandardItem, QStandardItemModel, QColor, QImage, QPixmap, QIcon

from qgis.core import (QgsGeometry, QgsCoordinateReferenceSystem, QgsMapSettings, QgsUnitTypes, QgsProject, QgsVectorLayer,
                       QgsRasterLayer, QgsRectangle, QgsDataSourceUri, QgsFillSymbol, QgsFeature, QgsMarkerSymbol,
                       QgsCentroidFillSymbolLayer, QgsSimpleLineSymbolLayer, QgsSingleSymbolRenderer, QgsWkbTypes)
from qgis.gui import QgsRubberBand

from APIS.src.apis_text_editor import APISTextEditor
from APIS.src.apis_representative_image import APISRepresentativeImage
from APIS.src.apis_overpass_request import APISOverpassRequest
from APIS.src.apis_utils import SiteHasFindspot, OpenFileOrFolder, ApisLogger, GetFindspotNumbers,VersionToCome
from APIS.src.apis_findspot import APISFindspot
from APIS.src.apis_findspot_selection_list import APISFindspotSelectionList
from APIS.src.apis_sharding_selection_list import APISShardingSelectionList
from APIS.src.apis_image_selection_list import APISImageSelectionList
from APIS.src.apis_printing_options import APISPrintingOptions
from APIS.src.apis_printer import APISPrinterQueue, APISListPrinter, APISTemplatePrinter

from functools import partial

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_site.ui'), resource_suffix='')


class APISSite(QDialog, FORM_CLASS):

    siteEditsSaved = pyqtSignal(bool)
    siteDeleted = pyqtSignal(bool)
    siteAndGeometryEditsSaved = pyqtSignal(QDialog, str, QgsGeometry, QgsGeometry, str, dict)
    siteAndGeometryEditsCanceled = pyqtSignal(QDialog)
    copyImageFinished = pyqtSignal(bool)

    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISSite, self).__init__(parent)

        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer
        self.stylesDir = self.apisLayer.getStylesDir()

        self.setupUi(self)

        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        self.editMode = False
        self.addMode = False
        self.initalLoad = True
        self.geometryEditing = False
        self.isGeometryEditingSaved = False
        self.repImageLoaded = False
        self.repImagePath = None

        self.rejected.connect(self.onReject)

        self.uiOkBtn.clicked.connect(self.onAccept)
        self.uiCancelBtn.clicked.connect(self.cancelEdit)
        self.uiSaveBtn.clicked.connect(self.saveEdits)

        self.uiPlotNumberBtn.clicked.connect(lambda: self.openTextEditor("Parzellennummer", self.uiPlotNumberEdit))
        self.uiCommentBtn.clicked.connect(lambda: self.openTextEditor("Bemerkung zur Lage", self.uiCommentEdit))
        self.uiOverpassBtn.clicked.connect(self.openOverpassRequest)

        self.uiFindspotListTableV.doubleClicked.connect(self.openFindspotDialog)

        self.findspotDlg = None
        self.shardingDlg = None
        self.findspotHandlingDlg = None
        self.printingOptionsDlg = None

        self.uiLoadSiteInQGisBtn.clicked.connect(self.loadSiteInQGis)
        self.uiLoadSiteInterpretationInQGisBtn.clicked.connect(self.loadSiteInterpretationInQGis)
        self.uiListImagesOfSiteBtn.clicked.connect(self.openImageSelectionListDialog)
        self.uiSelectRepresentativeImageBtn.clicked.connect(self.openRepresentativeImageDialog)
        self.uiDeleteSiteBtn.clicked.connect(self.deleteSite)

        self.uiLoadFindspotInQGisBtn.clicked.connect(lambda: VersionToCome())

        mSharding = QMenu()
        aShardingOverview = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'footprints.png')), "Begehungen Übersicht")
        aShardingOverview.triggered.connect(self.openShardingSelectionListDialog)
        aShardingImages = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Fotos der Begehungen")
        aShardingImages.triggered.connect(lambda: VersionToCome())
        self.uiShardingTBtn.setMenu(mSharding)
        self.uiShardingTBtn.clicked.connect(self.uiShardingTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundort")
        aPdfExportSite.triggered.connect(lambda: self.exportAsPdf(detail=True))
        aPdfExportSiteFindspotList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundort und Funstellenliste")
        aPdfExportSiteFindspotList.triggered.connect(lambda: self.exportAsPdf(detail=True, subList=True))
        aPdfExportSiteFindspotListFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundort, Funstellenliste und Fundstellen")
        aPdfExportSiteFindspotListFindspot.triggered.connect(lambda: self.exportAsPdf(detail=True, subList=True, subDetail=True))
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        self.uiAddNewFindspotBtn.clicked.connect(self.addNewFindspot)

        self.uiSiteMapCanvas.setCanvasColor(Qt.white)
        #self.uiSiteMapCanvas.setCrsTransformEnabled(True)
        self.uiSiteMapCanvas.setDestinationCrs(
            QgsCoordinateReferenceSystem(3857, QgsCoordinateReferenceSystem.EpsgCrsId))

        self.rubberBand = None
        self.siteLayerId = None

        self.copyImageFinished.connect(self.onCopyImageFinished)

        self.initalLoad = False


    def openInViewMode(self, siteNumber):
        self.initalLoad = True
        self.siteNumber = siteNumber

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundort")
        self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
        res = self.model.select()
        self.setupMapper()
        self.mapper.toFirst()

        self.setupFindspotList()

        self.loadSiteInSiteMapCanvas()

        #self.loadRepresentativeImageForSite()
        self.initalLoad = False

    def openInEditMode(self, siteNumber, newPolygon, oldPolygon, country, kgCode, kgName, siteArea):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.newPolygon = newPolygon
        self.oldPolygon = oldPolygon
        self.country = country

        self.geometryEditing = True

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundort")
        self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
        res = self.model.select()
        self.setupMapper()
        self.mapper.toFirst()

        self.setupFindspotList()

        self.loadSiteInSiteMapCanvas(newPolygon)

        self.startEditMode()
        self.initalLoad = False

        #update Editors
        if self.uiCadastralCommunityNumberEdit.text() != kgCode:
            self.uiCadastralCommunityNumberEdit.setText(kgCode)
        if self.uiCadastralCommunityEdit.text() != kgName:
            self.uiCadastralCommunityEdit.setText(kgName)
        if self.uiAreaEdit.text() != siteArea:
            self.uiAreaEdit.setText(str(siteArea))


    def openInAddMode(self, siteNumber, isFilmBased):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.isFilmBased = isFilmBased

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundort")
        self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
        res = self.model.select()
        self.setupMapper()
        self.mapper.toFirst()

        self.setupFindspotList()

        self.loadSiteInSiteMapCanvas()

        self.addMode = True
        self.startEditMode()

        self.initalLoad = False

    def setupMapper(self):
        self.mapper = QDataWidgetMapper(self)
        self.mapper.setSubmitPolicy(QDataWidgetMapper.ManualSubmit)
        self.mapper.setItemDelegate(SiteDelegate())

        self.mapper.setModel(self.model)

        self.mandatoryEditors = [self.uiSiteDiscoveryCombo, self.uiSiteCreationCombo, self.uiSiteReliabilityCombo]

        # LineEdits & PlainTextEdits
        self.intValidator = QIntValidator()
        self.doubleValidator = QDoubleValidator()

        self.lineEditMaps = {
            "fundortnummer": {
                "editor": self.uiSiteNumberEdit
            },
            "filmnummer_projekt": {
                "editor": self.uiProjectOrFilmEdit
            },
            "katastralgemeindenummer":{
                "editor": self.uiCadastralCommunityNumberEdit
            },
            "land":{
                "editor": self.uiCountryEdit
            },
            "katastralgemeinde":{
                "editor": self.uiCadastralCommunityEdit
            },
            "flurname":{
                "editor": self.uiFieldNameEdit
            },
            "parzellennummern":{
                "editor": self.uiPlotNumberEdit
            },
            "kommentar_lage":{
                "editor": self.uiCommentEdit
            },
            "erstmeldung_jahr":{
                "editor": self.uiFirstReportYearEdit,
                "validator": self.intValidator
            },
            "bildnummer": {
                "editor": self.uiImagesEdit
            },
            "raster": {
                "editor": self.uiRasterEdit
            },
            "ortshoehe":{
                "editor": self.uiElevationEdit,
                "validator": self.doubleValidator
            },
            "flaeche":{
                "editor": self.uiAreaEdit,
                "validator": self.doubleValidator
            },
            "literatur":{
                "editor": self.uiLiteraturePTxt
            },
            "detailinterpretation":{
                "editor": self.uiDetailinterpretationPTxt
            },
            "befund": {
                "editor": self.uiFindingsPTxt
            }
        }
        for key, item in self.lineEditMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            if "validator" in item:
                item["editor"].setValidator(item["validator"])
            #item["editor"].textChanged.connect(partial(self.onLineEditChanged, item["editor"]))
            item["editor"].textChanged.connect(self.onLineEditChanged)

        # Date and Times
        self.mapper.addMapping(self.uiInitalEntryDate, self.model.fieldIndex("datum_ersteintrag"))
        self.mapper.addMapping(self.uiLastChangesDate, self.model.fieldIndex("datum_aenderung"))

        # ComboBox without Model
        self.mapper.addMapping(self.uiSiteReliabilityCombo, self.model.fieldIndex("sicherheit"))
        self.uiSiteReliabilityCombo.editTextChanged.connect(self.onLineEditChanged)
        #FIXME Pyqt5 AutoCompletion
        #self.uiSiteReliabilityCombo.setAutoCompletion(True)
        self.uiSiteReliabilityCombo.lineEdit().setValidator(InListValidator([self.uiSiteReliabilityCombo.itemText(i) for i in range(self.uiSiteReliabilityCombo.count())], self.uiSiteReliabilityCombo.lineEdit(), None, self))

        # ComboBox with Model
        self.comboBoxMaps = {
            "fundgewinnung": {
                "editor": self.uiSiteDiscoveryCombo,
                "table": "fundgewinnung",
                "modelcolumn": 0,
                "depend": None
            },
            "fundgewinnung_quelle": {
                "editor": self.uiSiteCreationCombo,
                "table": "fundgewinnung_quelle",
                "modelcolumn": 0,
                "depend": None
            }
        }
        for key, item in self.comboBoxMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            self.setupComboBox(item["editor"], item["table"], item["modelcolumn"], item["depend"])
            item["editor"].editTextChanged.connect(self.onLineEditChanged)


    def setupComboBox(self, editor, table, modelColumn, depend):
        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable(table)
        model.removeColumn(0)
        model.select()

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)

        editor.setModel(model)

        editor.setModelColumn(modelColumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)
        #tv.setMinimumWidth(tv.horizontalHeader().length())
        tv.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        #FIXME PyQt5 AutoCompletion
        #editor.setAutoCompletion(True)
        editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), depend, self))

        if depend:
            editor.currentIndexChanged.connect(partial(self.updateDepends, editor, depend))


    def updateDepends(self, editor, depend):
         for dep in depend:
            for key, value in dep.iteritems():
                idx = editor.model().createIndex(editor.currentIndex(), editor.model().fieldIndex(key))
                value.setText(str(editor.model().data(idx)))
                #QMessageBox.warning(None, "Test", str(idx))


    def setupFindspotList(self):

        query = QSqlQuery(self.dbm.db)
        query.prepare("SELECT fundstellenummer AS 'Nummer', datierung_zeit AS 'Datierung', fundart AS 'Fundart', fundart_detail AS 'Fundart Detail' FROM fundstelle WHERE fundortnummer = '{0}'".format(self.siteNumber))
        query.exec_()

        model = self.dbm.queryToQStandardItemModel(query)

        self.uiFindspotListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiFindspotListTableV.setModel(model)
        self.uiFindspotListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.uiFindspotListTableV.resizeColumnsToContents()
        self.uiFindspotListTableV.resizeRowsToContents()
        self.uiFindspotListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        query.finish()


    def openFindspotDialog(self, idx):
        findspotNumber = self.uiFindspotListTableV.model().item(idx.row(), 0).text()
        siteNumber = self.uiSiteNumberEdit.text()
        if self.findspotDlg == None:
            self.findspotDlg = APISFindspot(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self)
            self.findspotDlg.findspotEditsSaved.connect(self.setupFindspotList)
            self.findspotDlg.findspotDeleted.connect(self.setupFindspotList)
            if isinstance(self.parentWidget(), APISFindspotSelectionList):
                self.findspotDlg.findspotEditsSaved.connect(self.updateParentTable)
                self.findspotDlg.findspotDeleted.connect(self.updateParentTable)
        self.findspotDlg.openInViewMode(siteNumber, findspotNumber)
        self.findspotDlg.show()
        # Run the dialog event loop

        if self.findspotDlg.exec_():
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            # QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"For Site: {0}".format(siteNumber)))

        self.findspotDlg.uiDatingTimeCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodContent)
        self.findspotDlg.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodDetailsContent)


    def openFindspotDialogInAddMode(self, siteNumber, findspotNumber):

        if self.findspotDlg == None:
            self.findspotDlg = APISFindspot(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self)
            self.findspotDlg.findspotEditsSaved.connect(self.setupFindspotList)
            self.findspotDlg.findspotDeleted.connect(self.setupFindspotList)
            if isinstance(self.parentWidget(), APISFindspotSelectionList):
                self.findspotDlg.findspotEditsSaved.connect(self.updateParentTable)
                self.findspotDlg.findspotDeleted.connect(self.updateParentTable)

        self.findspotDlg.openInAddMode(siteNumber, findspotNumber)
        self.findspotDlg.show()

        if self.findspotDlg.exec_():
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
            # QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"For Site: {0}".format(siteNumber)))

        self.findspotDlg.uiDatingTimeCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodContent)
        self.findspotDlg.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodDetailsContent)

    def updateParentTable(self):
        parent = self.parentWidget()
        parent.reloadTable(True)

    def getNextFindspotNumber(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT CASE WHEN max(fundstellenummer) IS NULL THEN 1 ELSE max(fundstellenummer)+1 END AS nextFindspot FROM fundstelle WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return query.value(0)

    def getSiteInfo(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT parzellennummern,gkx,gky,meridian,longitude,latitude,flaeche, AsBinary(geometry) FROM fundort WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return [query.value(0), query.value(1), query.value(2), query.value(3), query.value(4), query.value(5), query.value(6)], query.value(7)

    def addNewFindspot(self):

        #QMessageBox.information(None, "Neue Fundstelle", "Neue Fundstelle Nummer: {0}".format(findspotNumber))

        findspotNumber = self.getNextFindspotNumber(self.siteNumber)
        siteInfo, siteGeometry = self.getSiteInfo(self.siteNumber)

        query = QSqlQuery(self.dbm.db)
        query.prepare(u"INSERT INTO fundstelle(geometry,fundortnummer,fundstellenummer,parzellennummern,gkx,gky,meridian,longitude,latitude,flaeche,erstmeldung_jahr,datum_ersteintrag,datum_aenderung,aktion,aktionsdatum,aktionsuser) VALUES (GeomFromWKB(?, 4312), ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)")

        query.addBindValue(siteGeometry)
        query.addBindValue(self.siteNumber)
        query.addBindValue(findspotNumber)

        for info in siteInfo:
            query.addBindValue(info)

        now = QDate.currentDate()
        query.addBindValue(now.toString("yyyy"))
        query.addBindValue(now.toString("yyyy-MM-dd"))
        query.addBindValue(now.toString("yyyy-MM-dd"))

        import getpass
        query.addBindValue('new')
        query.addBindValue(now.toString("yyyy-MM-dd"))
        query.addBindValue(getpass.getuser())

        res = query.exec_()
        #MessageBox.information(None, "Neue Fundstelle", "Neue Fundstelle Result: {0}, {1}".format(res, query.lastError().text()))

        query.finish()

        # load find spot layer dialog in addMode
        self.openFindspotDialogInAddMode(self.siteNumber, findspotNumber)

    def enableItemsInLayout(self, layout, enable):
        for i in range(layout.count()):
            if layout.itemAt(i).widget():
                layout.itemAt(i).widget().setEnabled(enable)


    def onLineEditChanged(self):
        sender = self.sender()
        if not self.editMode and not self.initalLoad:
            self.startEditMode()
        if not self.initalLoad:
            sender.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(sender.metaObject().className()))
            self.editorsEdited.append(sender)


    def onComboBoxChanged(self, editor):
        pass

    # TODO remove
    def apisLogger(self, action, fromTable, primaryKeysWhere):
        toTable = fromTable + u"_log"
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"INSERT INTO {0} SELECT * FROM {1} WHERE {2}".format(toTable, fromTable, primaryKeysWhere))

        res = query.exec_()
        #QMessageBox.information(None, "SqlQuery", query.executedQuery())
        if not res:
            QMessageBox.information(None, "SqlError", query.lastError().text())
        import getpass
        query.prepare(u"UPDATE {0} SET aktion = '{1}', aktionsdatum = '{2}', aktionsuser = '{3}' WHERE rowid = (SELECT max(rowid) FROM {0})".format(toTable, action, QDateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss"), getpass.getuser(), primaryKeysWhere))
        res = query.exec_()
        #QMessageBox.information(None, "SqlQuery", query.executedQuery())
        if not res:
            QMessageBox.information(None, "SqlError", query.lastError().text())

    def openTextEditor(self, title, editor):
        textEditorDlg = APISTextEditor()
        textEditorDlg.setWindowTitle(title)
        textEditorDlg.setText(editor.text())
        if textEditorDlg.exec_():
            editor.setText(textEditorDlg.getText())

    def openOverpassRequest(self):
        overpassRequestDlg = APISOverpassRequest()
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT latitude, longitude FROM fundort WHERE fundortnummer = '{0}'".format(self.siteNumber))
        res = query.exec_()
        query.first()
        overpassRequestDlg.setLatLon(query.value(0), query.value(1))
        if overpassRequestDlg.exec_():
            newValue = overpassRequestDlg.getSelection()
            oldValue = self.uiCadastralCommunityEdit.text()
            if oldValue.strip():
                # Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
                msgBox = QMessageBox()
                msgBox.setWindowTitle(u'Katastralgemeinde')
                msgBox.setText(u'Wollen Sie die Katastralgemeinde "{0}" durch "{1}" ersetzen?'.format(oldValue, newValue))
                msgBox.addButton(QPushButton(u'Ersetzen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()
                if ret == 0:
                    self.uiCadastralCommunityEdit.setText(newValue)
            else:
                self.uiCadastralCommunityEdit.setText(newValue)

    def onAccept(self):
        '''
        Check DB
        Save options when pressing OK button
        Update Plugin Status
        '''

        # Save Settings

        self.accept()

    def onReject(self):
        '''
        Run some actions when
        the user closes the dialog
        '''
        if self.editMode:
            res = self.cancelEdit()
            if res:
               self.close()
               return "ABC"
            else:
                self.show()
        else:
            self.close()

    def openShardingSelectionListDialog(self):
        #if self.shardingDlg == None:
        self.shardingDlg = APISShardingSelectionList(self.iface, self.dbm)
        siteNumber = self.uiSiteNumberEdit.text()
        self.shardingDlg.loadShardingListBySiteNumber(siteNumber)
        if self.shardingDlg.exec_():
            pass
            #self.shardingDlg = None

    def openImageSelectionListDialog(self):
        #layer = self.uiSiteMapCanvas.layers()
        layer = self.uiSiteMapCanvas.layers()[0]

        i = 0
        for feature in layer.getFeatures():
            if i == 0:
                searchGeometry = QgsGeometry.fromWkt(feature.geometry().asWkt())
                searchGeometry.convertToMultiType()
            else:
                searchGeometry.addPartGeometry(feature.geometry())
            i += 1

        epsg = 4312
        query = QSqlQuery(self.dbm.db)

        # LuftbildSuche
        query.prepare("select cp.bildnummer as bildnummer, cp.filmnummer as filmnummer, cp.radius as mst_radius, f.weise as weise, f.art_ausarbeitung as art from film as f, luftbild_schraeg_cp AS cp WHERE f.filmnummer = cp.filmnummer AND cp.bildnummer IN (SELECT fp.bildnummer FROM luftbild_schraeg_fp AS fp WHERE NOT IsEmpty(fp.geometry) AND Intersects(GeomFromText('{0}',{1}), fp.geometry) AND rowid IN (SELECT rowid FROM SpatialIndex WHERE f_table_name = 'luftbild_schraeg_fp' AND search_frame = GeomFromText('{0}',{1}) )) UNION ALL SELECT  cp_s.bildnummer AS bildnummer, cp_S.filmnummer AS filmnummer, cp_s.massstab, f_s.weise, f_s.art_ausarbeitung FROM film AS f_s, luftbild_senk_cp AS cp_s WHERE f_s.filmnummer = cp_s.filmnummer AND cp_s.bildnummer IN (SELECT fp_s.bildnummer FROM luftbild_senk_fp AS fp_s WHERE NOT IsEmpty(fp_s.geometry) AND Intersects(GeomFromText('{0}',{1}), fp_s.geometry) AND rowid IN (SELECT rowid FROM SpatialIndex WHERE f_table_name = 'luftbild_senk_fp' AND search_frame = GeomFromText('{0}',{1}) ) ) ORDER BY filmnummer, bildnummer".format(searchGeometry.asWkt(), epsg))
        query.exec_()
        imageSelectionListDlg = APISImageSelectionList(self.iface, self.dbm, self.imageRegistry)
        res = imageSelectionListDlg.loadImageListBySqlQuery(query)
        if res:
            imageSelectionListDlg.show()
            if imageSelectionListDlg.exec_():
                pass

    def removeNewSite(self):
        self.initalLoad = True
        row = self.mapper.currentIndex()
        self.model.removeRow(row)
        self.model.submitAll()
        #while (self.model.canFetchMore()):
        #    self.model.fetchMore()
        #self.uiTotalFilmCountLbl.setText(unicode(self.model.rowCount()))
        #self.mapper.toLast()
        self.initalLoad = False

    def saveEdits(self):
        # Check Mandatory fields
        flag = False
        fSEditActions = {}
        for mEditor in self.mandatoryEditors:
            cName = mEditor.metaObject().className()
            if cName == 'QLineEdit':
                value = mEditor.text()
            elif cName == 'QComboBox':
                if mEditor.isEditable():
                    value = mEditor.lineEdit().text()
                else:
                    if mEditor.currentIndex == -1:
                        value = ''
                    else:
                        value = '1'
            if value.strip() == "":
                flag = True
                # RED
                mEditor.setStyleSheet("{0} {{background-color: rgb(240, 160, 160);}}".format(cName))
                if mEditor not in self.editorsEdited:
                    self.editorsEdited.append(mEditor)
            else:
                if mEditor in self.editorsEdited:
                    #BLUE
                    mEditor.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(cName))
                #else:
                    #mEditor.setStyleSheet("")
        if flag:
            QMessageBox.warning(None, self.tr(u"Benötigte Felder Ausfüllen"), self.tr(u"Füllen Sie bitte alle Felder aus, die mit * gekennzeichnet sind."))
            return False

        # Check if fins spots will change due to site geometry edits
        if self.geometryEditing and SiteHasFindspot(self.dbm.db, self.siteNumber): # SiteHasFindspot in apis_utils.py
            fSEditActions = self.openSiteEditFindspotHandlingDialog()
            if fSEditActions == None:
                return True #Only return False if Dialog should be shown again

        #saveToModel
        currIdx = self.mapper.currentIndex()
        now = QDate.currentDate()
        self.uiLastChangesDate.setDate(now)

        if self.addMode:
            action = u"new"
        else:
            action = u"editAG" if self.geometryEditing else u"editA"
            #Update AKTION
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktion")),action)
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsdatum")), now.toString("yyyy-MM-dd"))
            import getpass
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsuser")), getpass.getuser())

        self.mapper.submit()

        #emit signal
        self.siteEditsSaved.emit(True)
        if self.geometryEditing:
            self.siteAndGeometryEditsSaved.emit(self, self.siteNumber, self.newPolygon, self.oldPolygon, self.country, fSEditActions)
            self.geometryEditing = False
        else:
            # log only if not geometryEditing envolved, otherwise log in site_mapping_dialog.saveSiteEdits()
            # TODO remove
            # self.apisLogger(action, u"fundort", u"fundortnummer = '{0}' ".format(self.siteNumber))
            ApisLogger(self.dbm.db, action, "fundort", "fundortnummer = '{0}' ".format(self.siteNumber))

        self.mapper.setCurrentIndex(currIdx)
        self.endEditMode()

        #
        if not self.isGeometryEditingSaved:
            self.isGeometryEditingSaved = True
        return True

    def cancelEdit(self):
        currIdx = self.mapper.currentIndex()
        if self.editMode:
            if self.addMode:
                header = self.tr(u"Neuer Fundort wurden hinzugefügt!")
                question = self.tr(u"Möchten Sie den neuen Fundort speichern?")
            elif self.geometryEditing:
                header = self.tr(u"Änderungen an der Fundort Geometrie wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änerungen der Geometrie und Attribute speichern?")
            else:
                header = self.tr(u"Änderungen wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änerungen der Attribute speichern?")
            result = QMessageBox.question(None,
                                          header,
                                          question,
                                          QMessageBox.Yes | QMessageBox.No ,
                                          QMessageBox.Yes)

            #save or not save
            if result == QMessageBox.Yes:
                res = self.saveEdits()
                if res:
                    return True
                else:
                    return False
            elif result == QMessageBox.No:
                if self.geometryEditing:
                    self.siteAndGeometryEditsCanceled.emit(self)
                    self.geometryEditing = False
                if self.addMode:
                    self.removeNewSite()
                    self.endEditMode()
                    self.close()
                    return True
                else:
                    self.mapper.setCurrentIndex(currIdx)
                    self.endEditMode()
                    return True

    def startEditMode(self):
        self.editMode = True
        self.uiFindspotGrp.setEnabled(False)
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, False)
        self.uiOkBtn.setEnabled(False)
        self.uiSaveBtn.setEnabled(True)
        self.uiCancelBtn.setEnabled(True)
        self.editorsEdited = []

    def endEditMode(self):
        self.editMode = False
        self.addMode = False
        self.uiFindspotGrp.setEnabled(True)
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, True)
        self.uiOkBtn.setEnabled(True)
        self.uiSaveBtn.setEnabled(False)
        self.uiCancelBtn.setEnabled(False)
        for editor in self.editorsEdited:
            cName = editor.metaObject().className()
            if (cName == "QLineEdit" or cName == "QDateEdit") and editor.isReadOnly():
                editor.setStyleSheet("{0} {{background-color: rgb(218, 218, 218);}}".format(cName))
            else:
                editor.setStyleSheet("")
        self.editorsEdited = []

    def isGeometrySaved(self):
        return self.isGeometryEditingSaved and self.geometryEditing

    #def showEvent(self, evnt):
     #   pass
        #self.model.select()
        #while (self.model.canFetchMore()):
        #    self.model.fetchMore()

    def deleteSite(self):
        # has findspots
        findspotCount = self.siteHasFindspots(self.siteNumber)
        if findspotCount:
            QMessageBox.warning(None, u"Fundort löschen", u"Der Fundort ({0}) hat {1} Fundstellen. Bitte löschen Sie diese damit Sie den Fundort löschen können.".format(self.siteNumber, findspotCount))
            return
        else:
            # Abfrage wirklich löschen
            header = u"Fundort löschen "
            question = u"Möchten Sie den Fundort wirklich aus der Datenbank löschen?"
            result = QMessageBox.question(None,
                                          header,
                                          question,
                                          QMessageBox.Yes | QMessageBox.No,
                                          QMessageBox.Yes)

            # save or not save

            if result == QMessageBox.Yes:

                # get path from settings
                path = self.settings.value("APIS/repr_image_dir", QDir.home().dirName())
                # get filename from SQL
                repImageName = self.getRepresentativeImage(self.siteNumber)
                if repImageName:
                    path += u"\\" + repImageName + u".jpg"
                    # Check if exists
                    repImageFile = QFile(path)

                    if repImageFile.exists():
                        repImageFile.remove()

                # log eintragen
                # TODO remove
                # self.apisLogger(u"delete", u"fundort", u"fundortnummer = '{0}'".format(self.siteNumber))
                ApisLogger(self.dbm.db, "delete", "fundort", "fundortnummer = '{0}'".format(self.siteNumber))

                # löschen
                self.model.deleteRowFromTable(self.mapper.currentIndex())

                self.siteDeleted.emit(True)
                self.iface.mapCanvas().refreshAllLayers()
                self.done(1)


    def siteHasFindspots(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT count(*) FROM fundstelle WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return query.value(0)

    def exportAsPdf(self, detail=False, subList=False, subDetail=False):
        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)

        if detail and not subList and not subDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundort")
        elif detail and subList and not subDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundort und Funndstellenliste")
        elif detail and subList and subDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundort, Funndstellenliste und Fundstellen")
        else:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundort")

        self.printingOptionsDlg.configure(False, subList)  # only if at least findspot list (or list plus detail of findspots) is selected allow outputmode

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():
            # get settings from dialog
            outputMode = self.printingOptionsDlg.outputMode()

            pdfsToPrint = []
            if detail:
                s = self.siteNumber
                pdfsToPrint.append({'type': APISTemplatePrinter.SITE, 'idList': [s]})
                if SiteHasFindspot(self.dbm.db, s) and (subList or subDetail):
                    findspotList = GetFindspotNumbers(self.dbm.db, [s])
                    if findspotList:
                        if subList:
                            pdfsToPrint.append({'type': APISListPrinter.FINDSPOT, 'idList': findspotList})
                        if subDetail:
                            for f in findspotList:
                                pdfsToPrint.append({'type': APISTemplatePrinter.FINDSPOT, 'idList': [f]})

            if pdfsToPrint:
                APISPrinterQueue(pdfsToPrint,
                                 outputMode,
                                 openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                 openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                 dbm=self.dbm,
                                 parent=self)


    def loadSiteInQGis(self):

        polygon, point = self.askForGeometryType()
        if polygon or point:
            # get PolygonLayer
            siteNumber = self.uiSiteNumberEdit.text()
            subsetString = u'"fundortnummer" = "{0}"'.format(siteNumber)
            siteLayer = self.getSpatialiteLayer(u"fundort", subsetString, u"fundort polygon {0}".format(siteNumber))

            if polygon:
                # load PolygonLayer
                QgsProject.instance().addMapLayer(siteLayer)

            if point:
                # generate PointLayer
                centerPointLayer = self.generateCenterPointLayer(siteLayer, u"fundort punkt {0}".format(siteNumber))
                # load PointLayer
                QgsProject.instance().addMapLayer(centerPointLayer)

    def loadSiteInterpretationInQGis(self):
        siteNumber = self.uiSiteNumberEdit.text()
        country, siteNumberN = siteNumber.split(".")
        if country == u"AUT":
            kgName = u"{0} ".format(self.uiCadastralCommunityEdit.text().lower().replace(".","").replace("-", " ").replace("(","").replace(")", ""))
        else:
            kgName = ""
        ##Generate Path

        siteNumberN = siteNumberN.zfill(6)
        intBaseDir = self.settings.value("APIS/int_base_dir")
        intDir = self.settings.value("APIS/int_dir")
        shpFile = u"luftint_{0}.shp".format(siteNumberN)
        intShpPath = os.path.normpath(os.path.join(intBaseDir, country, u"{0}{1}".format(kgName, siteNumberN), intDir, shpFile))


        if os.path.isfile(intShpPath):
            #QMessageBox.information(None, u"Interpretation", intShpPath)
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Fundort Interpretation')
            msgBox.setText(u"Für den Fundort {0} ist eine Interpretation vorhanden:".format(
                    siteNumber))
            msgBox.addButton(QPushButton(u'In QGIS laden'), QMessageBox.ActionRole)
            msgBox.addButton(QPushButton(u'Verzeichnis öffnen'), QMessageBox.ActionRole)
            msgBox.addButton(QPushButton(u'Laden und öffnen'), QMessageBox.ActionRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()
            if ret == 0 or ret == 2:
                # Load in QGIS
                self.apisLayer.requestShapeFile(intShpPath, epsg=None, layerName=None, groupName="Interpretationen", useLayerFromTree=True, addToCanvas=True)
            if ret == 1 or ret == 2:
                # Open Folder
                OpenFileOrFolder(os.path.dirname(intShpPath))

            if ret == 3:
                return


        else:
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Fundort Interpretation')
            msgBox.setText(u"Für den Fundort {0} ist keine Interpretation vorhanden. Wollen Sie eine Interpretation Erstellen?".format(siteNumber))
            msgBox.addButton(QPushButton(u'Vorbereiten'), QMessageBox.ActionRole)
            msgBox.addButton(QPushButton(u'Vorbereiten und laden'), QMessageBox.ActionRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0 or ret == 1:
                # Create Folder Path
                intPath = os.path.normpath(os.path.join(intBaseDir, country, u"{0}{1}".format(kgName, siteNumberN), intDir))
                try:
                    os.makedirs(intPath)
                except Exception as e:
                    pass
                # Copy Dummy Template
                srcPath = os.path.normpath(os.path.join(*[QSettings().value("APIS/plugin_dir"), "templates", "shp"]))
                template = self.settings.value("APIS/int_master_shp")
                for srcFile in glob.glob(os.path.normpath(os.path.join(srcPath, u'{0}.*'.format(template)))):
                    extension = os.path.splitext(srcFile)[1]
                    dstFile = os.path.normpath(os.path.join(intPath, u"luftint_{0}{1}".format(siteNumberN, extension)))
                    #QMessageBox.information(None, "Template", u"{0}, {1}".format(srcFile, dstFile))
                    shutil.copy(srcFile, dstFile)

                # Open Folder
                OpenFileOrFolder(intPath)
            else:
                return

            if ret == 1:
                self.apisLayer.requestShapeFile(intShpPath, epsg=None, layerName=None, groupName="Interpretationen", useLayerFromTree=True, addToCanvas=True)


        #TODO : REMOVE
        # subsetString = u'"fundortnummer" = "{0}"'.format(siteNumber)
        # siteInterpretationLayer = self.getSpatialiteLayer(u"fundort_interpretation", subsetString, u"fundort interpretation {0}".format(siteNumber))
        # count = siteInterpretationLayer.dataProvider().featureCount()
        # if count > 0:
        #     QgsMapLayerRegistry.instance().addMapLayer(siteInterpretationLayer)
        # else:
        #     QMessageBox.warning(None, u"Fundort Interpretation", u"Für den Fundort ist keine Interpretation vorhanden.")

    def askForGeometryType(self):
        # Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
        msgBox = QMessageBox()
        msgBox.setWindowTitle(u'Fundorte')
        msgBox.setText(u'Wollen Sie für den Fundort Polygon, Punkt oder beide Layer verwenden?')
        msgBox.addButton(QPushButton(u'Polygon'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Punkt'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Polygon und Punkt'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
        ret = msgBox.exec_()

        if ret == 0:
            polygon = True
            point = False
        elif ret == 1:
            polygon = False
            point = True
        elif ret == 2:
            polygon = True
            point = True
        else:
            return None, None

        return polygon, point

    def getSpatialiteLayer(self, layerName, subsetString=None, displayName=None):
        if not displayName:
            displayName = layerName
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbm.db.databaseName())
        uri.setDataSource('', layerName, 'geometry')
        layer = QgsVectorLayer(uri.uri(), displayName, 'spatialite')
        if subsetString:
            layer.setSubsetString(subsetString)

        return layer

    def generateCenterPointLayer(self, polygonLayer, displayName=None):
        if not displayName:
            displayName = polygonLayer.name()
        epsg = polygonLayer.crs().authid()
        # QMessageBox.warning(None, "EPSG", u"{0}".format(epsg))
        layer = QgsVectorLayer("Point?crs={0}".format(epsg), displayName, "memory")
        layer.setCrs(polygonLayer.crs())
        provider = layer.dataProvider()
        provider.addAttributes(polygonLayer.dataProvider().fields())

        layer.updateFields()

        pointFeatures = []
        for polygonFeature in polygonLayer.getFeatures():
            polygonGeom = polygonFeature.geometry()
            pointGeom = polygonGeom.centroid()
            # if center point is not on polygon get the nearest Point
            if not polygonGeom.contains(pointGeom):
                pointGeom = polygonGeom.pointOnSurface()

            pointFeature = QgsFeature()
            pointFeature.setGeometry(pointGeom)
            pointFeature.setAttributes(polygonFeature.attributes())
            pointFeatures.append(pointFeature)

        provider.addFeatures(pointFeatures)

        layer.updateExtents()

        return layer

    def getSiteRenderer(self):
        # Symbology für Layer
        symbol = QgsFillSymbol.createSimple({})
        symbol.deleteSymbolLayer(0)  # Remove default symbol layer

        symbol_layer = QgsSimpleLineSymbolLayer()
        symbol_layer.setWidth(0.6)
        symbol_layer.setColor(QColor(100, 50, 140, 255))
        symbol.appendSymbolLayer(symbol_layer)

        symbol_centroid = QgsMarkerSymbol.createSimple({u'name': u'circle', u'color': u'210,180,200,255', u'outline_color': u'100,50,140,255', u'outline_width': u'0.4'})

        symbol_layer = QgsCentroidFillSymbolLayer()
        symbol_layer.setPointOnSurface(True)
        symbol_layer.setSubSymbol(symbol_centroid)
        symbol.appendSymbolLayer(symbol_layer)

        renderer = QgsSingleSymbolRenderer(symbol)

        return renderer


    def loadSiteInSiteMapCanvas(self, polygon=None):
        siteNumber = self.uiSiteNumberEdit.text()
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbm.db.databaseName())
        uri.setDataSource('', 'fundort', 'geometry')

        siteLayer = QgsVectorLayer(uri.uri(), 'fundort {0}'.format(siteNumber), 'spatialite')
        self.siteLayerId = siteLayer.id()
        siteLayer.setSubsetString(u'"fundortnummer" = "{0}"'.format(siteNumber))

        siteLayer.loadNamedStyle(os.path.join(self.stylesDir, u"fundort_preview.qml"))
        #siteLayer.setRendererV2(self.getSiteRenderer())

        extent = siteLayer.extent()
        extent.scale(1.1)

        QgsProject.instance().addMapLayer(siteLayer, False)

        layerSet = []
        layerSet.append(siteLayer)

        # ÖK Background

        oekLayer28 = QgsRasterLayer(self.settings.value("APIS/oek50_gk_qgis_m28"), u"ok50_m28")
        oekLayer31 = QgsRasterLayer(self.settings.value("APIS/oek50_gk_qgis_m31"), u"ok50_m31")
        oekLayer34 = QgsRasterLayer(self.settings.value("APIS/oek50_gk_qgis_m34"), u"ok50_m34")

        # oekLayer.setCrs(QgsCoordinateReferenceSystem(31254, QgsCoordinateReferenceSystem.EpsgCrsId))
        QgsProject.instance().addMapLayer(oekLayer28, False)
        QgsProject.instance().addMapLayer(oekLayer31, False)
        QgsProject.instance().addMapLayer(oekLayer34, False)

        layerSet.append(oekLayer28)
        layerSet.append(oekLayer31)
        layerSet.append(oekLayer34)

        # # Tile Layer (Background Map)
        # ds = {}
        # ds['type'] = 'TMS'
        # ds['alias'] = 'basemap'
        # ds['copyright_text'] = 'basemaop'
        # ds['copyright_link'] = 'http://www.basemap.at'
        # #ds['tms_url'] = "https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}"
        # #ds['tms_url'] = "http://maps.wien.gv.at/basemap/bmaporthofoto30cm/normal/google3857/{z}/{y}/{x}.jpeg"
        # ds['tms_url'] = "http://maps.wien.gv.at/basemap/geolandbasemap/normal/google3857/{z}/{y}/{x}.png"
        #
        # #service_info = TileServiceInfo(ds['alias'], ds['alias'], ds['tms_url'])
        # #service_info.zmin = 0
        # #service_info.zmax = 17 #int(z)
        # #if ds.tms_y_origin_top is not None:
        # #   service_info.yOriginTop = ds.tms_y_origin_top
        # #service_info.epsg_crs_id = 3857
        # #service_info.postgis_crs_id = None
        # #service_info.custom_proj = None
        # #service_info.bbox = BoundingBox(-180, -85.05, 180, 85.05)
        #
        # service_info = TileServiceInfo(ds['alias'], ds['copyright_text'], ds['tms_url'])
        # service_info.zmin = 0
        # service_info.zmax = 17
        # #if ds.tms_y_origin_top is not None:
        # #    service_info.yOriginTop = ds.tms_y_origin_top
        # service_info.epsg_crs_id = 3857
        # service_info.postgis_crs_id = None
        # service_info.custom_proj = None
        # layer = TileLayer(service_info, False)
        #
        #
        # if not layer.isValid():
        #     error_message = ('Layer %s can\'t be added to the map!') % ds['alias']
        #     self.iface.messageBar().pushMessage('Error',
        #                                    error_message,
        #                                    level=QgsMessageBar.CRITICAL)
        #     QgsMessageLog.logMessage(error_message, level=QgsMessageLog.CRITICAL)
        # else:
        #     # Set attribs
        #     layer.setAttribution(ds['copyright_text'])
        #     layer.setAttributionUrl(ds['copyright_link'])
        #     # Insert layer
        #     #toc_root = QgsProject.instance().layerTreeRoot()
        #     #position = len(toc_root.children())  # Insert to bottom if wms\tms
        #     QgsMapLayerRegistry.instance().addMapLayer(layer, False)
        #     canvasLayer2 = QgsMapCanvasLayer(layer)
        #     layerSet.append(canvasLayer2)
        #     #toc_root.insertLayer(position, layer)
        #     #self.iface.mapCanvass()
        #
        #     # Save link
        #     #service_layers.append(layer)
        #     # Set OTF CRS Transform for map
        #     #if PluginSettings.enable_otf_3857() and ds.type == KNOWN_DRIVERS.TMS:
        #     self.uiSiteMapCanvas.setCrsTransformEnabled(True)
        #     self.uiSiteMapCanvas.setDestinationCrs(TileLayer.CRS_3857)
        #     #self.iface.mapCanvas().setDestinationCrs(QgsCoordinateReferenceSystem(3857, QgsCoordinateReferenceSystem.EpsgCrsId))


        # ds = {}
        # ds['title'] = 'basemap.at'
        # ds['attribution'] = 'basemap.at'
        # ds['attributionUrl'] = 'http://www.basemap.at'
        # ds['serviceUrl'] = "http://maps.wien.gv.at/basemap/geolandbasemap/normal/google3857/{z}/{y}/{x}.png"  # "https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}"
        # ds['yOriginTop'] = 1
        # ds['zmin'] = 0
        # ds['zmax'] = 19
        # ds['bbox'] = BoundingBox(-180, -85.05, 180, 85.05)
        #layerDef = TileLayerDefinition(ds['title'], ds['attribution'], ds['attributionUrl'], ds['serviceUrl'], ds['yOriginTop'], ds['zmin'], ds['zmax'], ds['bbox'])
        #tileLayer = TileLayer(self, service_info, False)
        #tileLayer = TileLayer(layerDef, False)
        #tileLayer.setCrs(QgsCoordinateReferenceSystem(3857, QgsCoordinateReferenceSystem.EpsgCrsId))
        #tileLayer = TileLayer(service_info, 0)
        #tileLayer.setCrs(QgsCoordinateReferenceSystem(3857, QgsCoordinateReferenceSystem.EpsgCrsId))

       # if not tileLayer.isValid():
        #    QMessageBox.information(None, "TileLayer", "TileLayer Is Not Valid")
            #error_message = self.tr('Background Layer %s can\'t be added to the map!') % ds['alias']
            #self.iface.messageBar().pushMessage(self.tr('Error'),
            #                                    error_message,
            #                                    level=QgsMessageBar.CRITICAL)
            #QgsMessageLog.logMessage(error_message, level=QgsMessageLog.CRITICAL)
        #else:
            # Set Attributes
            #QMessageBox.information(None, "TileLayer", "TileLayer Is Valid")
            #tileLayer.setAttribution(ds['copyright_text'])
            #tileLayer.setAttributionUrl(ds['copyright_url'])
        #    QgsMapLayerRegistry.instance().addMapLayer(tileLayer, False)
        #    canvasLayer2 = QgsMapCanvasLayer(tileLayer)
        #    layerSet.append(canvasLayer2)


        self.uiSiteMapCanvas.setLayers(layerSet)
        #self.uiSiteMapCanvas.refreshAllLayers()

        if polygon:
            if self.rubberBand:
                self.uiSiteMapCanvas.scene().removeItem(self.rubberBand)
                self.rubberBand = None

            self.rubberBand = QgsRubberBand(self.uiSiteMapCanvas, QgsWkbTypes.PolygonGeometry)
            self.rubberBand.setWidth(1)
            self.rubberBand.setFillColor(QColor(220, 0, 0, 120))
            self.rubberBand.setStrokeColor(QColor(220, 0, 0))
            self.rubberBand.setLineStyle(Qt.DotLine)
            self.rubberBand.addGeometry(polygon, siteLayer)
            self.rubberBand.show()
            extentNewPolygon = polygon.boundingBox()
            extentNewPolygon.scale(1.1)
            extent.combineExtentWith(extentNewPolygon)


        else:
            if self.rubberBand:
                self.uiSiteMapCanvas.scene().removeItem(self.rubberBand)
                self.rubberBand = None

        targetExtent = self.uiSiteMapCanvas.mapSettings().layerExtentToOutputExtent(siteLayer, extent)

        self.uiSiteMapCanvas.setExtent(targetExtent)
       # self.saveCanvasAsImage() # FIXME: DELTETE NOT NEEDED
       # self.uiSiteMapCanvas.zoomToFeatureIds(siteLayer, set([0]))

    def reloadMapCanvas(self):
        if self.rubberBand:
            self.uiSiteMapCanvas.scene().removeItem(self.rubberBand)
            self.rubberBand = None

        siteLayer = QgsProject.instance().mapLayer(self.siteLayerId)
        if siteLayer:
            siteLayer.reload()
            siteLayer.updateExtents()
            extent = siteLayer.extent()
            extent.scale(1.1)
            targetExtent = self.uiSiteMapCanvas.mapSettings().layerExtentToOutputExtent(siteLayer, extent)
            self.uiSiteMapCanvas.refresh()
            self.uiSiteMapCanvas.setExtent(targetExtent)
        #self.saveCanvasAsImage()
        #self.uiSiteMapCanvas.refreshAllLayers()

    def removeSitesFromSiteMapCanvas(self):
        layers = self.uiSiteMapCanvas.layers()
        for layer in layers:
            QgsProject.instance().removeMapLayer(layer.id())

    def saveCanvasAsImage(self):
        saveDir = self.settings.value("APIS/site_image_dir", QDir.home().dirName())
        # fileName = QFileDialog.getSaveFileName(self, 'Film Details', 'c://FilmDetails_{0}'.format(self.uiCurrentFilmNumberEdit.text()), '*.pdf')
        fileName = saveDir + "\\" + "Fundort_{0}.png".format(self.siteNumber)
        self.uiSiteMapCanvas.saveAsImage(fileName)

    def getRepresentativeImage(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        #query.prepare(u"SELECT CASE WHEN repraesentatives_luftbild IS NULL THEN replace(fundortnummer_legacy, '.','_') WHEN repraesentatives_luftbild ='_1' THEN replace(fundortnummer_legacy, '.','_') || '_1' ELSE repraesentatives_luftbild END as repImage FROM fundort WHERE fundortnummer = '{0}'".format(siteNumber))
        query.prepare(u"SELECT CASE WHEN repraesentatives_luftbild IS NULL THEN 0 WHEN repraesentatives_luftbild ='_1' THEN 0 ELSE repraesentatives_luftbild END as repImage FROM fundort WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        if query.value(0) == 0:
            return False
        else:
            return str(query.value(0))

    def getSiteNumberLegacy(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT fundortnummer_legacy FROM fundort WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return str(query.value(0))

    def loadRepresentativeImageForSite(self):
        # get path from settings
        path = self.settings.value("APIS/repr_image_dir", QDir.home().dirName())
        # get filename from SQL
        self.scene = QGraphicsScene()
        self.uiSiteImageView.setScene(self.scene)
        repImageName = self.getRepresentativeImage(self.siteNumber)
        if repImageName:
            path += u"\\" + repImageName + u".jpg"
            # Check if exists
            repImageFile = QFile(path)

            if repImageFile.exists():
                self.loadImage(repImageFile.fileName())
                #QMessageBox.information(None, "FileInfo", u"True, {0}".format(repImageFile.fileName()))
            else:
                self.loadText(u"Kein repräsentatives Luftbild vorhanden ...")
        else:
            self.loadText(u"Kein repräsentatives Luftbild vorhanden ...")

        self.repImageLoaded = True

    def openRepresentativeImageDialog(self):
        repImageDlg = APISRepresentativeImage(self.dbm, self.imageRegistry, self.repImagePath, self.uiProjectOrFilmEdit.text())
        repImageDlg.show()
        if repImageDlg.exec_():
            # if new Image saved Reload Image
            #update SQL
            self.copyNewImageToDestination(repImageDlg.newPath)

    def copyNewImageToDestination(self, sourceFileName):
        destinationDir = QDir(self.settings.value("APIS/repr_image_dir"))
        #TODO RM: destinationFileName = self.getSiteNumberLegacy(self.siteNumber).replace('.', '_')
        destinationFileName = self.siteNumber.replace('.', '_')
        destinationFilePath = os.path.normpath(os.path.normpath(destinationDir.absolutePath() + "\\{0}.jpg".format(destinationFileName)))

        sourceFile = QFile(os.path.normpath(sourceFileName))
        destinationFile = QFile(os.path.normpath(destinationFilePath))

        #QMessageBox.information(None, "info", sourceFile.fileName() +"\n"+ destinationFile.fileName())

        if not sourceFile.fileName() == destinationFile.fileName():
            self.loadText(u"Repräsentatives Luftbild wird geladen ...")
            if destinationFile.exists():
                destinationFile.remove()
            copyResult = sourceFile.copy(destinationFilePath)
            sqlResult = self.saveNewFileNameInDb(destinationFileName)
            self.copyImageFinished.emit(copyResult)


    def saveNewFileNameInDb(self, repImage):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"UPDATE fundort SET repraesentatives_luftbild = '{0}' WHERE fundortnummer = '{1}'".format(repImage, self.siteNumber))
        return query.exec_()

    def onCopyImageFinished(self, result):
        #if result:
        path = self.settings.value("APIS/repr_image_dir")
        # get filename from SQL
        repImageName = self.getRepresentativeImage(self.siteNumber)
        if repImageName:
            path += u"\\" + repImageName + u".jpg"
            # Check if exists
            repImageFile = QFile(path)

            if repImageFile.exists():
                self.loadImage(repImageFile.fileName())
                # QMessageBox.information(None, "FileInfo", u"True, {0}".format(repImageFile.fileName()))
            else:
                self.loadText(u"Kein repräsentatives Luftbild vorhanden ...")
        else:
            self.loadText(u"Kein repräsentatives Luftbild vorhanden ...")

    def loadImage(self, path):
        self.repImagePath = path
        self.scene.clear()
        image = QImage(path)
        size = image.size()
        self.rect = QRectF(0, 0, size.width(), size.height())
        self.scene.addPixmap(QPixmap.fromImage(image))
        self.scene.setSceneRect(self.rect)
        self.uiSiteImageView.fitInView(self.rect, Qt.KeepAspectRatio)

    def loadText(self, text):
        self.repImagePath = None
        # QMessageBox.information(None, "FileInfo", u"False, {0}".format(repImageFile.fileName()))
        self.scene.clear()
        noImageTxt = QGraphicsTextItem()
        noImageTxt.setPlainText(text)
        self.rect = noImageTxt.boundingRect()
        self.scene.addItem(noImageTxt)
        self.scene.setSceneRect(self.rect)
        self.uiSiteImageView.fitInView(self.rect, Qt.KeepAspectRatio)


    def openSiteEditFindspotHandlingDialog(self):
        if self.findspotHandlingDlg == None:
            self.findspotHandlingDlg = APISSiteEditFindspotConflictHandling(self.iface, self.dbm, {self.siteNumber: [self.newPolygon, self.oldPolygon, self.newPolygon.buffer(0.0001, 12)]})
        res = self.findspotHandlingDlg.exec_()
        if res:
            # fortfahren, get desissions made ...
            #QMessageBox.information(None, u"FO Updates", u"Fortfahren")
            actions = self.findspotHandlingDlg.getActions()
            return actions
        else:
            # cancel all edits and close dialog
            # QMessageBox.information(None, u"FO Updates", u"Abbrechen")
            return None


    def showEvent(self, event):
        self.loadRepresentativeImageForSite()
        #self.isActive = True
        if self.addMode and self.isFilmBased:
            self.openRepresentativeImageDialog()


    def resizeEvent(self, event):
        if self.repImageLoaded:
            self.uiSiteImageView.fitInView(self.rect, Qt.KeepAspectRatio)


class SiteDelegate(QSqlRelationalDelegate):
    def __init__(self):
       QSqlRelationalDelegate.__init__(self)

    def createEditor(self, parent, option, index):
        pass

    def setEditorData(self, editor, index):
        #QMessageBox.warning(None, "Test", str(editor.metaObject().className(index))()) + str
        value = str(index.model().data(index, Qt.EditRole))

        if value == 'NULL':
            value = ''

        if editor.metaObject().className() == 'QTimeEdit' and value == '':
            editor.setTime(QTime(0,0,0))
            #if value == '':
                #value ="00:00:00"
                #QMessageBox.warning(None, "Test", unicode(index.model().data(index, Qt.EditRole)))

        elif editor.metaObject().className() == 'QLineEdit':
            editor.setText(value)

        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 26: #sicherheit
                if value == '':
                    editor.setCurrentIndex(-1)
                else:
                    editor.setCurrentIndex(int(value)-1)
            else:
                editor.setEditText(value)

        elif editor.metaObject().className() == 'QListWidget':
            #QMessageBox.warning(None, "Test", unicode(index.model().data(index, Qt.EditRole)))
            editor.clear()
            editor.addItems(str.split(value, ";"))
        else:
            QSqlRelationalDelegate.setEditorData(self, editor, index)

    def setModelData(self, editor, model, index):
        #if editor.metaObject().className() == 'QLineEdit':
            #QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #if unicode(index.data(Qt.DisplayRole)) != unicode(editor.text()):
            #    QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #    model.setData(index, editor.text())


        if editor.metaObject().className() == 'QDateEdit':
            model.setData(index, editor.date().toString("yyyy-MM-dd"))
        elif editor.metaObject().className() == 'QTimeEdit':
            model.setData(index, editor.time().toString("HH:mm:ss"))
        elif editor.metaObject().className() == 'QListWidget':
            items = []
            for j in range(editor.count()):
                items.append(editor.item(j))
            model.setData(index, ";".join([i.text() for i in items]))
        #elif (editor.metaObject().className() == 'QLineEdit' and editor.text()==''):
        #    model.setData(model.createIndex(index.row(), 0), None)
        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 26: #26 = sicherheit
                model.setData(index, editor.currentIndex()+1)
            else:
                model.setData(index, editor.currentText())
        else:
            QSqlRelationalDelegate.setModelData(self, editor, model, index)

class InListValidator(QValidator):
        def __init__(self, itemList, editor, depend, parent):
            QValidator.__init__(self, parent)

            self.itemList = itemList
            self.editor = editor
            self.depend = depend

        def validate(self, s, pos):

            if str(s) in self.itemList or str(s).strip()=='':
                if self.depend and str(s).strip()=='':
                    for dep in self.depend:
                        for key, value in dep.iteritems():
                            value.setText("")
                return (QValidator.Acceptable, s, pos)

            return (QValidator.Invalid, "", pos)


        def fixup(self, s):
            #QMessageBox.warning(None, "Test", unicode(s))
            self.editor.setText("")