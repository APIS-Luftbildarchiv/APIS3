# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APIS
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018-2020 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna (luftbildarchiv.univie.ac.at)
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Standard Libs
import os
import re
import glob
import traceback

# PyQt
from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QPushButton, QFileDialog
from PyQt5.QtCore import QSettings, QDate, QDir, QThread, QObject, pyqtSignal
from PyQt5.QtSql import QSqlQuery

# PyQGIS
from qgis.core import (QgsVectorDataProvider, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsPointXY,
                       QgsFeatureRequest, QgsExpression, QgsVectorLayerUtils, QgsDistanceArea, QgsProject, QgsWkbTypes, Qgis, QgsMessageLog)

# APIS
from APIS.src.apis_utils import (TransformGeometry, GetMeridianAndEpsgGK, SetWindowSize, GetWindowSize, GetExifForImage,
                                 CopyFiles, OpenFileOrFolder, GetExportPath, SetExportPath, GetCountryCode, CalculateImageRadius)

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_image_digital_auto_import.ui'), resource_suffix='')


class APISDigitalImageAutoImport(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, apisLayer, targetLayerCP, targetLayerFP, filmId, parent=None):
        """Constructor."""
        super(APISDigitalImageAutoImport, self).__init__(parent)

        self.setupUi(self)
        if GetWindowSize("image_digital_auto_import"):
            self.resize(GetWindowSize("image_digital_auto_import"))

        self.accepted.connect(self.onClose)
        self.rejected.connect(self.onClose)

        self.iface = iface
        self.dbm = dbm
        self.apisLayer = apisLayer
        self.filmId = filmId
        self.parent = parent
        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        # update UI regarding orientation
        self.updateUiForFilmMode(self.parent.isOblique)

        self.targetLayerCP = targetLayerCP
        self.targetLayerFP = targetLayerFP

        self.uiReportPTxt.setCenterOnScroll(True)
        self.writeMsg(u"Auto Import digitaler Bilder für Film: {0}".format(self.filmId))
        self.uiImportBtn.clicked.connect(self.runImport)
        self.uiImportBtn.setEnabled(False)

        self.uiMonoplotSourceGrp.toggled.connect(lambda: self.toggleSourceGroups(friend=self.uiOrientalSourceGrp))
        self.uiOrientalSourceGrp.toggled.connect(lambda: self.toggleSourceGroups(friend=self.uiMonoplotSourceGrp))

        self.importMode = 0  # 0 .. ins2cam, 1 .. oriental, 2 .. vexcel

        self.uiMonoplotSourceGrp.clicked.connect(self.activateIns2CamMode)
        self.uiOrientalSourceGrp.clicked.connect(self.activateOrientalMode)

        self.uiCenterPointFileTBtn.clicked.connect(lambda: self.getSourceFile(editor=self.uiCenterPointSourceEdit, caption="Quelldatei für Centerpoint Layer auswählen"))
        self.uiFootprintFileTBtn.clicked.connect(lambda: self.getSourceFile(editor=self.uiFootprintSourceEdit, caption="Quelldatei für Footprint Layer auswählen"))
        self.uiAutodetectIns2CamSourcesBtn.clicked.connect(self.autodetectSourcesIns2Cam)
        self.uiCenterPointSourceEdit.textChanged.connect(self.checkIfEmpty)
        self.uiFootprintSourceEdit.textChanged.connect(self.checkIfEmpty)
        self.uiImageDirTBtn.clicked.connect(lambda: self.getSourceDir(editor=self.uiImageSourceEdit, caption="Quellverzeichnis für Bilder (EXIF-Import) auswählen"))

        self.uiOrientalDirTBtn.clicked.connect(lambda: self.getSourceDir(editor=self.uiOrientalSourceEdit, caption="Quellverzeichnis für OrientAL Aktualisierung auswählen"))
        self.uiAutodetectOrientalSourceBtn.clicked.connect(self.autodetectSourcesOriental)
        self.uiOrientalSourceEdit.textChanged.connect(self.checkIfEmpty)

        self.uiVexcelDirTBtn.clicked.connect(lambda: self.getSourceFile(editor=self.uiVexcelSourceEdit, caption="Quelldatei für Vexcel Import (KML) auswählen"))
        self.uiAutodetectVexcelSourceBtn.clicked.connect(self.autodetectSourcesVexcel)
        self.uiVexcelSourceEdit.textChanged.connect(self.checkIfEmpty)

        self.getExistingImages()
        if self.parent.isOblique:
            self.autodetectSourcesIns2Cam()
            self.autodetectSourcesOriental()
        else:
            self.activateVexcelMode(True)
            self.autodetectSourcesVexcel()

    def checkIfEmpty(self, text):
        # QMessageBox.information(self, "Info", text)
        if len(text.strip()) == 0:
            self.sender().setText("")
        if self.importMode == 0:  # ins2cam
            if len(self.uiCenterPointSourceEdit.text().strip()) == 0 or len(self.uiFootprintSourceEdit.text().strip()) == 0:
                self.uiImportBtn.setEnabled(False)
            else:
                self.uiImportBtn.setEnabled(True)
        elif self.importMode == 1:  # oriental
            if len(self.uiOrientalSourceEdit.text().strip()) == 0:
                self.uiImportBtn.setEnabled(False)
            else:
                self.uiImportBtn.setEnabled(True)
        elif self.importMode == 2:  # vexcel
            if len(self.uiVexcelSourceEdit.text().strip()) == 0:
                self.uiImportBtn.setEnabled(False)
            else:
                self.uiImportBtn.setEnabled(True)

    def updateUiForFilmMode(self, isOblique):
        self.uiMonoplotSourceGrp.setVisible(isOblique)
        self.uiOrientalSourceGrp.setVisible(isOblique)
        # self.uiImageSourceGrp.setVisible(isOblique)
        self.uiVexcelSourceGrp.setVisible(not isOblique)

    def toggleSourceGroups(self, friend):
        on = self.sender().isChecked()
        friend.setChecked(not on)

    def activateIns2CamMode(self, checked):
        if checked:
            self.importMode = 0

    def activateOrientalMode(self, checked):
        if checked:
            self.importMode = 1

    def activateVexcelMode(self, checked):
        if checked:
            self.importMode = 2

    def getExistingImages(self):
        existingImagesCP = QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0]
        existingImagesFP = QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0]
        return existingImagesCP, existingImagesFP

    def autodetectSourcesIns2Cam(self):
        imageBasePath = self.settings.value("APIS/image_dir")
        monoplotPath = self.settings.value("APIS/monoplot_dir")
        sourceCpLayerShp = "{0}.{1}".format(self.settings.value("APIS/monoplot_cp_shp"), u"shp")
        sourceFpLayerShp = "{0}.{1}".format(self.settings.value("APIS/monoplot_fp_shp"), u"shp")
        sourceCpLayerPath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath, sourceCpLayerShp))
        sourceFpLayerPath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath, sourceFpLayerShp))

        if os.path.isfile(sourceCpLayerPath):
            self.uiCenterPointSourceEdit.setText(sourceCpLayerPath)
        else:
            self.uiCenterPointSourceEdit.clear()

        if os.path.isfile(sourceFpLayerPath):
            self.uiFootprintSourceEdit.setText(sourceFpLayerPath)
        else:
            self.uiFootprintSourceEdit.clear()

    def autodetectSourcesOriental(self):
        imageBasePath = self.settings.value("APIS/image_dir")
        orientalPath = self.settings.value("APIS/oriental_dir")
        orientalSourceDir = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, orientalPath))

        if os.path.isdir(orientalSourceDir):
            self.uiOrientalSourceEdit.setText(orientalSourceDir)
        else:
            self.uiOrientalSourceEdit.clear()

    def autodetectSourcesVexcel(self):
        imageBasePath = self.settings.value("APIS/image_dir")
        vexcelPath = self.settings.value("APIS/vexcel_dir")
        vexcelSourceDir = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, vexcelPath))

        if os.path.isdir(vexcelSourceDir):
            self.uiVexcelSourceEdit.setText(vexcelSourceDir)
        else:
            self.uiVexcelSourceEdit.clear()

    def getSourceFile(self, editor, caption="Quelldatei auswählen"):
        sourceFileName = QFileDialog.getOpenFileName(self, caption, GetExportPath())
        #QMessageBox.information(None, "SourceInfo", f"type: {type(sourceFileName[0])}, leng: {len(sourceFileName)}, data: {sourceFileName[0]}")
        if sourceFileName and sourceFileName[0]:
            editor.setText(os.path.normpath(sourceFileName[0]))
            SetExportPath(os.path.dirname(os.path.normpath(sourceFileName[0])))
        else:
            editor.clear()

    def getSourceDir(self, editor, caption="Quellverzeichnis auswählen"):
        sourceDirName = QFileDialog.getExistingDirectory(self, caption, GetExportPath(), QFileDialog.DontUseNativeDialog)
        if sourceDirName:
            editor.setText(os.path.normpath(sourceDirName))
            SetExportPath(os.path.dirname(os.path.normpath(sourceDirName)))

    def areSourceLayerIns2Cam(self, sourceLayerCP, sourceLayerFP):
        if sourceLayerCP.geometryType() != QgsWkbTypes.PointGeometry or sourceLayerFP.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "Zumindest einer der Layer hat einen falschen Geometrie Typ (Centerpoint GeometryType: {0}, Footprint GeometryType: {1})".format(sourceLayerCP.geometryType(), sourceLayerFP.geometryType())
        if sourceLayerCP.featureCount() == 0 or sourceLayerFP.featureCount() == 0:
            return False, "Zumindest einer der Layer hat keine Features (Centerpoint: {0}, Footprint: {1})".format(sourceLayerCP.featureCount(), sourceLayerFP.featureCount())
        if sourceLayerCP.featureCount() != sourceLayerFP.featureCount():
            return False, "Die Feature Anzahl stimmt nicht überein (Centerpoint: {0}, Footprint: {1})".format(sourceLayerCP.featureCount(), sourceLayerFP.featureCount())

        # required attribute 'Image'
        provCP = sourceLayerCP.dataProvider()
        fieldNamesCP = set([field.name() for field in provCP.fields()])
        if "Image" not in fieldNamesCP:
            return False, "Der Centerpoint Layer hat kein Attribut 'Image'."

        provFP = sourceLayerFP.dataProvider()
        fieldNamesFP = set([field.name() for field in provFP.fields()])
        if "Image" not in fieldNamesFP:
            return False, "Der Footprint Layer hat kein Attribut 'Image'."

        numOfImagesCPSet = set([feature["Image"] for feature in sourceLayerCP.getFeatures()])
        numOfImagesFPSet = set([feature["Image"] for feature in sourceLayerFP.getFeatures()])

        if numOfImagesCPSet != numOfImagesFPSet:
            return False, "Die Werte des Attributes 'Image' stimmen zwischen den Layern nicht überein."

        filmNumberCP = set([feature["Image"].split('_')[0] for feature in sourceLayerCP.getFeatures()])
        if len(filmNumberCP) != 1:
            return False, "Im Centerpoint Layer gibt es Bilder von mehr als einem Film ({0}).".format(u', '.join(list(filmNumberCP)))

        filmNumber = list(filmNumberCP)[0]
        if len(filmNumber) == 8:
            #old Id
            mil = u""
            if filmNumber[:2] == u"01":
                mil = u"19"
            elif filmNumber[:2] == u"02":
                mil = u"20"
            else:
                return False, u"Die Filmnummer im Centerpoint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format(filmNumber)
            filmNumber = u"01{0}{1}".format(mil, filmNumber[2:])
        elif len(filmNumber) == 10:
            #new Id
            pass
        else:
            return False, u"Die Filmnummer im Centerpoint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format(filmNumber)

        if filmNumber != self.filmId:
            return False, u"Im Centerpoint Layer sind Bilder eines anderen Films ({0}).".format(list(filmNumberCP)[0])

        filmNumberFP = set([feature["Image"].split('_')[0]for feature in sourceLayerFP.getFeatures()])
        if len(filmNumberFP) != 1:
            return False, u"Im Footprint Layer gibt es Bilder von mehr als einem Film ({0}).".format(u', '.join(list(filmNumberFP)))

        filmNumber = list(filmNumberFP)[0]
        if len(filmNumber) == 8:
            #old Id
            mil = u""
            if filmNumber[:2] == u"01":
                mil = u"19"
            elif filmNumber[:2] == u"02":
                mil = u"20"
            else:
                return False, u"Die Filmnummer im Footprint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format(filmNumber)
            filmNumber = u"01{0}{1}".format(mil, filmNumber[2:])
        elif len(filmNumber) == 10:
            #new Id
            pass
        else:
            return False, u"Die Filmnummer im Footprint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format(filmNumber)

        if filmNumber != self.filmId:
            return False, "Im Footprint Layer sind Bilder eines anderen Films ({0}).".format(list(filmNumberFP)[0])

        return True, "MonoplotLayer"

    def isSourceLayerOriental(self, orientalLayer):
        # only one feature
        if orientalLayer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "Ein OrientAL Layer muss vom Typ PolygonGeometry sein (GeometryType: {0})".format(orientalLayer.geometryType())
        if orientalLayer.featureCount() != 1:
            return False, "Ein OrientAL Layer muss genau ein Feature enthalten (FeatureCount: {0})".format(orientalLayer.featureCount())
        # field ImageId
        prov = orientalLayer.dataProvider()
        fieldNames = set([field.name() for field in prov.fields()])
        if "ImageId" not in fieldNames:
            return False, "Der OrientAL Layer hat kein Attribut 'ImageId'."

        return True, "OrientalLayer"

    def checkIfTargetIsClean(self):
        errorMsg = ""
        if self.targetLayerCP.featureCount() != self.targetLayerFP.featureCount():
            errorMsg += "Die Feature Anzahl bereits kartierter Bilder stimmt nicht überein (Centerpoint: {0}, Footprint: {1})".format(self.targetLayerCP.featureCount(), self.targetLayerFP.featureCount())

        existingFeaturesCP = set(QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0])
        existingFeaturesFP = set(QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0])
        CPwoFP = list(set(existingFeaturesCP) - set(existingFeaturesFP))
        FPwoCP = list(set(existingFeaturesFP) - set(existingFeaturesCP))

        if len(CPwoFP) > 0 or len(FPwoCP) > 0:
            if len(errorMsg) > 0:
                errorMsg += "\n"
            errorMsg += "Bitte beheben Sie folgende Probleme vor dem Import. Centerpoints ohne Footprints oder umgekehrt"
            if len(CPwoFP) > 0:
                errorMsg += "\n{0}".format(", ".join(CPwoFP))
            if len(FPwoCP) > 0:
                errorMsg += "\n{0}".format(", ".join(FPwoCP))

        if len(errorMsg) > 0:
            return False, errorMsg
        else:
            return True, "Die APIS Bild-Tabellen sind bereit für den Auto Import von Ins2Cam Bildern."

    def calculateImageRadius(self, centerPoint, polygon, minValue=175):
        polyline = polygon.asPolygon()[0]
        points = [QgsGeometry.fromPointXY(point) for point in polyline[:-1]]
        dists = [point.distance(centerPoint) for point in points]
        r = int((sorted(dists)[0] + sorted(dists)[1]) / 2.0)
        return r if r > minValue else minValue

    def writeMsg(self, msg):
        self.uiReportPTxt.insertPlainText(msg)
        self.uiReportPTxt.insertPlainText(u"\n")
        self.uiReportPTxt.ensureCursorVisible()

    def runImport(self):
        self.uiImportBtn.setEnabled(False)
        self.uiReportPTxt.clear()
        self.writeMsg("Auto Import digitaler Bilder für Film: {0}".format(self.filmId))
        if self.importMode == 0:
            self.runImportIns2Cam()
        elif self.importMode == 1:
            self.runImportOrientalWorker()
        elif self.importMode == 2:
            self.runImportVexcel()
        else:
            return

    def runImportIns2Cam(self):
        centerPointSourcePath = self.uiCenterPointSourceEdit.text()
        footprintSourcePath = self.uiFootprintSourceEdit.text()
        if os.path.isfile(centerPointSourcePath) and os.path.isfile(footprintSourcePath):
            epsg = self.settings.value("APIS/monoplot_epsg", type=int)
            sourceLayerIns2CamCP = self.apisLayer.requestShapeFile(centerPointSourcePath, epsg, None, "Bildkartierung", True, True)
            sourceLayerIns2CamFP = self.apisLayer.requestShapeFile(footprintSourcePath, epsg, None, "Bildkartierung", True, True)
            if not sourceLayerIns2CamCP.isValid() or not sourceLayerIns2CamCP.isSpatial() or not sourceLayerIns2CamFP.isValid() or not sourceLayerIns2CamFP.isSpatial():
                QMessageBox.warning(None, "Ins2Cam Import", "Die ausgewählten Centerpoint und Footprint Layer sind für den Ins2Cam Import ungeeignet:\nZumindest eine der zwei angegbenen Dateien hat kein passendes Dateiformat.")
                return
        else:
            QMessageBox.warning(None, "Ins2Cam Import", "Die ausgewählten Centerpoint und Footprint Layer sind für den Ins2Cam Import ungeeignet:\nZumindest eine der zwei angegbenen Dateien existiert nicht.")
            return

        # check if target (in APIS DB) is clean (same number of images mapped
        resCheckSource, msgCheckSource = self.areSourceLayerIns2Cam(sourceLayerIns2CamCP, sourceLayerIns2CamFP)
        resCheckTarget, msgCheckTarget = self.checkIfTargetIsClean()

        if resCheckSource and resCheckTarget:
            iterCP = sourceLayerIns2CamCP.getFeatures()
            iterFP = sourceLayerIns2CamFP.getFeatures()
            existingFeaturesCP = QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0]
            existingFeaturesFP = QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0]

            mode = 1  # add
            if self.targetLayerCP.featureCount() > 0 or self.targetLayerFP.featureCount() > 0:

                msgBox = QMessageBox()
                msgBox.setWindowTitle('Ins2Cam Import')
                msgBox.setText("Für den Film {0} sind kartierte Bilder vorhanden:".format(self.filmId))
                msgBox.addButton(QPushButton('Überschreiben'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton('Nicht überschreiben'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton('Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()
                if ret == 0:
                    mode = 2  # overwrite
                    self.writeMsg("Bereits kartierte Bilder: überschreiben")
                elif ret == 1:
                    mode = 3  # not overwrite/skip
                    self.writeMsg("Bereits kartierte Bilder: nicht überschreiben")
                else:
                    self.writeMsg("Vorgang wurde abgebrochen.")
                    self.uiImportBtn.setEnabled(True)
                    return

            capsCP = self.targetLayerCP.dataProvider().capabilities()
            capsFP = self.targetLayerFP.dataProvider().capabilities()
            if capsCP & QgsVectorDataProvider.AddFeatures and capsFP & QgsVectorDataProvider.AddFeatures:
                featuresCP = []
                featuresFP = []
                imagesToDelete = []
                sourceFeatCP = QgsFeature()
                sourceFeatFP = QgsFeature()
                i = 0
                while iterCP.nextFeature(sourceFeatCP):
                    i += 1
                    iterFP.nextFeature(sourceFeatFP)
                    sINCP = re.search(r'^(.+\d)_([0-9][0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9]\.tif|[0-9][0-9]\.tif|[0-9]\.tif|[0-9][0-9][0-9])$', sourceFeatCP["Image"])
                    sINFP = re.search(r'^(.+\d)_([0-9][0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9]\.tif|[0-9][0-9]\.tif|[0-9]\.tif|[0-9][0-9][0-9])$', sourceFeatFP["Image"])
                    if sINCP and sINFP:
                        if sINCP.group(0) == sINFP.group(0):
                            imageNumber = int(sINCP.group(0).split('_')[1].split('.')[0])
                            imageNumberFP = int(sINFP.group(0).split('_')[1].split('.')[0])
                        else:
                            self.writeMsg("SKIP: Die fortlaufende Bildnummer in Reihe {0} stimmen im Centerpoint ({1}) und Footprint ({2}) Layer nicht überein.".format(i, imageNumber, imageNumberFP))
                            continue
                    else:
                        self.writeMsg("SKIP: Die Eintrag in Reihe {0} hat keine entsprechende Bildnummer (Filmnummer + fortlaufende Bildnummer)".format(i))
                        continue

                    filmImageNumber = '{0}.{1:03d}'.format(self.filmId, imageNumber)

                    if filmImageNumber in existingFeaturesCP or filmImageNumber in existingFeaturesFP:
                        if mode == 2:
                            # überschreiben
                            #QMessageBox.warning(None, u"Bild Nummern", u"Ein Bild mit der Nummer {0} wurde bereits kartiert".format(imageNumber))
                            self.writeMsg(u"UPDATE: {0}: wird überschrieben.".format(filmImageNumber))
                            imagesToDelete.append(filmImageNumber)

                        elif mode == 3:
                            # nicht überschreiben
                            self.writeMsg(u"SKIP: {0}: wurde bereits kartiert.".format(filmImageNumber))
                            continue
                    else:
                        self.writeMsg(u"NEW: {0}: wird erstellt.".format(filmImageNumber))

                    # CENTERPOINT
                    targetFeatCP = QgsFeature(self.targetLayerCP.fields())
                    targetGeometryCP = TransformGeometry(QgsGeometry(sourceFeatCP.geometry()), sourceLayerIns2CamCP.crs(), self.targetLayerCP.crs())
                    targetFeatCP.setGeometry(targetGeometryCP)

                    # From Film Table
                    # filmFields = ["form1", "form2", "weise", "kammerkonstante"]
                    targetFeatCP.setAttribute('filmnummer_hh_jjjj_mm', self.parent.currentFilmInfoDict["filmnummer_hh_jjjj_mm"])
                    targetFeatCP.setAttribute('filmnummer_nn', self.parent.currentFilmInfoDict["filmnummer_nn"])
                    targetFeatCP.setAttribute('filmnummer', self.parent.currentFilmNumber)

                    targetFeatCP.setAttribute('bildnummer_nn', imageNumber)
                    targetFeatCP.setAttribute('bildnummer', filmImageNumber)

                    # Date TODAY
                    now = QDate.currentDate()
                    targetFeatCP.setAttribute('datum_ersteintrag', now.toString("yyyy-MM-dd"))
                    targetFeatCP.setAttribute('datum_aenderung', now.toString("yyyy-MM-dd"))

                    targetFeatCP.setAttribute('copyright', self.parent.currentFilmInfoDict["copyright"])
                    targetFeatCP.setAttribute('etikett', 0)  # By default fixed value of 0

                    # Calculated/Derived
                    cp = targetFeatCP.geometry().asPoint()
                    targetFeatCP.setAttribute('longitude', cp.x())
                    targetFeatCP.setAttribute('latitude', cp.y())

                    countryCode = GetCountryCode(self.dbm.db, cp)
                    targetFeatCP.setAttribute('land', countryCode)

                    if countryCode == 'AUT':
                        # get meridian and epsg Code
                        meridian, epsgGK = GetMeridianAndEpsgGK(cp.x())

                        # get KG Coordinates
                        gk = TransformGeometry(QgsGeometry(targetFeatCP.geometry()), self.targetLayerCP.crs(), QgsCoordinateReferenceSystem(f"EPSG:{epsgGK}"))
                        gkx = gk.asPoint().y()  # Hochwert
                        gky = gk.asPoint().x()  # Rechtswert
                    else:
                        meridian = None
                        gkx = None
                        gky = None

                    targetFeatCP.setAttribute('meridian', meridian)
                    targetFeatCP.setAttribute('gkx', gkx)  # Hochwert
                    targetFeatCP.setAttribute('gky', gky)  # Rechtswert

                    # TODO extend so the Images can be local!
                    # 1) if uiImageSourceEdit is empty, is no dir then use Deafault Dir
                    # 2) if isDir and dir has filmImageNumber.replace('.', '_') + '.jpg' use this File! else fall back to default
                    # self.writeMsg() which dir was used!
                    if os.path.isdir(self.uiImageSourceEdit.text()) and os.path.isfile(os.path.join(self.uiImageSourceEdit.text(), filmImageNumber.replace('.', '_') + '.jpg')):
                        image = os.path.normpath(os.path.join(self.uiImageSourceEdit.text(), filmImageNumber.replace('.', '_') + '.jpg'))
                        self.writeMsg(f"EXIF from: {image}")
                    else:
                        image = os.path.normpath(os.path.join(self.settings.value("APIS/image_dir"), self.filmId, filmImageNumber.replace('.', '_') + '.jpg'))
                        if os.path.isfile(image):
                            self.writeMsg(f"EXIF from default directory: {image}")
                        else:
                            self.writeMsg(f"EXIF from default directory: Image not found!")
                    # image = os.path.normpath(self.settings.value("APIS/image_dir") + '\\' + self.filmId + '\\' + filmImageNumber.replace('.', '_') + '.jpg')

                    exif = GetExifForImage(image, altitude=True, longitude=True, latitude=True, exposure_time=True, focal_length=True, fnumber=True)

                    targetFeatCP.setAttribute('hoehe', exif["altitude"] if exif["altitude"] else 450)  # TODO: Is this the best way to set hight to 0 if no image is there? 436 is the average hight of all oblique images
                    targetFeatCP.setAttribute('gps_longitude', exif["longitude"] if exif["longitude"] is not None else None)
                    targetFeatCP.setAttribute('gps_latitude', exif["latitude"] if exif["latitude"] is not None else None)
                    targetFeatCP.setAttribute('kappa', QgsPointXY(exif["longitude"], exif["latitude"]).azimuth(cp) if exif["longitude"] and exif["latitude"] else None)
                    targetFeatCP.setAttribute('belichtungszeit', exif["exposure_time"] if exif["exposure_time"] is not None else None)
                    targetFeatCP.setAttribute('fokus', exif["focal_length"] if exif["focal_length"] is not None else None)  # FocalLength
                    targetFeatCP.setAttribute('blende', exif["focal_length"] / exif["fnumber"] if exif["focal_length"] and exif["fnumber"] else None)  # effecitve aperture (diameter of entrance pupil) = focalLength / fNumber

                    # FOOTPRINT
                    targetFeatFP = QgsFeature(self.targetLayerFP.fields())

                    #self.writeMsg('source FP: ' + sourceFeatFP.geometry().asWkt())
                    sourceGeometryFP = QgsGeometry(sourceFeatFP.geometry())
                    if sourceGeometryFP.isMultipart():
                        sourceGeometryFP.convertToSingleType()

                    targetFeatCP.setAttribute('radius', str(self.calculateImageRadius(sourceFeatCP.geometry(), sourceGeometryFP)))

                    targetGeometryFP = TransformGeometry(sourceGeometryFP, sourceLayerIns2CamFP.crs(), self.targetLayerFP.crs())
                    targetFeatFP.setGeometry(targetGeometryFP)

                    targetFeatFP.setAttribute('filmnummer', self.parent.currentFilmNumber)
                    targetFeatFP.setAttribute('bildnummer', filmImageNumber)
                    da = QgsDistanceArea()
                    da.setEllipsoid(self.targetLayerFP.crs().ellipsoidAcronym())
                    targetFeatFP.setAttribute('shape_length', round(da.measurePerimeter(targetGeometryFP), 3))
                    targetFeatFP.setAttribute('shape_area', round(da.measureArea(targetGeometryFP), 3))
                    targetFeatFP.setAttribute('source', 'imu')

                    featuresCP.append(targetFeatCP)
                    featuresFP.append(targetFeatFP)

                # remove source map layers
                QgsProject.instance().removeMapLayer(sourceLayerIns2CamCP)
                QgsProject.instance().removeMapLayer(sourceLayerIns2CamFP)
                del sourceLayerIns2CamCP
                del sourceLayerIns2CamFP

                if imagesToDelete:
                    request = QgsFeatureRequest().setFilterExpression(u'"bildnummer" IN ({0})'.format(u', '.join(u'\'{0}\''.format(img) for img in imagesToDelete)))
                    featureIdsCPToDelete = []
                    featureIdsFPToDelete = []

                    for f in self.targetLayerCP.getFeatures(request):
                        featureIdsCPToDelete.append(f.id())

                    for f in self.targetLayerFP.getFeatures(request):
                        featureIdsFPToDelete.append(f.id())

                    res = self.targetLayerCP.dataProvider().deleteFeatures(featureIdsCPToDelete)
                    res = self.targetLayerFP.dataProvider().deleteFeatures(featureIdsFPToDelete)

                if featuresCP:
                    (res, outFeats) = self.targetLayerCP.dataProvider().addFeatures(featuresCP)
                    self.targetLayerCP.updateExtents()

                if featuresFP:
                    (res, outFeats) = self.targetLayerFP.dataProvider().addFeatures(featuresFP)
                    self.targetLayerFP.updateExtents()

                if self.iface.mapCanvas().isCachingEnabled():
                    self.targetLayerCP.triggerRepaint()
                    self.targetLayerFP.triggerRepaint()
                else:
                    self.iface.mapCanvas().refresh()

                if self.uiCopyToIns2camDirChk.isChecked():
                    imageBasePath = self.settings.value("APIS/image_dir")
                    monoplotPath = self.settings.value("APIS/monoplot_dir")
                    defaultCpFileName = self.settings.value("APIS/monoplot_cp_shp")
                    defaultFpFileName = self.settings.value("APIS/monoplot_fp_shp")
                    destinationDirName = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath))

                    # get all shape files!
                    cpDir = QDir(os.path.dirname(centerPointSourcePath))
                    cpDirFiles = cpDir.entryList([os.path.splitext(os.path.basename(centerPointSourcePath))[0] + "*"], QDir.Files)
                    cpFilesToCopy = [{'source': os.path.normpath(os.path.join(os.path.dirname(centerPointSourcePath), cpDirFile)), 'destination': os.path.normpath(os.path.join(destinationDirName, "{0}{1}".format(defaultCpFileName, os.path.splitext(cpDirFile)[1])))} for cpDirFile in cpDirFiles]

                    fpDir = QDir(os.path.dirname(footprintSourcePath))
                    fpDirFiles = fpDir.entryList([os.path.splitext(os.path.basename(footprintSourcePath))[0] + "*"], QDir.Files)
                    fpFilesToCopy = [{'source': os.path.normpath(os.path.join(os.path.dirname(footprintSourcePath), fpDirFile)), 'destination': os.path.normpath(os.path.join(destinationDirName, "{0}{1}".format(defaultFpFileName, os.path.splitext(fpDirFile)[1])))} for fpDirFile in fpDirFiles]

                    for cpFileToCopy in cpFilesToCopy:
                        self.writeMsg("{0} > {1}".format(cpFileToCopy['source'], cpFileToCopy['destination']))
                    for fpFileToCopy in fpFilesToCopy:
                        self.writeMsg("{0} > {1}".format(fpFileToCopy['source'], fpFileToCopy['destination']))

                    filesToCopy = cpFilesToCopy + fpFilesToCopy
                    if filesToCopy:
                        if CopyFiles(filesToCopy, destinationDirName, checkDestination=True, parent=self):
                            OpenFileOrFolder(destinationDirName)

            else:
                QMessageBox.warning(None, "Layer Capabilities!", "Probleme mit Layer Capabilities!")

        else:
            if not resCheckSource:
                QMessageBox.warning(None, "Ins2Cam Import", "Die Ausgewählten Centerpoint und Footprint Layer sind für den Ins2Cam Import ungeeignet:\n{0}".format(msgCheckSource))

            if not resCheckTarget:
                QMessageBox.warning(None, "Ins2Cam Import", "Es sind Probleme bei bereits kartierten Bildern vorhanden:\n{0}".format(msgCheckTarget))

    def runImportOrientalWorker(self):
        orientalSourceDir = self.uiOrientalSourceEdit.text()

        # check: not set or not a dir
        if not orientalSourceDir or not os.path.isdir(orientalSourceDir):
            QMessageBox.warning(None, "OrientAL Import", "Das ausgewählte Verzeichnis ist für den OrientAL Import ungeeignet:\nDas Verzeichnis existiert nicht.")
            return

        # check for oriental files
        self.orientalSourceFiles = glob.glob(os.path.normpath(orientalSourceDir + "\\{0}_[0-9][0-9][0-9].shp".format(self.parent.currentFilmNumber)))

        if self.orientalSourceFiles and len(self.orientalSourceFiles) > 0:
            worker = OrientalImportWorker(self.orientalSourceFiles, self.settings, self.dbm, self.apisLayer, self.filmId, self.targetLayerCP, self.targetLayerFP)
            # start the worker in a new thread
            thread = QThread()
            worker.moveToThread(thread)
            worker.finished.connect(self.workerOrientalFinished)
            worker.error.connect(self.workerError)
            worker.message.connect(self.writeMsg)
            thread.started.connect(worker.run)
            thread.start()
            self.threadOriental = thread
            self.workerOriental = worker
        else:
            QMessageBox.warning(None, "OrientAL Import", "Das ausgewählte Verzeichnis ist für den OrientAL Import ungeeignet:\nDas Verzeichnis enthält keine OrientAL SHP Dateien für den Film {0} mit dem Dateinamenmuster {0}_XXX.shp".format(self.parent.currentFilmNumber))
            self.threadOriental = None
            self.workerOriental = None
            return

    def workerOrientalFinished(self, result):
        # clean up the worker and thread
        self.workerOriental.deleteLater()
        self.threadOriental.quit()
        self.threadOriental.wait()
        self.threadOriental.deleteLater()
        if result is not None:
            self.writeMsg("-----\nImport abgeschloßen!")
            self.targetLayerCP.updateExtents()
            self.targetLayerCP.triggerRepaint()
            self.targetLayerFP.updateExtents()
            self.targetLayerFP.triggerRepaint()

            # Initiate Copy Files
            if self.uiCopyToOrientalDirChk.isChecked() and self.orientalSourceFiles:
                self.writeMsg("-----\nSource Datien werden in das Standardverzeichnis kopiert.")
                imageBasePath = self.settings.value("APIS/image_dir")
                orientalPath = self.settings.value("APIS/oriental_dir")
                destinationDirName = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, orientalPath))

                # get all shape files!
                orientalFilesToCopy = []
                for orientalSourceFile in self.orientalSourceFiles:
                    sourceDir = QDir(os.path.dirname(orientalSourceFile))
                    orientalSourceFileAll = sourceDir.entryList([os.path.splitext(os.path.basename(orientalSourceFile))[0] + "*"], QDir.Files)
                    orientalFilesToCopy += [{'source': os.path.normpath(os.path.join(os.path.dirname(orientalSourceFile), orientalSourceFileOne)), 'destination': os.path.normpath(os.path.join(destinationDirName, os.path.basename(orientalSourceFileOne)))} for orientalSourceFileOne in orientalSourceFileAll]

                for orientalFileToCopy in orientalFilesToCopy:
                    self.writeMsg("{0} > {1}".format(orientalFileToCopy['source'], orientalFileToCopy['destination']))

                if orientalFilesToCopy:
                    if CopyFiles(orientalFilesToCopy, destinationDirName, checkDestination=True, parent=self):
                        OpenFileOrFolder(destinationDirName)
                self.writeMsg("Kopiervorgang abgeschloßen!")

        else:
            # notify the user that something went wrong
            self.writeMsg("-----\nImport fehlerhaft! Öffnen Sie das QGIS Log Messages Panel für mehr Informationen.")
        self.workerOriental = None

    def workerError(self, e, exception_string, import_type):
        QgsMessageLog.logMessage('APIS Image Auto Import ({0}) thread raised an exception:\n{1}'.format(import_type, exception_string), tag='APIS', level=Qgis.Critical)

    def kmlToWktPolygon(self, lineString):
        points = lineString.split(' ')
        polygon = []
        for point in points:
            p = point.split(',')
            polygon.append(QgsPointXY(float(p[0]), float(p[1])))
        return QgsGeometry.fromPolygonXY([polygon])

    def runImportVexcel(self):
        # from osgeo import ogr
        # from pykml import parser
        from lxml import etree

        fileName = self.uiVexcelSourceEdit.text()
        tree = etree.parse(fileName)
        placemarks = tree.xpath('//kml:Folder/kml:Placemark[kml:MultiGeometry]', namespaces={"kml": "http://earth.google.com/kml/2.2"})
        # self.writeMsg(f"{placemarks}")
        imageNumber = 0
        cpFeatures = []
        fpFeatures = []

        da = QgsDistanceArea()
        da.setEllipsoid(self.targetLayerFP.crs().ellipsoidAcronym())

        for placemark in placemarks:
            targetFeatCP = QgsFeature(self.targetLayerCP.fields())
            targetFeatFP = QgsFeature(self.targetLayerFP.fields())
            imageNumber += 1
            filmImageNumber = '{0}.{1:03d}'.format(self.filmId, imageNumber)
            name = placemark.xpath('.//kml:name/text()', namespaces={"kml": "http://earth.google.com/kml/2.2"})[0].replace('\n', '').replace('\t', '')
            pointCoordinates = placemark.xpath('.//kml:MultiGeometry/kml:Point/kml:coordinates/text()', namespaces={"kml": "http://earth.google.com/kml/2.2"})[0].replace('\n', '').replace('\t', '').split(',')
            sourceGeometryCP = QgsGeometry.fromPointXY(QgsPointXY(float(pointCoordinates[0]), float(pointCoordinates[1])))
            altitude = int(float(pointCoordinates[2]))
            targetGeometryCP = TransformGeometry(sourceGeometryCP, QgsCoordinateReferenceSystem("EPSG:4326"), self.targetLayerCP.crs())
            targetFeatCP.setGeometry(targetGeometryCP)
            # From Film Table
            # filmFields = ["form1", "form2", "weise", "kammerkonstante"]
            targetFeatCP.setAttribute('filmnummer_hh_jjjj_mm', self.parent.currentFilmInfoDict["filmnummer_hh_jjjj_mm"])
            targetFeatCP.setAttribute('filmnummer_nn', self.parent.currentFilmInfoDict["filmnummer_nn"])
            targetFeatCP.setAttribute('filmnummer', self.filmId)

            targetFeatCP.setAttribute('bildnummer_nn', imageNumber)
            targetFeatCP.setAttribute('bildnummer', filmImageNumber)

            # Date TODAY
            now = QDate.currentDate()
            targetFeatCP.setAttribute('datum_ersteintrag', now.toString("yyyy-MM-dd"))
            targetFeatCP.setAttribute('datum_aenderung', now.toString("yyyy-MM-dd"))

            targetFeatCP.setAttribute('copyright', self.parent.currentFilmInfoDict["copyright"])
            targetFeatCP.setAttribute('etikett', 0)  # By default fixed value of 0

            # Calculated/Derived
            cp = targetFeatCP.geometry().asPoint()
            targetFeatCP.setAttribute('longitude', cp.x())
            targetFeatCP.setAttribute('latitude', cp.y())

            countryCode = GetCountryCode(self.dbm.db, cp)
            targetFeatCP.setAttribute('land', countryCode)

            if countryCode == 'AUT':
                # get meridian and epsg Code
                meridian, epsgGK = GetMeridianAndEpsgGK(cp.x())

                # get KG Coordinates
                gk = TransformGeometry(QgsGeometry(targetFeatCP.geometry()), self.targetLayerCP.crs(), QgsCoordinateReferenceSystem(f"EPSG:{epsgGK}"))
                gkx = gk.asPoint().y()  # Hochwert
                gky = gk.asPoint().x()  # Rechtswert
            else:
                meridian = None
                gkx = None
                gky = None

            targetFeatCP.setAttribute('meridian', meridian)
            targetFeatCP.setAttribute('gkx', gkx)  # Hochwert
            targetFeatCP.setAttribute('gky', gky)  # Rechtswert

            targetFeatCP.setAttribute('hoehe', altitude)
            targetFeatCP.setAttribute('fokus', self.parent.currentFilmInfoDict["kammerkonstante"])
            targetFeatCP.setAttribute('massstab', altitude / self.parent.currentFilmInfoDict["kammerkonstante"] * 1000)

            golygonCoordinates = placemark.xpath('.//kml:MultiGeometry/kml:Polygon/kml:outerBoundaryIs/kml:LinearRing/kml:coordinates/text()', namespaces={"kml": "http://earth.google.com/kml/2.2"})[0].replace('\n', '').replace('\t', '')
            sourceGeometryFP = self.kmlToWktPolygon(golygonCoordinates)
            targetGeometryFP = TransformGeometry(sourceGeometryFP, QgsCoordinateReferenceSystem("EPSG:4326"), self.targetLayerFP.crs())
            targetFeatFP.setGeometry(targetGeometryFP)
            targetFeatFP.setAttribute('filmnummer', self.filmId)
            targetFeatFP.setAttribute('bildnummer', filmImageNumber)
            targetFeatFP.setAttribute('shape_length', round(da.measurePerimeter(targetGeometryFP), 3))
            targetFeatFP.setAttribute('shape_area', round(da.measureArea(targetGeometryFP), 3))
            targetFeatFP.setAttribute('source', 'vexcel')

            self.writeMsg(f"-----\n{imageNumber}, {name}")
            # self.writeMsg(f"-----\n{filmImageNumber}, {name}, {cpGeom.asWkt()}, {altitude}")
            # self.writeMsg(f"{fpGeom.asWkt()}")
            description = placemark.xpath('.//kml:description/text()', namespaces={"kml": "http://earth.google.com/kml/2.2"})
            if description:
                description = description[0].replace('\n', '').replace('\t', '')
                table = etree.XML(description)
                runId = int(float(table.xpath("//table/tr/td[.='Run ID']/following-sibling::node()/text()")[0]))
                countOnLine = int(float(table.xpath("//table/tr/td[.='Count on line']/following-sibling::node()/text()")[0]))
                heading = int(float(table.xpath("//table/tr/td[.='Heading']/following-sibling::node()/text()")[0]))
                self.writeMsg(f"{runId}, {countOnLine}, {heading}")
                targetFeatCP.setAttribute('kappa', heading)

            cpFeatures.append(targetFeatCP)
            fpFeatures.append(targetFeatFP)

        if cpFeatures:
            (resAFs, feats) = self.targetLayerCP.dataProvider().addFeatures(cpFeatures)

        if fpFeatures:
            (resAFs, feats) = self.targetLayerFP.dataProvider().addFeatures(fpFeatures)

        self.targetLayerCP.updateExtents()
        self.targetLayerCP.triggerRepaint()

        self.targetLayerFP.updateExtents()
        self.targetLayerFP.triggerRepaint()

    def onClose(self):
        SetWindowSize("image_digital_auto_import", self.size())


class Ins2CamImportWorker(QObject):
    '''Background worker for Importing Ins2Cam'''

    message = pyqtSignal(str)
    finished = pyqtSignal(object)
    error = pyqtSignal(Exception, str, str)

    def __init__(self, sourceFiles, settings, dbm, apisLayer, filmId, targetLayerCP, targetLayerFP):
        QObject.__init__(self)
        self.killed = False
        self.sourceFiles = sourceFiles
        self.settings = settings
        self.dbm = dbm
        self.apisLayer = apisLayer
        self.filmId = filmId
        self.targetLayerCP = targetLayerCP
        self.targetLayerFP = targetLayerFP

    def run(self):
        ret = False
        try:
            self.importIns2Cam()
            if self.killed is False:
                ret = True
        except Exception as e:
            # forward the exception upstream
            self.error.emit(e, traceback.format_exc(), "Ins2Cam/IMU/Monoplot")

        self.finished.emit(ret)

    def kill(self):
        self.killed = True

    def importIns2Cam(self):
        return


class OrientalImportWorker(QObject):
    '''Background worker for Importing OrientAL Updates'''

    message = pyqtSignal(str)
    finished = pyqtSignal(object)
    error = pyqtSignal(Exception, str, str)

    def __init__(self, sourceFiles, settings, dbm, apisLayer, filmId, targetLayerCP, targetLayerFP):
        QObject.__init__(self)
        self.killed = False
        self.sourceFiles = sourceFiles
        self.settings = settings
        self.dbm = dbm
        self.apisLayer = apisLayer
        self.filmId = filmId
        self.targetLayerCP = targetLayerCP
        self.targetLayerFP = targetLayerFP

    def run(self):
        ret = False
        try:
            self.importOriental()
            if self.killed is False:
                ret = True

        except Exception as e:
            # forward the exception upstream
            self.error.emit(e, traceback.format_exc(), "OrientAL")

        self.finished.emit(ret)

    def kill(self):
        self.killed = True

    def importOriental(self):
        for orientalSourceFile in self.sourceFiles:
            if self.killed is True:
                # kill request received, exit loop early
                break
            if os.path.isfile(orientalSourceFile):
                epsg = self.settings.value("APIS/oriental_epsg", type=int)
                sourceLayerFPOriental = self.apisLayer.requestShapeFile(orientalSourceFile, epsg=epsg, useLayerFromTree=False, addToCanvas=False)
                isOrientalSourceLayer, isOrientalSourceLayerMsg = self.isSourceLayerOriental(sourceLayerFPOriental)

                if isOrientalSourceLayer:
                    iterFPOriental = sourceLayerFPOriental.getFeatures()
                    existingFeaturesCP = QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0]
                    existingFeaturesFP = QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0]

                    fileMsg = f"Source Datei OrientAL: {orientalSourceFile}"
                    crsMsg = f"Spatial Reference System: {sourceLayerFPOriental.crs().authid()}, {sourceLayerFPOriental.crs().mapUnits()}"
                    self.message.emit(f"-----\n{fileMsg}\n{crsMsg}")

                    capsCP = self.targetLayerCP.dataProvider().capabilities()
                    capsFP = self.targetLayerFP.dataProvider().capabilities()
                    if capsCP & QgsVectorDataProvider.ChangeAttributeValues and capsCP & QgsVectorDataProvider.ChangeGeometries and capsFP & QgsVectorDataProvider.AddFeatures and capsFP & QgsVectorDataProvider.ChangeAttributeValues and capsFP & QgsVectorDataProvider.ChangeGeometries:
                        sourceFeatFPOriental = QgsFeature()

                        while iterFPOriental.nextFeature(sourceFeatFPOriental):
                            # check if ImageId value == filename; current Filmnummer; Bildnummer
                            if self.filmId == sourceFeatFPOriental['ImageId'][:10] and len(sourceFeatFPOriental['ImageId']) == 14:
                                imageNumber = int(sourceFeatFPOriental['ImageId'][11:])
                                filmImageNumber = '{0}.{1:03d}'.format(self.filmId, imageNumber)
                                # check if CP exists (yes, continue, no, skip this image!)
                                if filmImageNumber in existingFeaturesCP:
                                    # get oriental FP geometry
                                    orientalGeometryFP = QgsGeometry(sourceFeatFPOriental.geometry())
                                    if orientalGeometryFP.isMultipart():
                                        orientalGeometryFP.convertToSingleType()

                                    # get existing CP feature! assumption there is only one feature where expression applies!
                                    featuresRequestedCP = self.targetLayerCP.getFeatures(QgsFeatureRequest(QgsExpression(f"\"bildnummer\" = '{filmImageNumber}'")))
                                    featureCP = QgsFeature()
                                    featuresRequestedCP.nextFeature(featureCP)  # crs 4312
                                    featuresRequestedCP.close()

                                    updateAttrCP = {}
                                    # set CP attributes: datum_aenderung
                                    now = QDate.currentDate()
                                    updateAttrCP[featureCP.fieldNameIndex('datum_aenderung')] = now.toString("yyyy-MM-dd")

                                    # project/transform geometry of existing CP to same CRS as input FP (to check if FP geometry still contains CP geometry)
                                    projectedGeometryCP = TransformGeometry(QgsGeometry(featureCP.geometry()), self.targetLayerCP.crs(), sourceLayerFPOriental.crs())
                                    if orientalGeometryFP.contains(projectedGeometryCP):
                                        # just update FP and radius for CP
                                        # derive CP Attributes: radius (Radius is Type String in APIS-DB!)
                                        updateAttrCP[featureCP.fieldNameIndex('radius')] = str(CalculateImageRadius(projectedGeometryCP, orientalGeometryFP))
                                        self.message.emit(f"UPDATE CP: Bei Bild {filmImageNumber} ist der Bildmittelpunkt innerhalb des neuen Footprints. Der Bildmittelpunkt wird beibehalten.")
                                    else:
                                        # update FP and everything else for CP (radius, land, gkx, gky, meridian, lon, lat)
                                        self.message.emit(f"UPDATE CP: Bei Bild {filmImageNumber} ist der Bildmittelpunkt auserhalb des neuen Footprints. Ein neuer Bildmittelpunkt wird berechnet.")
                                        orientalGeometryCP = orientalGeometryFP.centroid()
                                        if not orientalGeometryFP.contains(orientalGeometryCP):
                                            orientalGeometryCP = orientalGeometryFP.pointOnSurface()
                                        updateAttrCP[featureCP.fieldNameIndex('radius')] = str(CalculateImageRadius(orientalGeometryCP, orientalGeometryFP))

                                        # project/transform new CP geometry to CRS of target CP Layer
                                        targetGeometryCP = TransformGeometry(QgsGeometry(orientalGeometryCP), sourceLayerFPOriental.crs(), self.targetLayerCP.crs())

                                        # derive CP attributes: land, gkx, gky, meridian, lon, lat
                                        cp = targetGeometryCP.asPoint()
                                        updateAttrCP[featureCP.fieldNameIndex('longitude')] = cp.x()
                                        updateAttrCP[featureCP.fieldNameIndex('latitude')] = cp.y()

                                        countryCode = GetCountryCode(self.dbm.db, cp)
                                        updateAttrCP[featureCP.fieldNameIndex('land')] = countryCode

                                        if countryCode == 'AUT':
                                            # get meridian and epsg Code
                                            meridian, epsgGK = GetMeridianAndEpsgGK(cp.x())
                                            updateAttrCP[featureCP.fieldNameIndex('meridian')] = meridian

                                            # get KG Coordinates
                                            gk = TransformGeometry(QgsGeometry(targetGeometryCP), self.targetLayerCP.crs(), QgsCoordinateReferenceSystem(f"EPSG:{epsgGK}"))
                                            updateAttrCP[featureCP.fieldNameIndex('gkx')] = gk.asPoint().y()  # Hochwert
                                            updateAttrCP[featureCP.fieldNameIndex('gky')] = gk.asPoint().x()  # Rechtswert

                                        # update CP geometry
                                        self.targetLayerCP.dataProvider().changeGeometryValues({featureCP.id(): targetGeometryCP})

                                    # update CP attributes
                                    resCAVs = self.targetLayerCP.dataProvider().changeAttributeValues({featureCP.id(): updateAttrCP})
                                    self.message.emit(f"UPDATE CP: Bild {filmImageNumber}; CAVs: {resCAVs}")
                                    if not resCAVs:
                                        QgsMessageLog.logMessage("APIS OrientAL Import: {0}".format(";".join(self.targetLayerCP.commitErrors())), tag="APIS", level=Qgis.Critical)

                                    # prep footprint geometry
                                    # derive FP attributes: shape_length; shape_area;
                                    targetGeometryFP = TransformGeometry(QgsGeometry(orientalGeometryFP), sourceLayerFPOriental.crs(), self.targetLayerFP.crs())
                                    da = QgsDistanceArea()
                                    da.setEllipsoid(self.targetLayerFP.crs().ellipsoidAcronym())
                                    shape_length = round(da.measurePerimeter(targetGeometryFP), 3)
                                    shape_area = round(da.measureArea(targetGeometryFP), 3)

                                    # check if FP exists (yes, update geom and dependencies; no, add feature)
                                    if filmImageNumber in existingFeaturesFP:
                                        # change Feature
                                        # get existing FP feature! assumption there is only one feature where expression applies!
                                        featuresRequestedFP = self.targetLayerFP.getFeatures(QgsFeatureRequest(QgsExpression(f"\"bildnummer\" = '{filmImageNumber}'")))
                                        featureFP = QgsFeature()
                                        featuresRequestedFP.nextFeature(featureFP)  # crs 4312
                                        featuresRequestedFP.close()

                                        updateAttrFP = {}
                                        # set FP attributes: source "oriental"
                                        updateAttrFP[featureFP.fieldNameIndex('source')] = 'oriental'

                                        # derive FP attributes: shape_length; shape_area;
                                        updateAttrFP[featureFP.fieldNameIndex('shape_length')] = shape_length
                                        updateAttrFP[featureFP.fieldNameIndex('shape_area')] = shape_area

                                        resCGVs = self.targetLayerFP.dataProvider().changeGeometryValues({featureFP.id(): targetGeometryFP})
                                        resCAVs = self.targetLayerFP.dataProvider().changeAttributeValues({featureFP.id(): updateAttrFP})
                                        self.message.emit(f"UPDATE FP: Bild {filmImageNumber}; CGVs: {resCGVs}; CAVs: {resCAVs}")
                                    else:
                                        # add Feature FP
                                        targetFeatFP = QgsFeature(self.targetLayerFP.fields())
                                        targetFeatFP.setGeometry(targetGeometryFP)

                                        targetFeatFP.setAttribute('filmnummer', self.filmId)
                                        targetFeatFP.setAttribute('bildnummer', filmImageNumber)
                                        targetFeatFP.setAttribute('shape_length', shape_length)
                                        targetFeatFP.setAttribute('shape_area', shape_area)
                                        targetFeatFP.setAttribute('source', 'oriental')

                                        (resAFs, feats) = self.targetLayerFP.dataProvider().addFeatures([targetFeatFP])
                                        self.message.emit(f"ADD FP: Bild {filmImageNumber}; AFs: {resAFs}")

                                else:
                                    self.message.emit(f"SKIP: kein CenterPoint für Bild: {filmImageNumber} vorhanden.")
                                    continue
                            else:
                                self.message.emit(f"SKIP: die Filmnummer/ImageId für Bild: {sourceFeatFPOriental['ImageId']} stimmen nicht mit der Filmnummer {self.filmId} überein.")
                                continue
                    else:
                        self.message.emit(f"SKIP ({os.path.basename(orientalSourceFile)}): Probleme mit Ziel Layer Capabilities (CP: {self.targetLayerCP.dataProvider().capabilitiesString()}; FP: {self.targetLayerFP.dataProvider().capabilitiesString()}")
                        continue

                else:
                    self.message.emit(isOrientalSourceLayerMsg)
                    continue

                QgsProject.instance().removeMapLayer(sourceLayerFPOriental)
                del sourceLayerFPOriental

    def isSourceLayerOriental(self, orientalLayer):
        # only one feature
        if orientalLayer.geometryType() != QgsWkbTypes.PolygonGeometry:
            return False, "Ein OrientAL Layer muss vom Typ PolygonGeometry sein (GeometryType: {0})".format(orientalLayer.geometryType())
        if orientalLayer.featureCount() != 1:
            return False, "Ein OrientAL Layer muss genau ein Feature enthalten (FeatureCount: {0})".format(orientalLayer.featureCount())
        # field ImageId
        provider = orientalLayer.dataProvider()
        fieldNames = set([field.name() for field in provider.fields()])
        if "ImageId" not in fieldNames:
            return False, "Der OrientAL Layer hat kein Attribut 'ImageId'."

        return True, "OrientalLayer"
