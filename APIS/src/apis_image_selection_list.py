# -*- coding: utf-8 -*-

"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Standard Libs
import os
import glob

# PyQt
from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QAbstractItemView, QHeaderView, QPushButton, QFileDialog, QProgressDialog, QMenu, QGraphicsTextItem, QGraphicsScene
from PyQt5.QtCore import QSettings, Qt, QFileInfo, QDateTime, QDir, QFile, QDate, QRectF, QThread, pyqtSignal
from PyQt5.QtGui import QDoubleValidator, QStandardItemModel, QStandardItem, QIcon, QImage, QPixmap
from PyQt5.QtSql import QSqlQuery, QSqlRelationalTableModel

#PyQIS
from qgis.core import (
    QgsRasterLayer,
    QgsGeometry,
    QgsFeature,
    QgsCoordinateReferenceSystem,
    Qgis,
    QgsMessageLog,
)

# APIS
from APIS.src.apis_utils import (OpenFileOrFolder, SetExportPath, GetExportPath, SetWindowSizeAndPos,
                                 GetWindowSize, GetWindowPos, SelectionOrAll, PolygonOrPoint, CopyFiles)
from APIS.src.apis_thumb_viewer import APISThumbViewer
from APIS.src.apis_printer import APISPrinterQueue, APISListPrinter, APISLabelPrinter, OutputMode
from APIS.src.apis_printing_options import APISPrintingOptions
from APIS.src.apis_image2xmp import Image2Xmp

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_image_selection_list_advanced_properties.ui'), resource_suffix='')


class APISImageSelectionList(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISImageSelectionList, self).__init__(parent)
        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer
        self.setupUi(self)

        # Initial window size/pos last saved. Use default values for first time
        if GetWindowSize("image_selection_list"):
            self.resize(GetWindowSize("image_selection_list"))
        if GetWindowPos("image_selection_list"):
            self.move(GetWindowPos("image_selection_list"))

        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        # Property Panel (Deactivate)
        self.uiTogglePropertyPanelBtn.toggled.connect(self.togglePropertyPanel)
        self.uiTogglePropertyPanelBtn.setChecked(False)
        self.loadTargetsForPropertyPanel()
        self.uiTablePropertiesSplitter.setCollapsible(0, False)
        self.uiTablePropertiesSplitter.setCollapsible(1, True)
        self.uiTablePropertiesSplitter.setRubberBand(-1)
        self.splitterState = None  # TODO load from Settings
        self.uiTablePropertiesSplitter.splitterMoved.connect(self.splitterWasMoved)
        self.uiImagePropertiesTab.currentChanged.connect(self.imagePropertiesTabChanged)
        self.currentImage = None
        self.uiImageNumberEdit.textChanged.connect(self.currentImageChanged)
        self.uiNextImageBtn.clicked.connect(lambda: self.nextPrevImagePreview(1))
        self.uiPrevImageBtn.clicked.connect(lambda: self.nextPrevImagePreview(-1))
        self.imageScene = QGraphicsScene()
        self.uiImageView.setScene(self.imageScene)
        self.imageRect = None

        mImage = QMenu()
        aImageThumbs = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Vorschau")
        aImageThumbs.triggered.connect(self.viewAsThumbs)
        aIns2CamThumbs = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Vorschau (Ins2Cam)")
        aIns2CamThumbs.triggered.connect(self.viewIns2CamAsThumbs)
        aImageCopy = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Kopieren")
        aImageCopy.triggered.connect(self.copyImages)
        aImageExif = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'exif_export.png')), "EXIF Export")
        aImageExif.triggered.connect(self.image2Xmp)
        #aImageExif.triggered.connect(lambda: VersionToCome("3.0.1"))
        self.uiImageTBtn.setMenu(mImage)
        self.uiImageTBtn.clicked.connect(self.uiImageTBtn.showMenu)

        mLayer = QMenu()
        mLayer.addSection("In QGIS laden")
        aLayerLoadImages = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Bild(er)")
        aLayerLoadImages.triggered.connect(self.loadImagesInQgis)
        aLayerLoadOrtho = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Orthofoto(s)")
        aLayerLoadOrtho.triggered.connect(self.loadOrthosInQgis)
        aLayerLoadIns2Cam = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Ins2Cam Bild(er)")
        aLayerLoadIns2Cam.triggered.connect(self.loadIns2CamsInQgis)
        mLayer.addSection("SHP Export")
        aLayerExportFootprints = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "Bild(er) als SHP exportieren")
        aLayerExportFootprints.triggered.connect(self.exportImagesAsShape)
        mLayer.addSection("In QGIS anzeigen")
        aLayerShowImage = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Bild(ern) zoomen")
        aLayerShowImage.triggered.connect(lambda: self.showImageInQgis(zoomTo=True, select=False))
        aLayerSelectImage = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Bild(er) selektieren")
        aLayerSelectImage.triggered.connect(lambda: self.showImageInQgis(zoomTo=False, select=True))
        aLayerShowAndSelectImage = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Bild(ern) zoomen und selektieren")
        aLayerShowAndSelectImage.triggered.connect(lambda: self.showImageInQgis(zoomTo=True, select=True))
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportImageList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Bildliste")
        aPdfExportImageList.triggered.connect(self.exportListAsPdf)
        aPdfExportLabels = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Etiketten")
        aPdfExportLabels.triggered.connect(self.exportLabelsAsPdf)
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        self.accepted.connect(self.onClose)
        self.rejected.connect(self.onClose)

        self.uiImageListTableV.doubleClicked.connect(self.viewImage)
        self.uiResetSelectionBtn.clicked.connect(self.uiImageListTableV.clearSelection)

        self.uiFilterGrp.toggled.connect(self.applyFilter)
        self.uiFilterVerticalChk.stateChanged.connect(self.applyFilter)
        self.uiFilterObliqueChk.stateChanged.connect(self.applyFilter)
        self.uiFilterScanChk.stateChanged.connect(self.applyFilter)
        self.uiFilterHiResChk.stateChanged.connect(self.applyFilter)
        self.uiFilterOrthoChk.stateChanged.connect(self.applyFilter)
        self.uiFilterScaleEdit.setValidator(QDoubleValidator())
        self.uiFilterScaleEdit.textEdited.connect(self.applyFilter)
        self.uiFilterScaleOperatorCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterFilmKindChk.stateChanged.connect(self.applyFilter)
        self.uiFilterFilmKindCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterScanCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterHiResCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterOrthoCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterFromChk.stateChanged.connect(self.applyFilter)
        self.uiFilterToChk.stateChanged.connect(self.applyFilter)

        self.printingOptionsDlg = None

    def loadImageListBySqlQuery(self, query=None):
        self.model = QStandardItemModel()

        # iterate over query result
        while query.next():
            newRow = []
            rec = query.record()
            for col in range(rec.count()):
                newCol = QStandardItem(str(rec.value(col)))
                newRow.append(newCol)

            #scan
            imageNumber = rec.value("bildnummer")
            if self.imageRegistry.hasImage(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            #ortho and mosaic
            if self.imageRegistry.hasOrthoOrMosaic(imageNumber):  # hasOrtho(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            #hires
            if self.imageRegistry.hasHiRes(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            self.model.appendRow(newRow)

        if self.model.rowCount() < 1:
            QMessageBox.warning(self, "Bild Auswahl", u"Es wurden keine kartierten Bilder gefunden!")
            return False

        for col in range(rec.count()):
            self.model.setHeaderData(col, Qt.Horizontal, rec.fieldName(col))

        self.model.setHeaderData(self.model.columnCount() - 3, Qt.Horizontal, "scan")
        self.model.setHeaderData(self.model.columnCount() - 2, Qt.Horizontal, "ortho")
        self.model.setHeaderData(self.model.columnCount() - 1, Qt.Horizontal, "hires")

        self.uiImageCountLbl.setText("{0}".format(self.model.rowCount()))
        self.uiScanCountLbl.setText("{0}".format(self.conditionalRowCount(5, "ja")))
        self.uiOrthoCountLbl.setText("{0}".format(self.conditionalRowCount(6, "ja")))
        self.uiHiResCountLbl.setText("{0}".format(self.conditionalRowCount(7, "ja")))

        self.setupTable()
        self.setupFilter()
        self.applyFilter()

        return True

    def conditionalRowCount(self, section, value):
        count = 0
        for row in range(self.model.rowCount()):
            if self.model.item(row, section).text() == value:
                count += 1
        return count

    def conditionalSelectedRowCount(self, column, value):
        count = 0
        for idx in self.uiImageListTableV.selectionModel().selectedRows():
            if self.model.item(idx.row(), column).text() == value:
                count += 1
        return count

    def setupTable(self):
        self.uiImageListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiImageListTableV.setModel(self.model)
        self.uiImageListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)

        self.uiImageListTableV.resizeColumnsToContents()
        self.uiImageListTableV.resizeRowsToContents()
        self.uiImageListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        self.uiImageListTableV.selectionModel().selectionChanged.connect(self.onSelectionChanged)

    def onSelectionChanged(self):
        # self.uiSelectionCountLbl.setText("{0}".format(len(self.uiImageListTableV.selectionModel().selectedRows())))
        # self.uiImageListTableV.selectionModel().selectedRows()
        self.uiImageSelectedCountLbl.setText("{0}".format(len(self.uiImageListTableV.selectionModel().selectedRows())))
        self.uiScanSelectedCountLbl.setText("{0}".format(self.conditionalSelectedRowCount(5, "ja")))
        self.uiHiResSelectedCountLbl.setText("{0}".format(self.conditionalSelectedRowCount(7, "ja")))
        self.uiOrthoSelectedCountLbl.setText("{0}".format(self.conditionalSelectedRowCount(6, "ja")))

        if self.uiTogglePropertyPanelBtn.isChecked():
            # update panel
            self.updatePropertyPanelVisibility()
            self.updatePropertyPanelContent()

    def setupFilter(self):
        self.uiFilterGrp.setChecked(False)
        self.uiFilterFilmKindChk.setCheckState(Qt.Unchecked)
        self.uiFilterVerticalChk.setCheckState(Qt.Checked)
        self.uiFilterObliqueChk.setCheckState(Qt.Checked)
        self.uiFilterScaleEdit.clear()
        self.uiFilterScaleOperatorCombo.setCurrentIndex(0)
        self.uiFilterFilmKindCombo.clear()

        self.uiFilterScanChk.setCheckState(Qt.Unchecked)
        self.uiFilterHiResChk.setCheckState(Qt.Unchecked)
        self.uiFilterOrthoChk.setCheckState(Qt.Unchecked)
        self.uiFilterScanCombo.setCurrentIndex(0)
        self.uiFilterHiResCombo.setCurrentIndex(0)
        self.uiFilterOrthoCombo.setCurrentIndex(0)

        self.uiFilterFromChk.setCheckState(Qt.Unchecked)
        self.uiFilterToChk.setCheckState(Qt.Unchecked)

        minDate, maxDate = self.getMinMaxDate()
        # QMessageBox.information(None, "MinMax", "{0}, {1}".format(minDate.toString("MM.yyyy"), maxDate.toString("MM.yyyy")))

        self.uiFilterFromDate.setMinimumDate(minDate)
        self.uiFilterFromDate.setMaximumDate(maxDate)
        self.uiFilterFromDate.setDate(minDate)

        self.uiFilterToDate.setMinimumDate(minDate)
        self.uiFilterToDate.setMaximumDate(maxDate)
        self.uiFilterToDate.setDate(maxDate)

        self.uiFilterFromDate.dateChanged.connect(self.updateToDate)
        self.uiFilterToDate.dateChanged.connect(self.updateFromDate)

        filmKinds = []
        for row in range(self.model.rowCount()):
            filmKinds.append(self.model.item(row, 4).text())

        for filmKind in set(filmKinds):
            self.uiFilterFilmKindCombo.addItem(filmKind)
        self.uiFilterFilmKindCombo.setCurrentIndex(0)

    def updateToDate(self, date):
        self.uiFilterToDate.setMinimumDate(date)
        self.applyFilter()

    def updateFromDate(self, date):
        self.uiFilterFromDate.setMaximumDate(date)
        self.applyFilter()

    def getImageList(self, getAll=False, filterSection=None, filterValue=None):
        imageList = []
        if self.uiImageListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiImageListTableV.selectionModel().selectedRows()
            for row in rows:
                # get imagenummer
                if not self.uiImageListTableV.isRowHidden(row.row()):
                    if filterSection and filterValue:
                        if self.model.item(row.row(), filterSection).text() == filterValue:
                            imageList.append(self.model.item(row.row(), 0).text())
                    else:
                        imageList.append(self.model.item(row.row(), 0).text())
                    # imageList.append(self.model.record(row.row()).value("bildnummer"))#(self.model.createIndex(row.row(), self.model.fieldIndex("filmnummer"))))
        else:
            for row in range(self.model.rowCount()):
                if not self.uiImageListTableV.isRowHidden(row):
                    if filterSection and filterValue:
                        if self.model.item(row, filterSection).text() == filterValue:
                            imageList.append(self.model.item(row, 0).text())
                    else:
                        imageList.append(self.model.item(row, 0).text())
                    # imageList.append(self.model.record(row).value("bildnummer"))#(self.model.createIndex(row, self.model.fieldIndex("filmnummer"))))

        return imageList

    def getImageListWithRows(self, getAll=False, filterSection=None, filterValue=None):
        imageList = []
        if self.uiImageListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiImageListTableV.selectionModel().selectedRows()
            for row in rows:
                # get imagenummer
                if not self.uiImageListTableV.isRowHidden(row.row()):
                    rowContent = []
                    if filterSection and filterValue:
                        if self.model.item(row.row(), filterSection).text() == filterValue:
                            for col in range(self.model.columnCount()):
                                rowContent.append(self.model.item(row.row(), col).text())
                            imageList.append(rowContent)
                    else:
                        for col in range(self.model.columnCount()):
                            rowContent.append(self.model.item(row.row(), col).text())
                        imageList.append(rowContent)
        else:
            for row in range(self.model.rowCount()):
                if not self.uiImageListTableV.isRowHidden(row):
                    rowContent = []
                    if filterSection and filterValue:
                        if self.model.item(row, filterSection).text() == filterValue:
                            for col in range(self.model.columnCount()):
                                rowContent.append(self.model.item(row, col).text())
                            imageList.append(rowContent)
                    else:
                        for col in range(self.model.columnCount()):
                            rowContent.append(self.model.item(row, col).text())
                        imageList.append(rowContent)
        return imageList

    def viewImage(self):
        r = self.uiImageListTableV.currentIndex().row()
        imageDir = self.settings.value("APIS/image_dir")
        fileName = imageDir + "\\{0}\\{1}.jpg".format(self.model.item(r, 1).text(), self.model.item(r, 0).text().replace('.', '_'))
        if os.path.isfile(os.path.normpath(fileName)):
            OpenFileOrFolder(fileName)
        else:
            QMessageBox.warning(self, "Bild", u"Bild unter {0} nicht vorhanden".format(fileName))
        # get Path to Image
        # open with standard

        # QMessageBox.warning(None, "FilmNumber", "Double")
        # filmIdx = self.model.createIndex(self.uiFilmListTableV.currentIndex().row(), self.model.fieldIndex("filmnummer"))
        # self.filmNumberToLoad = self.model.data(filmIdx)
        # self.accept()
        # QMessageBox.warning(None, "FilmNumber", unicode(self.model.data(filmIdx)))

    def viewAsThumbs(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            # Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)

            if ret == 0:
                imageList = self.getImageList(False, 5, "ja")
            elif ret == 1:
                imageList = self.getImageList(True, 5, "ja")
            else:
                return
        else:
            imageList = self.getImageList(True, 5, "ja")

        if len(imageList) == 0:
            QMessageBox.warning(self, "Bildvorschau", u"Es sind keine Bilder vorhanden!")
            return

        #imageString = ""
        #for image in imageList:
        #    imageString += "'" + image + "',"
        # use: imageString[:-1]
        #QMessageBox.warning(None, "BildNumber", "{0}".format(imageString))

        imagePathList = []
        imageList.sort()
        imageDir = self.settings.value("APIS/image_dir")

        for image in imageList:
            imagePathList.append(os.path.normpath(imageDir + "\\{0}\\{1}.jpg".format(image.split('.')[0], image.replace('.', '_'))))

        #QMessageBox.warning(None, "BildNumber", "{0}".format(', '.join(imagePathList)))
        #app = QtGui.QApplication([])
        widget = APISThumbViewer()
        widget.load(imagePathList)
        widget.show()
        if widget.exec_():
            pass

    def viewIns2CamAsThumbs(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        ins2camImages = []
        for image in imageList:
            if self.imageRegistry.hasIns2Cam(image):
                ins2camImages.append(image)
        if len(ins2camImages) == 0:
            QMessageBox.warning(self, "Bildvorschau", u"Es sind keine Bilder vorhanden!")
            return

        pathList = []
        ins2camImages.sort()
        imageDir = self.settings.value("APIS/image_dir")
        i2cDir = self.settings.value("APIS/monoplot_dir")
        for image in imageList:
            pathList.append(os.path.normpath(imageDir + "\\{0}\\{1}\\{2}.tif".format(image.split('.')[0], i2cDir, image.replace('.', '_'))))

        widget = APISThumbViewer()
        widget.load(pathList)
        widget.show()
        if widget.exec_():
            pass

    def loadImagesInQgis(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            # Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        polygon, point = PolygonOrPoint(parent=self)
        if polygon or point:
            # imageString = ""
            # for image in imageList:
            #     imageString += "'" + image + "',"
            # use: imageString[:-1]
            # QMessageBox.warning(None, "BildNumber", "{0}".format(imageString))

            subsetString = '"bildnummer" IN (' + ','.join(['\'{0}\''.format(imageNumber) for imageNumber in imageList]) + ')'
            # now = QDateTime.currentDateTime()
            # time = now.toString("yyyyMMdd_hhmmss")

            if polygon:
                polygonLayerOblique = self.apisLayer.getSpatialiteLayer("luftbild_schraeg_fp", subsetString)
                polygonLayerVertical = self.apisLayer.getSpatialiteLayer("luftbild_senk_fp", subsetString)
                polygonLayer = self.apisLayer.mergeLayers([polygonLayerOblique, polygonLayerVertical], name="bild footprint", parent=self)
                if polygonLayer:
                    polygonLayer.loadNamedStyle(self.apisLayer.getStylePath("images_vertical_fp"))
                    # export PolygonLayer
                    self.apisLayer.addLayerToCanvas(polygonLayer, "Temp")

            if point:
                pointLayerOblique = self.apisLayer.getSpatialiteLayer("luftbild_schraeg_cp", subsetString)
                pointLayerVertical = self.apisLayer.getSpatialiteLayer("luftbild_senk_cp", subsetString)
                pointLayer = self.apisLayer.mergeLayers([pointLayerOblique, pointLayerVertical], name="bild centerpoint", parent=self)
                if pointLayer:
                    pointLayer.loadNamedStyle(self.apisLayer.getStylePath("images_vertical_cp"))
                    # export PolygonLayer
                    self.apisLayer.addLayerToCanvas(pointLayer, "Temp")

    def showImageInQgis(self, zoomTo=True, select=False):
        if self.uiImageListTableV.selectionModel().hasSelection():
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        layers = self.apisLayer.requestImageLayers()
        expression = "\"bildnummer\" IN ({})".format(','.join(["'{}'".format(iN) for iN in imageList]))
        for layer in layers:
            self.apisLayer.selectFeaturesByExpression(layer, expression)

        if zoomTo:
            self.apisLayer.zoomToSelections(layers)
        if not select:
            for layer in layers:
                layer.removeSelection()

    def loadOrthosInQgis(self):
        orthoList = self.getImageList(False, 6, "ja")

        orthoList.sort()
        orthoDir = self.settings.value("APIS/ortho_image_dir")

        for ortho in orthoList:
            orthoFileNames = glob.glob(os.path.normpath(orthoDir + "\\{0}\\{1}_op*.*".format(ortho.split('.')[0], ortho.replace('.', '_'))))
            for orthoFile in orthoFileNames:
                if os.path.splitext(orthoFile)[1] in ['.sid', '.tif', '.tiff', '.jpg']:
                    fileInfo = QFileInfo(orthoFile)
                    baseName = fileInfo.baseName()
                    rlayer = QgsRasterLayer(orthoFile, baseName)
                    if not rlayer.isValid():
                        QMessageBox.warning(self, "Ortho", "{0}".format(os.path.splitext(orthoFile)[1]))
                    else:
                        self.apisLayer.addLayerToCanvas(rlayer, groupName="Orthofotos")
                    # QMessageBox.warning(None, "Ortho", "{0}".format(os.path.splitext(orthoFile)[1]))

        # mosaics
        mosaicsToLoad = []
        for ortho in orthoList:
            mosaicsToLoad = mosaicsToLoad + self.imageRegistry.hasMosaic(ortho)
        if mosaicsToLoad:
            uniqueMosaicsToLoad = list(set(mosaicsToLoad))
            for mosaic in uniqueMosaicsToLoad:
                mosaicFileNames = glob.glob(os.path.normpath(orthoDir + "\\{0}\\{1}_op*.*".format(mosaic[:10], mosaic.replace('.', '_').replace('-', '_'))))
                for mosaicFile in mosaicFileNames:
                    if os.path.splitext(mosaicFile)[1] in ['.sid', '.tif', '.tiff', '.jpg']:
                        fileInfo = QFileInfo(mosaicFile)
                        baseName = fileInfo.baseName()
                        # TODO add requestRasterLayer
                        rlayer = QgsRasterLayer(mosaicFile, baseName)
                        if not rlayer.isValid():
                            QMessageBox.warning(self, "Mosaic", "{0}".format(os.path.splitext(mosaicFile)[1]))
                        else:
                            # FIXME Handle CRS more flexible! E.g. setCrs only if there is non CRS/SRS associated (check with GDAL)
                            self.apisLayer.rasterFileHasCrs(mosaicFile)
                            rlayer.setCrs(QgsCoordinateReferenceSystem("EPSG:31259"))
                            self.apisLayer.addLayerToCanvas(rlayer, groupName="Orthofotos")
            # QMessageBox.information(None, "MosaicInfo", "{0}; {1}".format(", ".join(mosaicsToLoad), ", ".join(list(set(mosaicsToLoad)))))

    def loadIns2CamsInQgis(self):
        imageList = self.getImageList()
        imageList.sort()
        ins2camToLoad = []
        imageDir = self.settings.value("APIS/image_dir")
        for image in imageList:
            if self.imageRegistry.hasIns2Cam(image):
                ins2camToLoad.append(image)
        if ins2camToLoad:
            for i2c in ins2camToLoad:
                ins2camFileNames = glob.glob(os.path.normpath(imageDir + "\\{0}\\{1}\\{2}.*".format(i2c[:10], self.settings.value("APIS/monoplot_dir"), i2c.replace('.', '_'))))
                for ins2camFile in ins2camFileNames:
                    if os.path.splitext(ins2camFile)[1] in ['.tif', '.tiff', '.jpg']:
                        fileInfo = QFileInfo(ins2camFile)
                        baseName = fileInfo.baseName()
                        rlayer = QgsRasterLayer(ins2camFile, baseName)
                        if not rlayer.isValid():
                            QMessageBox.warning(self, "ins2cam", "{0}".format(os.path.splitext(ins2camFile)[1]))
                        else:
                            self.apisLayer.addLayerToCanvas(rlayer, groupName="Orthofotos")

    def exportImagesAsShape(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        polygon, point = PolygonOrPoint(parent=self)
        if polygon or point:
            # imageString = ""
            # for image in imageList:
            #     imageString += "'" + image + "',"
            # use: imageString[:-1]
            #QMessageBox.warning(None, "BildNumber", "{0}".format(imageString))

            subsetString = '"bildnummer" IN (' + ','.join(['\'{0}\''.format(imageNumber) for imageNumber in imageList]) + ')'
            now = QDateTime.currentDateTime()
            time = now.toString("yyyyMMdd_hhmmss")

            if polygon:
                polygonLayerOblique = self.apisLayer.getSpatialiteLayer("luftbild_schraeg_fp", subsetString)
                polygonLayerVertical = self.apisLayer.getSpatialiteLayer("luftbild_senk_fp", subsetString)
                polygonLayer = self.apisLayer.mergeLayers([polygonLayerOblique, polygonLayerVertical], parent=self)
                if polygonLayer:
                    # export PolygonLayer
                    self.apisLayer.exportLayerAsShp(polygonLayer, time, name="Bilder_Footprints", groupName="Temp", styleName="images_vertical_fp", parent=self)

            if point:
                pointLayerOblique = self.apisLayer.getSpatialiteLayer("luftbild_schraeg_cp", subsetString)
                pointLayerVertical = self.apisLayer.getSpatialiteLayer("luftbild_senk_cp", subsetString)
                pointLayer = self.apisLayer.mergeLayers([pointLayerOblique, pointLayerVertical], parent=self)
                if pointLayer:
                    # export PolygonLayer
                    self.apisLayer.exportLayerAsShp(pointLayer, time, name="Bilder_Centerpoints", groupName="Temp", styleName="images_vertical_cp", parent=self)

                # query = QSqlQuery(self.dbm.db)

    def iter_features(self, query):
        """Iterate over the features of the input layer.
        Yields pairs of the form (QgsPoint, attributeMap).
        Each time a vertice is read hook is called.
        """

        while query.next():
            rec = query.record()
            attributes = [rec.value(rec.indexOf("bildnummer")), rec.value(rec.indexOf("filmnummer")), str(rec.value(rec.indexOf("weise"))), rec.value(rec.indexOf("area"))]
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromWkt(rec.value(rec.indexOf("fpGeom"))))
            feature.setAttributes(attributes)
            yield feature

    def copyImagesOLD(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)

            if ret == 0:
                imageList = self.getImageList(False, 5, "ja")
                hiResImageList = self.getImageList(False, 7, "ja")
            elif ret == 1:
                imageList = self.getImageList(True, 5, "ja")
                hiResImageList = self.getImageList(True, 7, "ja")
            else:
                return
        else:
            imageList = self.getImageList(True, 5, "ja")
            hiResImageList = self.getImageList(True, 7, "ja")

        if len(imageList) == 0:
            QMessageBox.warning(self, "Bilder kopieren", u"Es sind keine Bilder vorhanden!")
            return

        selectedDirName = QFileDialog.getExistingDirectory(self, u"Ziel Ordner auswählen", GetExportPath())

        if selectedDirName:
            SetExportPath(os.path.dirname(os.path.abspath(selectedDirName)))
            loRes = True
            hiRes = False
            if len(hiResImageList) > 0:
                #ask if normal, hires, oder beides?
                msgBox = QMessageBox(self)
                msgBox.setWindowTitle(u'Bilder Kopieren')
                msgBox.setText(u'Neben Bildern mit normaler Auflösung stehen Bilder mit hoher Auflösung zur Verfügung. Welche wollen Sie kopieren?')
                msgBox.addButton(QPushButton(u'Normale Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Hohe Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Alle Auflösungen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()

                if ret == 0:
                    loRes = True
                    hiRes = False
                elif ret == 1:
                    loRes = False
                    hiRes = True
                elif ret == 2:
                    loRes = True
                    hiRes = True
                else:
                    return

            destinationDir = QDir(selectedDirName)
            now = QDateTime.currentDateTime()
            newDirName = "apis_bild_export_{0}".format(now.toString("yyyyMMdd_hhmmss"))
            if destinationDir.mkdir(newDirName):
                destinationDirName = selectedDirName + '\\' + newDirName
                destinationDir = QDir(destinationDirName)
                # QMessageBox.warning(None, "Bilder kopieren", u"ZielVZ: {0}".format(destinationDirName))
                imageDir = self.settings.value("APIS/image_dir")
                for image in imageList:
                    if loRes or hiRes:
                        filmDirName = image.split('.')[0]
                        if not destinationDir.exists(filmDirName):
                            destinationDir.mkdir(filmDirName)

                        if loRes:
                            sourceFileName = os.path.normpath(imageDir + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.', '_')))
                            destinationFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.', '_')))
                            # QMessageBox.warning(None, "Bilder kopieren", u"SourceVZ: {0}, DestVZ: {1}".format(sourceFileName, destinationFileName))
                            sourceFile = QFile(sourceFileName)
                            sourceFile.copy(destinationFileName)

                        # HiRes Kopieren
                        # QMessageBox.warning(None, "Bilder kopieren", u"{0}, {1}".format(hiRes, ', '.join(hiResImageList)))
                        if hiRes and image in hiResImageList:
                            # copy hi res image files
                            filmDirPathName = imageDir + "\\" + filmDirName
                            filmDir = QDir(filmDirPathName)
                            hiResDirs = filmDir.entryList(["highres*", "mrsid", "raw"], QDir.Dirs)
                            if len(hiResDirs) > 0:
                                for hiResDirName in hiResDirs:
                                    filmDestDirName = destinationDirName + "\\" + filmDirName
                                    filmDestDir = QDir(filmDestDirName)
                                    if not filmDestDir.exists(hiResDirName):
                                        filmDestDir.mkdir(hiResDirName)
                                    hiResDir = QDir(filmDirPathName + "\\" + hiResDirName)
                                    hiResFiles = hiResDir.entryList([image.replace('.', '_') + "*"], QDir.Files)
                                    if len(hiResFiles) > 0:
                                        for hiResFile in hiResFiles:
                                            sourceHiResFileName = os.path.normpath("{0}\\{1}\\{2}".format(filmDirPathName, hiResDirName, hiResFile))
                                            destinationHiResFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}\\{2}".format(filmDirName, hiResDirName, hiResFile))
                                            # QMessageBox.warning(None, "Bilder kopieren", u"SourceVZ: {0}, DestVZ: {1}".format(sourceHiResFileName, destinationHiResFileName))
                                            sourceHiResFile = QFile(sourceHiResFileName)
                                            sourceHiResFile.copy(destinationHiResFileName)
                                        # QMessageBox.warning(None, "Bild", u"{0}".format(', '.join(hiResFiles)))

                OpenFileOrFolder(destinationDirName)

            else:
                QMessageBox.warning(self, "Bilder kopieren", u"Das Ziel Verzeichnis {0} konnte in {1} nicht erstellt werden".format(newDirName, selectedDirName))

    def copyImages(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)

            if ret == 0:
                imageList = self.getImageList(False, 5, "ja")
                hiResImageList = self.getImageList(False, 7, "ja")
            elif ret == 1:
                imageList = self.getImageList(True, 5, "ja")
                hiResImageList = self.getImageList(True, 7, "ja")
            else:
                return
        else:
            imageList = self.getImageList(True, 5, "ja")
            hiResImageList = self.getImageList(True, 7, "ja")

        if len(imageList) == 0:
            QMessageBox.warning(self, "Bilder kopieren", u"Es sind keine Bilder vorhanden!")
            return

        selectedDirName = QFileDialog.getExistingDirectory(self, u"Ziel Ordner auswählen", GetExportPath())

        if selectedDirName:
            SetExportPath(os.path.dirname(os.path.abspath(selectedDirName)))
            loRes = True
            hiRes = False
            if len(hiResImageList) > 0:
                #ask if normal, hires, oder beides?
                msgBox = QMessageBox(self)
                msgBox.setWindowTitle(u'Bilder Kopieren')
                msgBox.setText(u'Neben Bildern mit normaler Auflösung stehen Bilder mit hoher Auflösung zur Verfügung. Welche wollen Sie kopieren?')
                msgBox.addButton(QPushButton(u'Normale Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Hohe Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Alle Auflösungen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()

                if ret == 0:
                    loRes = True
                    hiRes = False
                elif ret == 1:
                    loRes = False
                    hiRes = True
                elif ret == 2:
                    loRes = True
                    hiRes = True
                else:
                    return

            # destinationDir = QDir(selectedDirName)
            now = QDateTime.currentDateTime()
            newDirName = "apis_bild_export_{0}".format(now.toString("yyyyMMdd_hhmmss"))
            # if destinationDir.mkdir(newDirName):
            destinationDirName = selectedDirName + '\\' + newDirName
            # destinationDir = QDir(destinationDirName)
            # QMessageBox.warning(None, "Bilder kopieren", u"ZielVZ: {0}".format(destinationDirName))
            imageDir = self.settings.value("APIS/image_dir")
            filesToCopy = []
            for image in imageList:
                if loRes or hiRes:
                    filmDirName = image.split('.')[0]
                    # if not destinationDir.exists(filmDirName):
                    #    destinationDir.mkdir(filmDirName)

                    if loRes:
                        sourceFileName = os.path.normpath(imageDir + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.', '_')))
                        destinationFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.', '_')))
                        # QMessageBox.warning(None, "Bilder kopieren", u"SourceVZ: {0}, DestVZ: {1}".format(sourceFileName, destinationFileName))
                        filesToCopy.append({'source': sourceFileName, 'destination': destinationFileName})

                    # HiRes Kopieren
                    # QMessageBox.warning(None, "Bilder kopieren", u"{0}, {1}".format(hiRes, ', '.join(hiResImageList)))
                    if hiRes and image in hiResImageList:
                        # copy hi res image files
                        filmDirPathName = imageDir + "\\" + filmDirName
                        filmDir = QDir(filmDirPathName)
                        hiResDirs = filmDir.entryList(["highres*", "mrsid", "raw"], QDir.Dirs)
                        if len(hiResDirs) > 0:
                            for hiResDirName in hiResDirs:
                                hiResDir = QDir(filmDirPathName + "\\" + hiResDirName)
                                hiResFiles = hiResDir.entryList([image.replace('.', '_') + "*"], QDir.Files)
                                if len(hiResFiles) > 0:
                                    for hiResFile in hiResFiles:
                                        sourceHiResFileName = os.path.normpath("{0}\\{1}\\{2}".format(filmDirPathName, hiResDirName, hiResFile))
                                        destinationHiResFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}\\{2}".format(filmDirName, hiResDirName, hiResFile))
                                        filesToCopy.append({'source': sourceHiResFileName, 'destination': destinationHiResFileName})
                                    # QMessageBox.warning(None, "Bild", u"{0}".format(', '.join(hiResFiles)))

            if filesToCopy:
                if CopyFiles(filesToCopy, destinationDirName, checkDestination=True, parent=self):
                    OpenFileOrFolder(destinationDirName)

            # else:
            #     QMessageBox.warning(self, "Bilder kopieren", u"Das Ziel Verzeichnis {0} konnte in {1} nicht erstellt werden".format(newDirName, selectedDirName))

    def image2Xmp(self):
        # check if exiv2 is installed
        from shutil import which
        if which("exiv2") is None:
            QMessageBox.warning(self, "Exiv2 nicht installiert!", "Um diese Funktion zu verwenden muss exiv2 installiert sein. Verwenden Sie dazu den OSGeo4W Network Installer (https://download.qgis.org/)")
            return

        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)

            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        # check if images available for imageList
        finalImageList = [imageNumber for imageNumber in imageList if self.imageRegistry.hasImage(imageNumber)]

        if finalImageList:
            if len(finalImageList) == len(imageList):
                # same size (all images are in image registry)
                rep = QMessageBox.question(self, "EXIF/XMP Export: Bilder vorhanden.", "Bilder sind für alle {0} Einträge vorhanden. Wollen Sie mit dem XMP Export fortfahren?".format(len(finalImageList)),
                                           QMessageBox.Yes | QMessageBox.Cancel, QMessageBox.Cancel)
                if rep == QMessageBox.Cancel:
                    return
            else:
                # not same size (not all images are in image registry) ask if to continue
                rep = QMessageBox.question(self, "EXIF/XMP Export: einige Bilder vorhanden.",
                                           "Bilder sind für {0} von {1} Einträgen vorhanden. Wollen Sie mit dem XMP Export fortfahren?".format(
                                               len(finalImageList), len(imageList)),
                                           QMessageBox.Yes | QMessageBox.Cancel, QMessageBox.Cancel)
                if rep == QMessageBox.Cancel:
                    return
        else:
            QMessageBox.warning(self, "EXIF/XMP Export: Bilder nicht vorhanden.", "Es sind keine Bilder für die ausgewählten Einträge vorhanden.")
            return

        imageString = "'" + "','".join(finalImageList) + "'"
        #QMessageBox.information(None, "Image", u"{0}".format(imageString))

        query = QSqlQuery(self.dbm.db)
        qryStr = u"SELECT * FROM (SELECT bildnummer, hoehe, longitude, latitude,  (SELECT group_concat(fundortnummer, ';' ) FROM fundort, luftbild_senk_fp WHERE luftbild_senk_fp.bildnummer = lb.bildnummer AND Intersects(fundort.geometry, luftbild_senk_fp.geometry) AND fundort.rowid IN (SELECT rowid FROM spatialindex WHERE f_table_name='fundort' AND search_frame=luftbild_senk_fp.geometry) ORDER BY fundortnummer_nn) AS fundorte, NULL AS keyword, NULL AS description, lb.projekt, lb.copyright, land, militaernummer, militaernummer_alt, archiv, kamera, kalibrierungsnummer, kammerkonstante, fokus, fotograf, flugdatum, flugzeug FROM luftbild_senk_cp AS lb, film AS f WHERE lb.filmnummer = f.filmnummer AND lb.bildnummer IN ({0}) UNION ALL SELECT bildnummer, hoehe, longitude, latitude, (SELECT group_concat(fundortnummer, ';' ) FROM fundort, luftbild_schraeg_fp WHERE luftbild_schraeg_fp.bildnummer = lb.bildnummer AND Intersects(fundort.geometry, luftbild_schraeg_fp.geometry) AND fundort.rowid IN (SELECT rowid FROM spatialindex WHERE f_table_name='fundort' AND search_frame=luftbild_schraeg_fp.geometry) ORDER BY fundortnummer_nn) as fundorte, keyword, description, lb.projekt, lb.copyright, land, militaernummer, militaernummer_alt, archiv, kamera, kalibrierungsnummer, kammerkonstante, fokus, fotograf, flugdatum, flugzeug FROM luftbild_schraeg_cp AS lb, film AS f WHERE lb.filmnummer = f.filmnummer AND lb.bildnummer IN ({0})) ORDER BY bildnummer".format(imageString)
        query.prepare(qryStr)
        query.exec_()

        # QMessageBox.information(None, "Info", "{0}".format(query.executedQuery()))# query.lastError().text()))

        imageDir = self.settings.value("APIS/image_dir")

        query.seek(-1)
        count = 0
        while query.next():
            count += 1

        if count == 0:
            QMessageBox.warning(self, "Database Warning", "{0}, {1}".format(query.executedQuery(), query.lastError().text()))
            return

        progressDlg = QProgressDialog("XMP Metadaten werden geschrieben...", "Abbrechen", 0, count, self)
        progressDlg.setWindowModality(Qt.WindowModal)
        progressDlg.show()
        query.seek(-1)
        counting = 0
        while query.next():
            progressDlg.setValue(counting)
            if progressDlg.wasCanceled():
                break

            rec = query.record()
            metadataDict = {}
            for i in range(rec.count()):
                val = u"{0}".format(rec.value(i))
                if val.replace(" ", "") == '' or val == 'NULL':
                    val = u"---"
                metadataDict["APIS_" + rec.fieldName(i)] = val

            if self.imageRegistry.hasImage(metadataDict["APIS_bildnummer"]):
                imagePath = imageDir + "\\" + metadataDict["APIS_bildnummer"][:10] + "\\" + metadataDict["APIS_bildnummer"].replace('.', '_') + ".jpg"
                if os.path.isfile(imagePath):
                    # QMessageBox.information(None, "Image", u"{0}".format(imagePath))
                    Image2Xmp(metadataDict, imagePath)
                    counting += 1
                else:
                    QMessageBox.information(self, "Image", u"Die Bilddatei für {0} wurde nicht gefunden (FileSystem: {1}).".format(metadataDict["APIS_bildnummer"], imagePath))
            else:
                QMessageBox.information(self, "Image", u"Die Bilddatei für {0} wurde nicht gefunden (ImageRegistry).".format(metadataDict["APIS_bildnummer"]))
            #imagePath = self.settings.value("APIS/image_dir") + "\\02140301\\02140301_003.jpg"
        progressDlg.setValue(count)

    def exportListAsPdf(self):

        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)
        self.printingOptionsDlg.setWindowTitle("Druck Optionen: Bildliste")

        if self.uiImageListTableV.model().rowCount() == 1:
            self.printingOptionsDlg.configure(False, False)
        elif not self.uiImageListTableV.selectionModel().hasSelection():
            self.printingOptionsDlg.configure(False, False)
        else:
            if len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
                self.printingOptionsDlg.configure(True, False)
            elif len(self.uiImageListTableV.selectionModel().selectedRows()) == self.uiImageListTableV.model().rowCount():
                self.printingOptionsDlg.configure(False, False)
            else:
                self.printingOptionsDlg.configure(True, False)

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():
            selectionModeIsAll = self.printingOptionsDlg.selectionModeIsAll()
            imageList = self.getImageList(selectionModeIsAll)
            if imageList:
                pdfsToPrint = []
                pdfsToPrint.append({'type': APISListPrinter.IMAGE, 'idList': imageList})
                APISPrinterQueue(pdfsToPrint,
                                 OutputMode.MergeNone,
                                 openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                 openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                 dbm=self.dbm,
                                 imageRegistry=self.imageRegistry,
                                 parent=self)

    def askForImageList(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return None
        else:
            imageList = self.getImageList(True)

        return imageList

    def exportLabelsAsPdf(self):
        imageListOblique = self.getImageList(True, 3, u"schräg")
        imageListVertical = self.getImageList(True, 3, u"senk.")
        pdfsToPrint = []
        if imageListOblique:
            pdfsToPrint.append({'type': APISLabelPrinter.Oblique, 'idList': imageListOblique})

        if imageListVertical:
            pdfsToPrint.append({'type': APISLabelPrinter.Vertical, 'idList': imageListVertical})

        if pdfsToPrint:
            APISPrinterQueue(pdfsToPrint, OutputMode.MergeNone, dbm=self.dbm, parent=self)

    # def onSelectionChanged(self, current, previous):
    #     # Filter ortho = ja
    #     if self.uiImageListTableV.selectionModel().hasSelection() and len(self.getImageList(False, 6, "ja")) > 0:
    #         pass
    #         #self.uiLoadOrthoBtn.setEnabled(True)
    #     else:
    #         pass
    #         #self.uiLoadOrthoBtn.setEnabled(False)
    #     #if self.uiImageListTableV.selectionModel().hasSelection() and len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
    #     #    self.uiLoadOrthoBtn.setEnabled(True)
    #     #else:
    #     #    self.uiLoadOrthoBtn.setEnabled(False)
    #     #QMessageBox.warning(None, "FilmNumber", "selection Changed")

    def applyFilter(self):
        """
        Applies Filter to Image List
        """
        self.uiImageListTableV.selectionModel().clear()
        if self.uiFilterGrp.isChecked():
            count = 0
            for row in range(self.model.rowCount()):
                show = True
                # Weise
                if (self.uiFilterVerticalChk.checkState() == Qt.Unchecked and self.model.item(row, 3).text() == u'senk.') or (self.uiFilterObliqueChk.checkState() == Qt.Unchecked and self.model.item(row, 3).text() == u'schräg'):
                    show = False
                # Images
                if show and ((self.uiFilterScanChk.checkState() == Qt.Checked and self.model.item(row, 5).text() != self.uiFilterScanCombo.currentText()) or (self.uiFilterOrthoChk.checkState() == Qt.Checked and self.model.item(row, 6).text() != self.uiFilterOrthoCombo.currentText()) or (self.uiFilterHiResChk.checkState() == Qt.Checked and self.model.item(row, 7).text() != self.uiFilterHiResCombo.currentText())):
                    show = False
                # Scale
                if show and self.uiFilterScaleEdit.text().strip() != '':
                    imageScaleNumber = float(self.model.item(row, 2).text())
                    scaleNumber = float(self.uiFilterScaleEdit.text().replace(',', '.'))
                    operator = self.uiFilterScaleOperatorCombo.currentText()
                    if operator == '=':
                        if imageScaleNumber != scaleNumber:
                            show = False
                    elif operator == '>=':
                        if imageScaleNumber < scaleNumber:
                            show = False
                    elif operator == '<=':
                        if imageScaleNumber > scaleNumber:
                            show = False
                # filmart
                if show and self.uiFilterFilmKindChk.checkState() == Qt.Checked and self.uiFilterFilmKindCombo.currentText() != self.model.item(row, 4).text():
                    show = False

                # year
                if show and self.uiFilterFromChk.checkState() == Qt.Checked and int(self.model.item(row, 1).text()[2:6]) < self.uiFilterFromDate.date().year():
                    show = False
                if show and self.uiFilterToChk.checkState() == Qt.Checked and int(self.model.item(row, 1).text()[2:6]) > self.uiFilterToDate.date().year():
                    show = False

                if show:
                    self.uiImageListTableV.showRow(row)
                    count += 1
                else:
                    self.uiImageListTableV.hideRow(row)

            self.uiImageFilterCountLbl.setText('({0})'.format(count))
            self.uiScanFilterCountLbl.setText('({0})'.format(len(self.getImageList(True, 5, "ja"))))
            self.uiHiResFilterCountLbl.setText('({0})'.format(len(self.getImageList(True, 7, "ja"))))
            self.uiOrthoFilterCountLbl.setText('({0})'.format(len(self.getImageList(True, 6, "ja"))))

            # self.onSelectionChanged(None, None)
            # if count == 0:
            #     pass
            #     #self.uiLoadOrthoBtn.setEnabled(False)
            #     #self.uiImageThumbsBtn.setEnabled(False)
            #     #self.uiExportFootprintsBtn.setEnabled(False)
            #     #self.uiCopyImagesBtn.setEnabled(False)
            #     #self.uiPdfExportTBtn.setEnabled(False)
            # else:
            #     pass
            #     #if self.uiImageListTableV.selectionModel().hasSelection() and len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
            #     #    self.uiLoadOrthoBtn.setEnabled(True)
            #     #self.uiImageThumbsBtn.setEnabled(True)
            #     #self.uiExportFootprintsBtn.setEnabled(True)
            #     #self.uiCopyImagesBtn.setEnabled(True)
            #     #self.uiPdfExportTBtn.setEnabled(True)
        else:
            # show all rows
            for row in range(self.model.rowCount()):
                self.uiImageListTableV.showRow(row)
            self.uiImageFilterCountLbl.setText('(-)')
            self.uiScanFilterCountLbl.setText('(-)')
            self.uiHiResFilterCountLbl.setText('(-)')
            self.uiOrthoFilterCountLbl.setText('(-)')

            #self.uiImageThumbsBtn.setEnabled(True)
            #self.uiExportFootprintsBtn.setEnabled(True)
            #self.uiCopyImagesBtn.setEnabled(True)
            #self.uiPdfExportTBtn.setEnabled(True)

            self.uiFilterScanChk.setChecked(False)
            self.uiFilterHiResChk.setChecked(False)
            self.uiFilterOrthoChk.setChecked(False)

    def getMinMaxDate(self):
        years = []
        for row in range(self.model.rowCount()):
            years.append(int(self.model.item(row, 1).text()[2:6]))
        return QDate(min(years), 1, 1), QDate(max(years), 1, 1)

    # Property Panel
    def togglePropertyPanel(self, checked):
        self.uiTogglePropertyPanelBtn.setText("Properties <<" if checked else "Properties >>")
        self.isPropertyPanelActive = checked
        if checked:
            self.updatePropertyPanelVisibility()
            self.uiTargetsTableV.resizeRowsToContents()
            if self.splitterState:
                self.uiTablePropertiesSplitter.restoreState(self.splitterState)
            else:
                self.uiTablePropertiesSplitter.setSizes([800, 400])
        else:
            self.splitterState = self.uiTablePropertiesSplitter.saveState()
            self.uiTablePropertiesSplitter.setSizes([800, 0])

    def updatePropertyPanelVisibility(self):
        visibility = self.uiImageListTableV.selectionModel() and self.uiImageListTableV.selectionModel().hasSelection()
        self.uiImagePropertiesTab.setVisible(visibility)
        self.uiImageView.setVisible(visibility)
        self.uiImageNumberEdit.setVisible(visibility)
        self.uiPrevImageBtn.setVisible(visibility)
        self.uiNextImageBtn.setVisible(visibility)
        self.uiPropertyPlaceholderLbl.setVisible(not visibility)

    def updatePropertyPanelContent(self):
        imageList = self.getImageList()
        imageList.sort()
        self.currentImageList = imageList
        if self.currentImageList:
            QgsMessageLog.logMessage(f"{imageList}", tag="APIS", level=Qgis.Info)
            self.updateImagePreview()

    def updateImagePreview(self):
        if self.currentImage not in self.currentImageList:
            self.currentImage = self.currentImageList[0]
        if self.currentImage != self.uiImageNumberEdit.text():
            self.uiImageNumberEdit.setText(self.currentImage)
        self.evaluateClicker()

    def nextPrevImagePreview(self, direction):
        currentIndex = self.currentImageList.index(self.currentImage)
        newIndex = currentIndex + direction
        if self.currentImageList[newIndex] != self.uiImageNumberEdit.text():
            self.currentImage = self.currentImageList[newIndex]
            self.uiImageNumberEdit.setText(self.currentImage)

    def currentImageChanged(self, imageNumber):
        self.evaluateClicker()
        imageDir = self.settings.value("APIS/image_dir")
        path = imageDir + "\\{0}\\{1}.jpg".format(self.currentImage[:10], self.currentImage.replace('.', '_'))
        thread = LoadImageThread(file=path)
        thread.finished.connect(self.loadCurrentImageIntoPreview)

        if self.imageRegistry.hasImage(self.currentImage) and os.path.isfile(path):
            thread.start()
            # t = QgsTask.fromFunction(f'LoadImage{self.currentImage}', doSomething, on_finished=finished, file=path)
            # QgsApplication.taskManager().addTask(t, priority=999)
            # # QgsApplication.taskManager().triggerTask(t)
            # QgsMessageLog.logMessage(f"task, {t.status()}", tag="APIS", level=Qgis.Info)
        else:
            self.imageScene.clear()
            noImageTxt = QGraphicsTextItem()
            noImageTxt.setPlainText("Kein Luftbild vorhanden ...")
            self.imageRect = noImageTxt.boundingRect()
            self.imageScene.addItem(noImageTxt)
            self.imageScene.setSceneRect(self.imageRect)
            self.uiImageView.fitInView(self.imageRect, Qt.KeepAspectRatio)

    def evaluateClicker(self):
        if self.currentImage == self.currentImageList[0]:
            self.uiPrevImageBtn.setEnabled(False)
        else:
            self.uiPrevImageBtn.setEnabled(True)

        if self.currentImage == self.currentImageList[len(self.currentImageList) - 1]:
            self.uiNextImageBtn.setEnabled(False)
        else:
            self.uiNextImageBtn.setEnabled(True)

    def loadCurrentImageIntoPreviewTask(self, result):
        # self.imageScene.clear()
        # if self.imageRegistry.hasImage(self.currentImage) and os.path.isfile(path):
        #     image = QImage(path)
        #     size = image.size()
        #     self.imageRect = QRectF(0, 0, size.width(), size.height())
        #     self.imageScene.addPixmap(QPixmap.fromImage(image))
        # else:
        #     noImageTxt = QGraphicsTextItem()
        #     noImageTxt.setPlainText("Kein Luftbild vorhanden ...")
        #     self.imageRect = noImageTxt.boundingRect()
        #     self.imageScene.addItem(noImageTxt)
        QgsMessageLog.logMessage(f"{result['pixmap']}, {result['rect']}", tag="APIS", level=Qgis.Info)
        self.imageScene.clear()
        self.imageRect = result['rect']
        self.imageScene.addPixmap(result['pixmap'])
        self.imageScene.setSceneRect(self.imageRect)
        self.uiImageView.fitInView(self.imageRect, Qt.KeepAspectRatio)

    def loadCurrentImageIntoPreview(self, image, rect):
        # self.imageScene.clear()
        # if self.imageRegistry.hasImage(self.currentImage) and os.path.isfile(path):
        #     image = QImage(path)
        #     size = image.size()
        #     self.imageRect = QRectF(0, 0, size.width(), size.height())
        #     self.imageScene.addPixmap(QPixmap.fromImage(image))
        # else:
        #     noImageTxt = QGraphicsTextItem()
        #     noImageTxt.setPlainText("Kein Luftbild vorhanden ...")
        #     self.imageRect = noImageTxt.boundingRect()
        #     self.imageScene.addItem(noImageTxt)
        QgsMessageLog.logMessage(f"{image}, {rect}", tag="APIS", level=Qgis.Info)
        self.imageScene.clear()
        self.imageRect = rect
        pixmap = QPixmap.fromImage(image)
        self.imageScene.addPixmap(pixmap)
        self.imageScene.setSceneRect(rect)
        self.uiImageView.fitInView(rect, Qt.KeepAspectRatio)

    def loadTargetsForPropertyPanel(self):
        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable("target")
        model.select()
        self.uiTargetsTableV.setModel(model)

        self.uiTargetsTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiTargetsTableV.verticalHeader().setVisible(False)
        self.uiTargetsTableV.hideColumn(0)

        self.uiTargetsTableV.resizeRowsToContents()
        # self.uiTargetsTableV.resizeColumnsToContents()
        self.uiTargetsTableV.horizontalHeader().setStretchLastSection(True)

        # self.uiTargetsTableV.selectionModel().selectionChanged.connect(self.generateWeatherCode)

    def imagePropertiesTabChanged(self, index):
        if index == 1:
            self.uiTargetsTableV.resizeRowsToContents()

    def splitterWasMoved(self, pos, index):
        splitterRange = self.uiTablePropertiesSplitter.getRange(index)
        QgsMessageLog.logMessage(f"splitter index: {index}, pos: {pos}, {splitterRange}", tag="APIS", level=Qgis.Info)

        self.uiTogglePropertyPanelBtn.toggled.disconnect(self.togglePropertyPanel)
        if pos == splitterRange[1]:
            self.uiTogglePropertyPanelBtn.setChecked(False)
        else:
            self.uiTogglePropertyPanelBtn.setChecked(True)
            self.updatePropertyPanelVisibility()
            if self.uiImagePropertiesTab.currentIndex() == 1:
                self.uiTargetsTableV.resizeRowsToContents()
            if self.imageRect:
                self.uiImageView.fitInView(self.imageRect, Qt.KeepAspectRatio)
        self.uiTogglePropertyPanelBtn.toggled.connect(self.togglePropertyPanel)

    # Window show/close/resize
    def showEvent(self, event):
        self.uiTogglePropertyPanelBtn.setChecked(False)

    def resizeEvent(self, event):
        if self.uiTogglePropertyPanelBtn.isChecked() and self.uiImagePropertiesTab.currentIndex() == 1:
            self.uiTargetsTableV.resizeRowsToContents()
        if self.imageRect:
            self.uiImageView.fitInView(self.imageRect, Qt.KeepAspectRatio)

    def onClose(self):
        SetWindowSizeAndPos("image_selection_list", self.size(), self.pos())


def doSomething(task, myFile):
    """
    Raises an exception to abort the task.
    Returns a result if success.
    The result will be passed, together with the exception (None in
    the case of success), to the on_finished method.
    If there is an exception, there will be no result.
    """
    QgsMessageLog.logMessage('Started task {}'.format(task.description()), tag="APIS", level=Qgis.Info)
    image = QImage(myFile)
    size = image.size()
    rect = QRectF(0, 0, size.width(), size.height())
    pixmap = QPixmap.fromImage(image)

    return {'pixmap': pixmap, 'rect': rect}


def finished(result):
    QgsMessageLog.logMessage(f"{result['pixmap']}, {result['rect']}", tag="APIS", level=Qgis.Info)


class LoadImageThread(QThread):
    finished = pyqtSignal(object, object)

    def __init__(self, file):
        QThread.__init__(self)
        self.file = file

    def __del__(self):
        self.wait()

    def run(self):
        image = QImage(self.file)
        size = image.size()
        rect = QRectF(0, 0, int(size.width() / 8), int(size.height() / 8))
        self.finished.emit(image.scaled(rect.width(), rect.height()), rect)
