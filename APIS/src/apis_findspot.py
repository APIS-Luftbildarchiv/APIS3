# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from functools import partial

from PyQt5.QtCore import pyqtSignal, QSettings, Qt, QDate, QTime, QDateTime, QDir
from PyQt5.QtGui import QValidator, QIntValidator, QDoubleValidator, QColor, QIcon
from PyQt5.QtSql import QSqlRelationalTableModel, QSqlQuery, QSqlRelationalDelegate, QSqlQueryModel, QSqlRecord
from PyQt5.QtWidgets import (QDialog, QDataWidgetMapper, QTableView, QAbstractItemView, QComboBox, QHeaderView,
                             QMessageBox, QPushButton, QFileDialog, QMenu, QApplication, QStyle)
from PyQt5.uic import loadUiType
from qgis.core import (QgsProject, QgsVectorLayer, QgsDataSourceUri, QgsFeature)

from APIS.src.apis_findingtype_detail import APISFindingTypeDetail
from APIS.src.apis_sharding_selection_list import APISShardingSelectionList
from APIS.src.apis_text_editor import APISTextEditor
from APIS.src.apis_utils import (OpenFileOrFolder, ApisLogger, VersionToCome, SetWindowSizeAndPos, GetWindowSize,
                                 GetWindowPos, PolygonOrPoint)
from APIS.src.apis_printing_options import APISPrintingOptions
from APIS.src.apis_printer import APISPrinterQueue, APISTemplatePrinter
from APIS.src.apis_thumb_viewer import APISThumbViewer
from APIS.src.apis_chronology import APISChronology

# QgsGeometry, QgsCoordinateReferenceSystem, QgsMapSettings, QgsUnitTypes, QgsProject, QgsVectorLayer,
# QgsRasterLayer, QgsRectangle, QgsDataSourceUri, QgsFillSymbol, QgsFeature, QgsMarkerSymbol,
# QgsCentroidFillSymbolLayer, QgsSimpleLineSymbolLayer, QgsSingleSymbolRenderer, Qgis)

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_findspot.ui'), resource_suffix='')


class APISFindspot(QDialog, FORM_CLASS):

    findspotEditsSaved = pyqtSignal(bool)
    findspotDeleted = pyqtSignal(bool)

    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISFindspot, self).__init__(parent)

        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer

        self.setupUi(self)

        # Initial window size/pos last saved. Use default values for first time
        if GetWindowSize("findspot"):
            self.resize(GetWindowSize("findspot"))
        if GetWindowPos("findspot"):
            self.move(GetWindowPos("findspot"))

        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        self.editMode = False
        self.addMode = False
        self.initalLoad = True
        self.geometryEditing = False
        self.isGeometryEditingSaved = False
        # Signals/Slot Connections
        self.rejected.connect(self.onReject)
        #self.uiButtonBox.rejected.connect(self.onReject)
        self.uiOkBtn.clicked.connect(self.onAccept)
        self.uiCancelBtn.clicked.connect(self.cancelEdit)
        self.uiSaveBtn.clicked.connect(self.saveEdits)

        self.uiPlotNumberBtn.clicked.connect(lambda: self.openTextEditor("Parzellennummer", self.uiPlotNumberEdit))
        self.uiCommentBtn.clicked.connect(lambda: self.openTextEditor("Bemerkung zur Lage", self.uiCommentEdit))
        self.uiFindingTypeDetailBtn.clicked.connect(self.openFindingTypeDetailDialog)
        self.uiDatingBtn.clicked.connect(self.openChronologyDialog)

        # TODO remove
        #self.uiLoadFindspotInQGisBtn.clicked.connect(self.loadFindspotInQGis)

        self.uiViewSiteBtn.clicked.connect(self.openSiteDialog)

        self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)

        mLayer = QMenu()
        aLayerLoadSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "In QGIS laden")
        aLayerLoadSite.triggered.connect(self.loadFindspotInQgis)
        aLayerShowSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle zoomen")
        aLayerShowSite.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=False))
        aLayerSelectSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle selektieren")
        aLayerSelectSite.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=False, select=True))
        aLayerShowAndSelectSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle zoomen und selektieren")
        aLayerShowAndSelectSite.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=True))
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mSharding = QMenu()
        aShardingOverview = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'footprints.png')), "Begehungen Übersicht")
        aShardingOverview.triggered.connect(self.openShardingSelectionListDialog)
        aShardingImagesPreview = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Fotos der Begehungen in Vorschau anzeigen")
        aShardingImagesPreview.triggered.connect(self.openShardingImagesInPreview)
        aShardingImagesFolder = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Fotos der Begehungen in Ordern anzeigen")
        aShardingImagesFolder.triggered.connect(self.openShardingImagesInFolder)
        self.uiShardingTBtn.setMenu(mSharding)
        self.uiShardingTBtn.clicked.connect(self.uiShardingTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        aPdfExportFindspot.triggered.connect(lambda: self.exportAsPdf(detail=True))
        aPdfExportFindspotAndSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle und Fundort")
        aPdfExportFindspotAndSite.triggered.connect(lambda: self.exportAsPdf(detail=True, parentDetail=True))
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        mFindspot = QMenu()
        aFindspotClone = mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'findspot_clone.png')), "Fundstelle klonen")
        aFindspotClone.triggered.connect(self.cloneFindspot)
        # TODO: implement MoveFindspotToSite
        # aFindspotMoveToSite.mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        # aFindspotMoveToSite.triggered.connect(self.exportDetailsPdf)
        aFindspotDelete = mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'findspot_delete.png')), "Fundstelle löschen")
        aFindspotDelete.triggered.connect(self.deleteFindspot)
        self.uiFindspotTBtn.setMenu(mFindspot)
        self.uiFindspotTBtn.clicked.connect(self.uiFindspotTBtn.showMenu)

        # Setup Sub-Dialogs
        self.printingOptionsDlg = None
        self.initalLoad = False

    def openInViewMode(self, siteNumber, findspotNumber):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.findspotNumber = findspotNumber

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundstelle")
        self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(self.siteNumber, self.findspotNumber))
        res = self.model.select()

        #QMessageBox.warning(None, "Funstellen Row Count", u"{0}".format(self.model.rowCount()))
        self.setupMapper()
        self.mapper.toFirst()

        #QMessageBox.warning(None, "Mapper", u"period detail: {0}".format(self.uiDatingPeriodDetailCombo.lineEdit().text()))

        query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)

        self.initalLoad = False

        #self.setupFindspotList()

    def openInAddMode(self, siteNumber, findspotNumber):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.findspotNumber = findspotNumber

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundstelle")
        self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(self.siteNumber, self.findspotNumber))
        res = self.model.select()

        #QMessageBox.warning(None, "Funstellen Row Count", u"{0}".format(self.model.rowCount()))
        self.setupMapper()
        self.mapper.toFirst()

        #QMessageBox.warning(None, "Mapper", u"period detail: {0}".format(self.uiDatingPeriodDetailCombo.lineEdit().text()))

        query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)

        self.addMode = True
        self.startEditMode()

        self.initalLoad = False

    # def openInEditMode(self, siteNumber, kgCode, kgName, siteArea):
    #     self.initalLoad = True
    #     self.siteNumber = siteNumber
    #     self.geometryEditing = True
    #
    #     # Setup site model
    #     self.model = QSqlRelationalTableModel(self, self.dbm.db)
    #     self.model.setTable("fundort")
    #     self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
    #     res = self.model.select()
    #     self.setupMapper()
    #     self.mapper.toFirst()
    #
    #     self.startEditMode()
    #     self.initalLoad = False
    #
    #     #update Editors
    #     if self.uiCadastralCommunityNumberEdit.text() != kgCode:
    #         self.uiCadastralCommunityNumberEdit.setText(kgCode)
    #     if self.uiCadastralCommunityEdit.text() != kgName:
    #         self.uiCadastralCommunityEdit.setText(kgName)
    #     if self.uiAreaEdit.text() != siteArea:
    #         self.uiAreaEdit.setText(unicode(siteArea))


    # def openInAddMode(self, siteNumber):
    #     self.initalLoad = True
    #     self.siteNumber = siteNumber
    #
    #     # Setup site model
    #     self.model = QSqlRelationalTableModel(self, self.dbm.db)
    #     self.model.setTable("fundort")
    #     self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
    #     res = self.model.select()
    #     self.setupMapper()
    #     self.mapper.toFirst()
    #
    #     self.addMode = True
    #     self.startEditMode()
    #
    #     self.initalLoad = False



    def setupMapper(self):
        self.mapper = QDataWidgetMapper(self)
        self.mapper.setSubmitPolicy(QDataWidgetMapper.ManualSubmit)
        self.mapper.setItemDelegate(FindspotDelegate())

        self.mapper.setModel(self.model)

        self.mandatoryEditors = [self.uiCaseWorkerEdit, self.uiFindspotCreationCombo, self.uiSiteReliabilityCombo, self.uiDatingTimeCombo, self.uiDatingPeriodCombo, self.uiFindingTypeCombo]

        # LineEdits & PlainTextEdits
        self.intValidator = QIntValidator()
        self.doubleValidator = QDoubleValidator()

        self.uiFindspotNumberEdit.setText("{0}.{1}".format(self.siteNumber, self.findspotNumber))
        # From fundort: KG Nummer, KG Name, Flurname
        query = QSqlQuery(self.dbm.db)
        query.prepare("SELECT katastralgemeindenummer, katastralgemeinde, flurname FROM fundort WHERE fundortnummer = '{0}'".format(self.siteNumber))
        query.exec_()
        query.first()

        self.uiCadastralCommunityNumberEdit.setText(str(query.value(0)))
        self.uiCadastralCommunityEdit.setText(str(query.value(1)))
        # self.uiFieldNameEdit.setText(str('' if query.isNull(2) else query.value(2)))


        self.lineEditMaps = {
            "common_name": {
                "editor": self.uiCommonNameEdit
            },
            "flurname": {
                "editor": self.uiFieldNameEdit
            },
            "bearbeiter": {
                "editor": self.uiCaseWorkerEdit
            },
            "erstmeldung_jahr": {
                "editor": self.uiFirstReportYearEdit,
                "validator": self.intValidator
            },
            "erhaltung": {
                "editor": self.uiPreservationStateEdit
            },
            "parzellennummern": {
                "editor": self.uiPlotNumberEdit
            },
            "bdanummer": {
                "editor": self.uiBdaNumberEdit
            },
            "kommentar_lage": {
                "editor": self.uiCommentEdit
            },
            "flaeche": {
                "editor": self.uiAreaEdit,
                "validator": self.doubleValidator
            },
            "datum_abs_1": {
               "editor": self.uiAbsoluteDatingFromEdit
            },
            "datum_abs_2": {
                "editor": self.uiAbsoluteDatingToEdit
            },
            "befundart_detail":{
                "editor": self.uiFindingTypeDetailEdit
            },
            "literatur":{
                "editor": self.uiLiteraturePTxt
            },
            "fundbeschreibung":{
                "editor": self.uiFindingsPTxt
            },
            "fundverbleib": {
                "editor": self.uiFindingsStoragePTxt
            },
            "sonstiges": {
                "editor": self.uiMiscellaneousPTxt
            },
            "befundgeschichte": {
                "editor": self.uiFindingsHistoryPTxt
            },
            "befund": {
                "editor": self.uiFindingsInterpretationPTxt
            }
        }
        for key, item in self.lineEditMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            if "validator" in item:
                item["editor"].setValidator(item["validator"])
            #item["editor"].textChanged.connect(partial(self.onLineEditChanged, item["editor"]))
            item["editor"].textChanged.connect(self.onLineEditChanged)

        # Date and Times
        self.mapper.addMapping(self.uiInitalEntryDate, self.model.fieldIndex("datum_ersteintrag"))
        self.mapper.addMapping(self.uiLastChangesDate, self.model.fieldIndex("datum_aenderung"))

        # ComboBox without Model
        self.mapper.addMapping(self.uiSiteReliabilityCombo, self.model.fieldIndex("sicherheit"))
        self.uiSiteReliabilityCombo.editTextChanged.connect(self.onLineEditChanged)
        # FIXME Pyqt5 AutoCompletion
        #self.uiSiteReliabilityCombo.setAutoCompletion(True)
        self.uiSiteReliabilityCombo.lineEdit().setValidator(InListValidator([self.uiSiteReliabilityCombo.itemText(i) for i in range(self.uiSiteReliabilityCombo.count())], self.uiSiteReliabilityCombo.lineEdit(), None, self))

        # ComboBox with Model
        self.comboBoxMaps = {
            "fundgewinnung_quelle": {
                "editor": self.uiFindspotCreationCombo,
                "table": "fundgewinnung_quelle",
                "modelcolumn": 0,
                "justshowcolumn": True,
                "depend": None
            },
            # "datierung_zeitstufe": {
            #     "editor": self.uiDatingTimeCombo,
            #     "table": "zeit",
            #     "modelcolumn": 0,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "datierung_periode": {
            #     "editor": self.uiDatingPeriodCombo,
            #     "table": "zeit",
            #     "modelcolumn": 1,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "datierung_periode_detail": {
            #     "editor": self.uiDatingPeriodDetailCombo,
            #     "table": "zeit",
            #     "modelcolumn": 2,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            "phase_von": {
                "editor": self.uiFineDatingFromCombo,
                "table": "phase",
                "modelcolumn": 1,
                "justshowcolumn": True,
                "depend": None
            },
            "phase_bis": {
                 "editor": self.uiFineDatingToCombo,
                 "table": "phase",
                 "modelcolumn": 1,
                 "justshowcolumn": True,
                 "depend": None
            },
            "datierungsbasis": {
                "editor": self.uiDatingSourceCombo,
                "table": "datierung_quelle",
                "modelcolumn": 0,
                "justshowcolumn": True,
                "depend": None
            },
            "kultur": {
                "editor": self.uiCultureCombo,
                "table": "kultur",
                "modelcolumn": 0,
                "justshowcolumn": False,
                "depend": None
            }#,
            # "befundart": {
            #     "editor": self.uiFindingTypeCombo,
            #     "table": "befundart",
            #     "modelcolumn": 0,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "befundart_detail": {
            #     "editor": self.uiFindingTypeDetailCombo,
            #     "table": "befundart",
            #     "modelcolumn": 0,
            #     "justshowcolumn": False,
            #     "depend": None
            # }
        }
        for key, item in self.comboBoxMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            self.setupComboBox(item["editor"], item["table"], item["modelcolumn"], item["justshowcolumn"], item["depend"])
            item["editor"].editTextChanged.connect(self.onLineEditChanged)


        #befundart
        self.mapper.addMapping(self.uiFindingTypeCombo, self.model.fieldIndex("befundart"))
        query = u"SELECT DISTINCT {0} FROM {0}".format("befundart")
        self.setupComboBoxByQuery(self.uiFindingTypeCombo, query)
        self.uiFindingTypeCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiFindingTypeCombo.currentIndexChanged.connect(self.resetFindingTypeDetail)


        #datierung
        self.mapper.addMapping(self.uiDatingTimeCombo, self.model.fieldIndex("datierung_zeitstufe"))
        self.mapper.addMapping(self.uiDatingPeriodCombo, self.model.fieldIndex("datierung_periode"))
        self.mapper.addMapping(self.uiDatingPeriodDetailCombo, self.model.fieldIndex("datierung_periode_detail"))



        #query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        #self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        #self.uiDatingTimeCombo.setCurrentIndex(-1)

        #txt = self.uiDatingTimeCombo.lineEdit().text()
        #idx = self.uiDatingTimeCombo.findText(txt)
        #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}, {1}".format(txt, idx))
        #self.loadPeriodContent(0)
        #self.loadPeriodDetailsContent(0)

        #self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        #self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)
        # self.uiDatingCombo.currentIndexChanged.connect(self.joinRowValues)

    def loadPeriodContent(self, row):
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"TimeCombo Chagned: {0}".format(row))
        #pass
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"P: {0}".format(self.sender()))

        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}, {1}".format(time, period))
        #if time != "":
        #time = self.uiDatingTimeCombo.lineEdit().text()
        #period = self.uiDatingPeriodCombo.lineEdit().text()
        # QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}".format(time))
        self.setupComboBoxByQuery(self.uiDatingPeriodCombo, u"SELECT DISTINCT periode FROM zeit WHERE zeit ='{0}'".format(time))

        if self.initalLoad:
            index = self.uiDatingPeriodCombo.findText(period)
        else:
            index = self.uiDatingPeriodCombo.findText(time)

        # QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}".format(index))


        if index < 0 and self.uiDatingPeriodCombo.count() == 1:
            self.uiDatingPeriodCombo.setCurrentIndex(0)
        else:
            self.uiDatingPeriodCombo.setCurrentIndex(index)


    def loadPeriodDetailsContent(self, row):
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"PD: {0}".format(self.sender()))
        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        periodDetail = self.uiDatingPeriodDetailCombo.lineEdit().text()

        # QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}".format(periodDetail))
        self.setupComboBoxByQuery(self.uiDatingPeriodDetailCombo, u"SELECT DISTINCT periode_detail FROM zeit WHERE zeit = '{0}' AND periode = '{1}'".format(time, period))

        if self.initalLoad:
            index = self.uiDatingPeriodDetailCombo.findText(periodDetail)
        else:
            index = self.uiDatingPeriodDetailCombo.findText(period)


        if index < 0 and self.uiDatingPeriodDetailCombo.count() == 1:
            self.uiDatingPeriodDetailCombo.setCurrentIndex(0)
        else:
            self.uiDatingPeriodDetailCombo.setCurrentIndex(index)

    def resetFindingTypeDetail(self, row):
        self.uiFindingTypeDetailEdit.clear()

    #def setupComboBoxByQuery(self, editor, query):
    def setupComboBoxByQuery(self, editor, query, modelcolumn=0):
        currentText = editor.lineEdit().text()
        model = QSqlQueryModel(self)
        #model.setQuery("SELECT DISTINCT {0} FROM {1} ORDER BY {2}".format(column, table, order), self.dbm.db)
        model.setQuery(query, self.dbm.db)

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)
        tv.setWordWrap(True)

        editor.setModel(model)

        editor.setModelColumn(modelcolumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)
        scroll = 0 if editor.count() <= editor.maxVisibleItems() else QApplication.style().pixelMetric(QStyle.PM_ScrollBarExtent)
        tv.setMinimumWidth(tv.horizontalHeader().length() + scroll)
        tv.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # FIXME Pyqt5 AutoCompletion
        #editor.setAutoCompletion(True)
        editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), None, self))

        editor.setCurrentIndex(editor.findText(currentText))
        #editor.setCurrentIndex(-1)

    def setupComboBox(self, editor, table, modelColumn, justShowColumn, depend):
        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable(table)
        model.removeColumn(0)
        model.select()

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)
        tv.setWordWrap(True)

        editor.setModel(model)
        if justShowColumn:
            cCount = model.columnCount()
            for i in range(cCount):
                if i != modelColumn:
                    tv.hideColumn(i)

        editor.setModelColumn(modelColumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)

        #tv.setMinimumWidth(500)
        scroll = 0 if editor.count() <= editor.maxVisibleItems() else QApplication.style().pixelMetric(QStyle.PM_ScrollBarExtent)
        tv.setMinimumWidth(tv.horizontalHeader().length() + scroll)
        tv.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # FIXME Pyqt5 AutoCompletion
        #editor.setAutoCompletion(True)
        editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), depend, self))

        if depend:
            editor.currentIndexChanged.connect(partial(self.updateDepends, editor, depend))


    def updateDepends(self, editor, depend):
         for dep in depend:
            for key, value in dep.iteritems():
                idx = editor.model().createIndex(editor.currentIndex(), editor.model().fieldIndex(key))
                value.setText(str(editor.model().data(idx)))
                #QMessageBox.warning(None, "Test", str(idx))

    # def joinRowValues(self, row):
    #     editor = self.sender()
    #     #QMessageBox.warning(None, self.tr(u"Katastralgemeinde"), u"{0}".format(editor))
    #     record = editor.model().record(row)
    #     values = []
    #     for i in range(record.count()):
    #         values.append(record.value(i))
    #     editor.lineEdit().setText(", ".join(values))


    def enableItemsInLayout(self, layout, enable):
        for i in range(layout.count()):
            if layout.itemAt(i).widget():
                layout.itemAt(i).widget().setEnabled(enable)


    def onLineEditChanged(self):
        sender = self.sender()
        if not self.editMode and not self.initalLoad:
            self.startEditMode()
        if not self.initalLoad:
            sender.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(sender.metaObject().className()))
            self.editorsEdited.append(sender)



    def openTextEditor(self, title, editor):
        textEditorDlg = APISTextEditor(self)
        textEditorDlg.setWindowTitle(title)
        textEditorDlg.setText(editor.text())
        if textEditorDlg.exec_():
            editor.setText(textEditorDlg.getText())

    def openFindingTypeDetailDialog(self):
        findingTypeDetailDlg = APISFindingTypeDetail(self.iface, self.dbm, self)
        res = findingTypeDetailDlg.loadList(self.uiFindingTypeCombo.currentText(), self.uiFindingTypeDetailEdit.text())
        if res and findingTypeDetailDlg.exec_():
            self.uiFindingTypeDetailEdit.setText(findingTypeDetailDlg.getFindingTypeDetailText())

    def openChronologyDialog(self):
        chronologyDlg = APISChronology(self.uiFindspotNumberEdit.text()[:3], self)
        if chronologyDlg.isSetup and chronologyDlg.exec_():
            pass

    def onAccept(self):
        '''
        Check DB
        Save options when pressing OK button
        Update Plugin Status
        '''

        # Save Settings

        self.accept()

    def onReject(self):
        '''
        Run some actions when
        the user closes the dialog
        '''
        if self.editMode:
            res = self.cancelEdit()
            if res:
                self.close()
                return "ABC"
            else:
                self.show()
        else:
            self.close()

    def closeEvent(self, e):
        # Write window size and position to QSettings
        if self.editMode:
            self.onReject()
        else:
            SetWindowSizeAndPos("findspot", self.size(), self.pos())
            e.accept()

    def loadFindspotInQgis(self):
        polygon, point = PolygonOrPoint(parent=self)
        if polygon or point:
            # get PolygonLayer
            findspotNumber = self.uiFindspotNumberEdit.text()
            subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" = "{0}"'.format(findspotNumber)
            findspotLayer = self.apisLayer.getSpatialiteLayer(u"fundstelle", subsetString, u"fundstelle polygon {0}".format(findspotNumber))

            if polygon and findspotLayer:
                findspotLayerMemory = self.apisLayer.createMemoryLayer(findspotLayer)
                findspotLayerMemory.loadNamedStyle(self.apisLayer.getStylePath("find_spots_fp"))
                # load PolygonLayer
                self.apisLayer.addLayerToCanvas(findspotLayerMemory, "Temp")

            if point and findspotLayer:
                # generate PointLayer
                centerPointLayer = self.apisLayer.generateCenterPointMemoryLayer(findspotLayer, u"fundstelle punkt {0}".format(findspotNumber))
                centerPointLayer.loadNamedStyle(self.apisLayer.getStylePath("find_spots_cp"))
                # load PointLayer
                self.apisLayer.addLayerToCanvas(centerPointLayer, "Temp")

    def showFindspotInQgis(self, zoomTo=True, select=False):
        layer = self.apisLayer.requestFindspotLayer()
        findspotNumber = self.uiFindspotNumberEdit.text()
        expression = u"\"fundortnummer\"  || '.' || \"fundstellenummer\" = '{0}'".format(findspotNumber)
        self.apisLayer.selectFeaturesByExpression(layer, expression)
        if zoomTo:
            self.apisLayer.zoomToSelection(layer)
        if not select:
            layer.removeSelection()

    def openShardingSelectionListDialog(self):
        #if self.shardingDlg == None:
        shardingDlg = APISShardingSelectionList(self.iface, self.dbm, parent=self)
        shardingDlg.loadShardingListBySiteNumber(self.siteNumber)
        if shardingDlg.exec_():
            pass
            #self.shardingDlg = None

    #TODO: move Sharding opening stuff into utils (since it is now not only used in apis_sharding.py but also in site and findspot
    def openShardingImagesInPreview(self):
        dirName = self.settings.value("APIS/insp_image_dir")
        folderNameType = self.settings.value("APIS/insp_image_foto_dir")
        folderNameSite = self.getFolderNameSite(self.siteNumber)
        path = dirName + u'\\' + folderNameSite + u'\\' + folderNameType

        self.loadInImageViewer(path)

    def openShardingImagesInFolder(self):
        dirName = self.settings.value("APIS/insp_image_dir")
        folderNameType = self.settings.value("APIS/insp_image_foto_dir")
        folderNameSite = self.getFolderNameSite(self.siteNumber)
        path = dirName + u'\\' + folderNameSite + u'\\' + folderNameType

        if not OpenFileOrFolder(path):
            QMessageBox.information(self, u"Begehung", u"Das Verzeichnis '{0}' wurde nicht gefunden.".format(path))

    def getFolderNameSite(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        #qryStr = u"SELECT trim(katastralgemeinde) || ' ' || trim(katastralgemeindenummer) || '.' || substr('000' || fundortnummer_nn_legacy, -3, 3) AS folderName FROM fundort f WHERE f.fundortnummer='{0}'".format(siteNumber)
        query.prepare(u"SELECT land || '\\'  || CASE WHEN land = 'AUT' THEN replace(replace(replace(replace(lower(trim(katastralgemeinde)), '.',''), '-', ' '), '(', ''), ')', '') || ' ' ELSE '' END || substr('000000' || fundortnummer_nn, -6, 6) AS folderName FROM fundort f WHERE f.fundortnummer='{0}'".format(siteNumber))
        query.exec_()
        query.first()
        return query.value(0)

    def loadInImageViewer(self, path):
        dir = QDir(path)
        if dir.exists():
            entryList = dir.entryList(['*.jpg'], QDir.Files)
            if len(entryList) > 0:
                # load in thumb viewer
                # QMessageBox.information(None, u"Begehung", u",".join(entryList))
                imagePathList = []
                for image in entryList:
                    imagePathList.append(path + u'\\' + image)

                widget = APISThumbViewer()
                widget.load(imagePathList)
                widget.show()
                if widget.exec_():
                    pass
                    # app.exec_()
            else:
                QMessageBox.information(self, u"Begehung", u"Es wurden keine Dateien [*.jpg] für diesen Fundort gefunden.")
        else:
            QMessageBox.information(self, u"Begehung", u"Das Verzeichnis '{0}' wurde nicht gefunden.".format(path))


    def cloneFindspot(self):
        self.initalLoad = True
        currentRecord = QSqlRecord(self.model.record(self.mapper.currentIndex()))

        siteNumber = currentRecord.value('fundortnummer')
        findspotNumberSource = currentRecord.value('fundstellenummer')
        findspotNumber = self.getNextFindspotNumber(siteNumber)
        currentRecord.setValue('ogc_fid', None)
        currentRecord.setValue('fundstellenummer', findspotNumber)
        now = QDate.currentDate()
        currentRecord.setValue('datum_ersteintrag', now.toString("yyyy-MM-dd"))
        currentRecord.setValue('datum_aenderung', now.toString("yyyy-MM-dd"))

        import getpass
        currentRecord.setValue('aktion', 'clone')
        currentRecord.setValue('aktionsdatum', now.toString("yyyy-MM-dd"))
        currentRecord.setValue('aktionsuser', getpass.getuser())

        #QMessageBox.information(None, "info", "{}".format(", ".join(["{}".format(currentRecord.value(c)) for c in range(currentRecord.count())])))

        # res = self.model.insertRowIntoTable(currentRecord)
        res = self.model.insertRecord(-1, currentRecord)
        if not res:
            # QMessageBox.information(None, "SqlError", "{0}, {1}".format(self.model.lastError().text(), self.model.query().executedQuery()))
            QMessageBox.warning(self, "Fundort Klonen", "Bitte schließen Sie das Fenster und öffnen es erneut ohne Änderungen an der Funstelle vorzunehmen vor dem Klonvorgang. (Anmerkunk: ein noch nicht identifizierter Bug verhindert das korrekte Klonen).")
        else:
            self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(siteNumber, findspotNumber))
            res = self.model.select()
            self.mapper.toFirst()
            self.uiFindspotNumberEdit.setText("{0}.{1}".format(siteNumber, findspotNumber))

            self.findspotNumber = findspotNumber
            self.siteNumber = siteNumber

            self.findspotEditsSaved.emit(True)

            # in log eintragen
            ApisLogger(self.dbm.db, "clone", "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

            QMessageBox.information(self, u"Fundstelle Klonen", u"Die Fundstelle {0}.{1} wurde geklont und gespeichert: {0}.{2}".format(siteNumber, findspotNumberSource, findspotNumber))
        self.initalLoad = False

    def deleteFindspot(self):
        # Abfrage wirklich löschen
        header = u"Fundstelle löschen"
        question = u"Möchten Sie die Fundstelle wirklich aus der Datenbank löschen?"
        result = QMessageBox.question(self,
                                      header,
                                      question,
                                      QMessageBox.Yes | QMessageBox.No,
                                      QMessageBox.Yes)

        # save or not save

        if result == QMessageBox.Yes:
            # TODO: remove
            # self.apisLogger(u"delete", u"fundstelle", u"fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))
            ApisLogger(self.dbm.db, "delete", "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

            # löschen
            self.model.deleteRowFromTable(self.mapper.currentIndex())

            self.findspotDeleted.emit(True)
            self.iface.mapCanvas().refreshAllLayers()
            self.done(1)

    # TODO remove
    # def apisLogger(self, action, fromTable, primaryKeysWhere):
    #     toTable = fromTable + u"_log"
    #     query = QSqlQuery(self.dbm.db)
    #     query.prepare(u"INSERT INTO {0} SELECT * FROM {1} WHERE {2}".format(toTable, fromTable, primaryKeysWhere))
    #
    #     res = query.exec_()
    #     #QMessageBox.information(None, "SqlQuery", query.executedQuery())
    #     if not res:
    #         QMessageBox.information(self, "SqlError", "{0}, {1}".format(query.lastError().text(), query.executedQuery()))
    #     import getpass
    #     query.prepare(u"UPDATE {0} SET aktion = '{1}', aktionsdatum = '{2}', aktionsuser = '{3}' WHERE rowid = (SELECT max(rowid) FROM {0})".format(toTable, action, QDateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss"), getpass.getuser(), primaryKeysWhere))
    #     res = query.exec_()
    #     #QMessageBox.information(None, "SqlQuery", query.executedQuery())
    #     if not res:
    #         QMessageBox.information(self, "SqlError", query.lastError().text())

    def getNextFindspotNumber(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT CASE WHEN max(fundstellenummer) IS NULL THEN 1 ELSE max(fundstellenummer)+1 END AS nextFindspot FROM fundstelle WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return query.value(0)

    def exportAsPdf(self, detail=False, parentDetail=False):
        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)

        if detail and not parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle")
            filmProject = False
        elif detail and parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle und Fundort")
            filmProject = True
        else:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle")
            filmProject = False

        self.printingOptionsDlg.configure(False, parentDetail, visPersonalDataChk=True, visFilmProjectChk=filmProject)  # only if parent site is selected allow outputmode

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():
            # get settings from dialog
            printPersonalData = self.printingOptionsDlg.printPersonalData()
            printFilmProject = self.printingOptionsDlg.printFilmProject()
            outputMode = self.printingOptionsDlg.outputMode()

            pdfsToPrint = []
            if detail:
                if parentDetail:
                    pdfsToPrint.append({'type': APISTemplatePrinter.SITE, 'idList': [self.siteNumber], 'options': {'filmProject': printFilmProject}})
                pdfsToPrint.append({'type': APISTemplatePrinter.FINDSPOT, 'idList': ["{0}.{1}".format(self.siteNumber, self.findspotNumber)], 'options': {'personalData': printPersonalData}})

            if pdfsToPrint:
                APISPrinterQueue(pdfsToPrint,
                                 outputMode,
                                 openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                 openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                 dbm=self.dbm,
                                 parent=self)

    def openSiteDialog(self):
        from APIS.src.apis_site import APISSite
        # if parent is instance of ApisSiteDialog then just close
        # if parent is ApisFindspotSelectionListDialog then open ApisSiteDialog and close ApisFindspotDialog
        if isinstance(self.parentWidget(), APISSite):
            #QMessageBox.warning(None, "Test", u"{0}".format(self.parentWidget()))
            self.close()
        else:
            siteDlg = APISSite(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self.parentWidget())
            siteDlg.openInViewMode(self.siteNumber)
            self.close()
            siteDlg.show()
            if siteDlg.exec_():
                pass
            siteDlg.removeSitesFromSiteMapCanvas()

    def removeNewFindspot(self):
        self.initalLoad = True
        row = self.mapper.currentIndex()
        self.model.removeRow(row)
        self.model.submitAll()
        self.initalLoad = False

    def saveEdits(self):
        # Check Mandatory fields
        flag = False
        for mEditor in self.mandatoryEditors:
            cName = mEditor.metaObject().className()
            if cName == 'QLineEdit':
                value = mEditor.text()
            elif cName == 'QComboBox':
                if mEditor.isEditable():
                    value = mEditor.lineEdit().text()
                else:
                    if mEditor.currentIndex == -1:
                        value = ''
                    else:
                        value = '1'
            if value.strip() == "":
                flag = True
                # ROT wenn Plichtfeld leer
                mEditor.setStyleSheet("{0} {{background-color: rgb(240, 160, 160);}}".format(cName))
                if mEditor not in self.editorsEdited:
                    self.editorsEdited.append(mEditor)
            else:
                if mEditor in self.editorsEdited:
                    # BLAU wenn Pflichtfeld nicht leer und editiert
                    mEditor.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(cName))
                #else:
                    #mEditor.setStyleSheet("")
        if flag:
            QMessageBox.warning(self, self.tr(u"Benötigte Felder Ausfüllen"), self.tr(u"Füllen Sie bitte alle Felder aus, die mit * gekennzeichnet sind."))
            return False

        #saveToModel
        currIdx = self.mapper.currentIndex()
        now = QDate.currentDate()
        self.uiLastChangesDate.setDate(now)

        if self.addMode:
            action = u"new"
        else:
            action = u"editA"
            #Update AKTION only in EDIT Mode
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktion")), u"editAG" if self.geometryEditing else u"editA")
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsdatum")), now.toString("yyyy-MM-dd"))
            import getpass
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsuser")), getpass.getuser())

        self.mapper.submit()

        #emit signal
        self.findspotEditsSaved.emit(True)

        #log
        ApisLogger(self.dbm.db, action, "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

        self.mapper.setCurrentIndex(currIdx)
        self.endEditMode()

        self.iface.mapCanvas().refreshAllLayers()
        #
        if not self.isGeometryEditingSaved:
            self.isGeometryEditingSaved = True
        return True

    def cancelEdit(self):
        currIdx = self.mapper.currentIndex()
        if self.editMode:
            if self.addMode:
                header = self.tr(u"Neue Fundstelle wurden hinzugefügt!")
                question = self.tr(u"Möchten Sie die neue Fundstelle speichern?")
            elif self.geometryEditing:
                header = self.tr(u"Änderungen an der Fundstellen Geometrie wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änderungen der Geometrie und Attribute speichern?")
            else:
                header = self.tr(u"Änderungen wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änderungen der Attribute speichern?")
            result = QMessageBox.question(self,
                                          header,
                                          question,
                                          QMessageBox.Yes | QMessageBox.No ,
                                          QMessageBox.Yes)

            #save or not save
            if result == QMessageBox.Yes:
                res = self.saveEdits()
                if res:
                    return True
                else:
                    return False
            elif result == QMessageBox.No:
                self.geometryEditing = False
                if self.addMode:
                    self.removeNewFindspot()
                    self.endEditMode(False)
                    self.close()
                    return True
                else:
                    self.mapper.setCurrentIndex(currIdx)
                    self.endEditMode(False)
                    return True

    def startEditMode(self):
        self.editMode = True
        #self.setWindowModality(Qt.ApplicationModal)
        #self.setModal(True)
        #geomHelper = self.saveGeometry()
        #self.hide()
        #self.show()
        #self.restoreGeometry(geomHelper)
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, False)
        self.uiOkBtn.setEnabled(False)
        self.uiSaveBtn.setEnabled(True)
        self.uiCancelBtn.setEnabled(True)
        self.editorsEdited = []

    def endEditMode(self, modalityFlag=True):
        self.editMode = False
        self.addMode = False
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, True)
        self.uiOkBtn.setEnabled(True)
        self.uiSaveBtn.setEnabled(False)
        self.uiCancelBtn.setEnabled(False)
        for editor in self.editorsEdited:
            cName = editor.metaObject().className()
            if (cName == "QLineEdit" or cName == "QDateEdit") and editor.isReadOnly():
                editor.setStyleSheet("{0} {{background-color: rgb(218, 218, 218);}}".format(cName))
            else:
                editor.setStyleSheet("")
        self.editorsEdited = []

        #self.uiDatingTimeCombo.editTextChanged.disconnect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.disconnect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.disconnect(self.onLineEditChanged)
        self.initalLoad = True
        self.uiDatingTimeCombo.currentIndexChanged.disconnect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.loadPeriodDetailsContent)
        #self.loadPeriodContent(0)
        #self.loadPeriodDetailsContent(0)
        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        periodDetail = self.uiDatingPeriodDetailCombo.lineEdit().text()
        #QMessageBox.warning(None, "Test", u"{0}, {1}, {2}".format(time, period, periodDetail))

        self.uiDatingTimeCombo.setCurrentIndex(self.uiDatingTimeCombo.findText(time))
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        #self.setupComboBoxByQuery(self.uiDatingPeriodCombo, u"SELECT DISTINCT periode FROM zeit WHERE zeit ='{0}'".format(time))
        #self.uiDatingPeriodCombo.setCurrentIndex(self.uiDatingPeriodCombo.findText(period))
        #self.setupComboBoxByQuery(self.uiDatingPeriodDetailCombo, u"SELECT DISTINCT periode_detail FROM zeit WHERE zeit = '{0}' AND periode = '{1}'".format(time, period))
        #self.uiDatingPeriodDetailCombo.setCurrentIndex(self.uiDatingPeriodDetailCombo.findText(periodDetail))

        #self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)
        self.initalLoad = False
        #self.setWindowModality(Qt.NonModal)
        #self.setModal(False)
        #if modalityFlag:
        #    self.hide()
        #    self.show()

    def isGeometrySaved(self):
        return self.isGeometryEditingSaved and self.geometryEditing

class FindspotDelegate(QSqlRelationalDelegate):
    def __init__(self):
       QSqlRelationalDelegate.__init__(self)

    def createEditor(self, parent, option, index):
        pass

    def setEditorData(self, editor, index):
        #QMessageBox.warning(None, "Test", str(editor.metaObject().className(index))()) + str
        value = str(index.model().data(index, Qt.EditRole))

        if value == 'NULL':
            value = ''

        if editor.metaObject().className() == 'QTimeEdit' and value == '':
            editor.setTime(QTime(0,0,0))
            #if value == '':
                #value ="00:00:00"

        elif editor.metaObject().className() == 'QLineEdit':
            editor.setText(value)

        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 3: #3 - sicherheit
                #if value == '':
                #    editor.setCurrentIndex(-1)
                #else:
                #    editor.setCurrentIndex(int(value) - 1)
                try:
                    editor.setCurrentIndex(int(value) - 1)
                except ValueError:
                    editor.setCurrentIndex(-1)

            else:
                editor.setEditText(value)

        elif editor.metaObject().className() == 'QListWidget':
            #QMessageBox.warning(None, "Test", unicode(index.model().data(index, Qt.EditRole)))
            editor.clear()
            editor.addItems(str.split(value, ";"))
        else:
            QSqlRelationalDelegate.setEditorData(self, editor, index)

    def setModelData(self, editor, model, index):
        #if editor.metaObject().className() == 'QLineEdit':
            #QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #if unicode(index.data(Qt.DisplayRole)) != unicode(editor.text()):
            #    QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #    model.setData(index, editor.text())

        # if index.column() == 0: #0 ... filmnummer, 1 ... filmnummer_legacy, 2 ... filmnummer_hh_jjjj_mm, 3 ... filmnummer_nn
        #     #QMessageBox.warning(None, "Test", unicode(index.column()) + editor.text())
        #     filmnummer = str(editor.text())
        #     model.setData(model.createIndex(index.row(), 2), filmnummer[:8]) # filmnummer_hh_jjjj_mm
        #     model.setData(model.createIndex(index.row(), 3), int(filmnummer[-2:])) # filmnummer_nn
        #     model.setData(model.createIndex(index.row(), 0), filmnummer) #filmnummer
        #     mil = ""
        #     if filmnummer[2:4] == "19":
        #         mil = "01"
        #     elif filmnummer[2:4] == "20":
        #         mil = "02"
        #     model.setData(model.createIndex(index.row(), 1), mil + filmnummer[4:]) # filmnummer_legacy

        # elif editor.metaObject().className() == 'QDateEdit':
        if editor.metaObject().className() == 'QDateEdit':
            model.setData(index, editor.date().toString("yyyy-MM-dd"))
        elif editor.metaObject().className() == 'QTimeEdit':
            model.setData(index, editor.time().toString("HH:mm:ss"))
        elif editor.metaObject().className() == 'QListWidget':
            items = []
            for j in range(editor.count()):
                items.append(editor.item(j))
            model.setData(index, ";".join([i.text() for i in items]))
        #elif (editor.metaObject().className() == 'QLineEdit' and editor.text()==''):
        #    model.setData(model.createIndex(index.row(), 0), None)
        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 3: #3 - sicherheit
                model.setData(index, editor.currentIndex()+1)
            else:
                model.setData(index, editor.currentText())
        else:
            QSqlRelationalDelegate.setModelData(self, editor, model, index)

class InListValidator(QValidator):
        def __init__(self, itemList, editor, depend, parent):
            QValidator.__init__(self, parent)

            self.itemList = itemList
            self.editor = editor
            self.depend = depend

        def validate(self, s, pos):

            if str(s) in self.itemList or str(s).strip()=='':
                if self.depend and str(s).strip()=='':
                    for dep in self.depend:
                        for key, value in dep.iteritems():
                            value.setText("")
                return (QValidator.Acceptable, s, pos)

            return (QValidator.Invalid, "", pos)


        def fixup(self, s):
            #QMessageBox.warning(None, "Test", unicode(s))
            self.editor.setText("")
