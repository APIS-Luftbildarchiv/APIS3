# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import re
import glob

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QPushButton, QFileDialog, QTableWidgetItem
from PyQt5.QtCore import QSettings, QDate, QDir
from PyQt5.QtSql import QSqlQuery

from qgis.core import (QgsVectorDataProvider, QgsFeature, QgsGeometry, QgsCoordinateReferenceSystem, QgsPointXY,
                       QgsFeatureRequest, QgsVectorLayerUtils, QgsDistanceArea)

import exifread

from APIS.src.apis_utils import TransformGeometry, GetMeridianAndEpsgGK, SetWindowSize, GetWindowSize, GetExifForImage

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_image_digital_auto_import.ui'), resource_suffix='')


class APISDigitalImageAutoImport(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, apisLayer, targetLayerCP, targetLayerFP, filmId, parent=None):
        """Constructor."""
        super(APISDigitalImageAutoImport, self).__init__(parent)

        self.setupUi(self)
        if GetWindowSize("image_digital_auto_import"):
            self.resize(GetWindowSize("image_digital_auto_import"))

        self.accepted.connect(self.onClose)
        self.rejected.connect(self.onClose)

        self.iface = iface
        self.dbm = dbm
        self.apisLayer = apisLayer
        self.filmId = filmId
        self.parent = parent
        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        # update UI regarding orientation
        self.updateUiForFilmMode(self.parent.isOblique)


        self.targetLayerCP = targetLayerCP
        self.targetLayerFP = targetLayerFP

        self.sourceLayerCP = None # sourceLayerCP
        self.sourceLayerFP = None # sourceLayerFP
        # self.sourceLayerCP = self.uiCenterPointMLCombo.currentLayer()
        # self.sourceLayerFP = self.uiFootPrintMLCombo.currentLayer()
        self.uiReportPTxt.setCenterOnScroll(True)
        self.writeMsg(u"Auto Import digitaler Bilder für Film: {0}".format(self.filmId))
        self.uiImportBtn.clicked.connect(self.runImport)
        self.uiImportBtn.setEnabled(False)

        self.uiMonoplotSourceGrp.toggled.connect(lambda: self.toggleSourceGroups(friend=self.uiOrientalSourceGrp))
        self.uiOrientalSourceGrp.toggled.connect(lambda: self.toggleSourceGroups(friend=self.uiMonoplotSourceGrp))

        self.uiMonoplotSourceGrp.clicked.connect(self.activateIns2CamMode)
        self.uiOrientalSourceGrp.clicked.connect(self.activateOrientalMode)

        self.importMode = 0 # 0 .. ins2cam, 1 .. oriental, 2 .. vexcel

        self.uiCenterPointFootprintDirTBtn.clicked.connect(self.getSourceDir)
        self.uiOrientalDirTBtn.clicked.connect(self.getSourceDir)

        self.getExistingImages()
        self.autodetectSourcesIns2Cam()

        # self.setupTable()

    def updateUiForFilmMode(self, isOblique):
        self.uiMonoplotSourceGrp.setVisible(isOblique)
        self.uiOrientalSourceGrp.setVisible(isOblique)
        # self.uiImageSourceGrp.setVisible(isOblique)
        self.uiVexcelSourceGrp.setVisible(not isOblique)

    def toggleSourceGroups(self, friend):
        on = self.sender().isChecked()
        friend.setChecked(not on)

    def activateIns2CamMode(self, checked):
       if checked:
           self.importMode = 0
           self.autodetectSourcesIns2Cam(self.uiCenterPointFootprintSourceEdit.text())

    def activateOrientalMode(self, checked):
        if checked:
            self.importMode = 1
            self.autodetectSourcesOriental(self.uiOrientalSourceEdit.text())

    # def setupTable(self):
    #     header = ["bildnummer", "status cp", "status fp"]
    #     c = 0
    #     for h in header:
    #         self.uiImageTable.insertColumn(0)
    #         c += 1
    #     self.uiImageTable.setHorizontalHeaderLabels(header)

    def getExistingImages(self):
        existingImagesCP = QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0]
        existingImagesFP = QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0]
        return existingImagesCP, existingImagesFP
        # existingTotal = list(set(existingImagesCP) | set(existingImagesFP))
        # existingTotal.sort()
        # for image in existingTotal:
        #     self.uiImageTable.insertRow(self.uiImageTable.rowCount())
        #     row = self.uiImageTable.rowCount() - 1
        #     self.uiImageTable.setItem(row, 0, QTableWidgetItem(f"{image}"))
        #     if image in existingFeaturesCP:
        #         self.uiImageTable.setItem(row, 1, QTableWidgetItem("vorhanden"))
        #     else:
        #         self.uiImageTable.setItem(row, 1, QTableWidgetItem("fehlt"))
        #     if image in existingFeaturesFP:
        #         self.uiImageTable.setItem(row, 2, QTableWidgetItem("vorhanden"))
        #     else:
        #         self.uiImageTable.setItem(row, 2, QTableWidgetItem("fehlt"))
        #
        # if existingTotal:
        #     self.writeMsg("Es sind bereits kartierte Bilder vorhanden.")
        # else:
        #     self.writeMsg("Es sind noch keine Bilder kartiert worden.")


    def autodetectSourcesIns2Cam(self, sourceDir=None):
        # sourceLayer
        if sourceDir:
            imageBasePath = ""
            monoplotPath = sourceDir
        else:
            imageBasePath = self.settings.value("APIS/image_dir")
            monoplotPath = self.settings.value("APIS/monoplot_dir")
        epsg = self.settings.value("APIS/monoplot_epsg", type=int)
        sourceCpLayerShp = u"{0}.{1}".format(self.settings.value("APIS/monoplot_cp_shp"), u"shp")
        sourceFpLayerShp = u"{0}.{1}".format(self.settings.value("APIS/monoplot_fp_shp"), u"shp")
        sourceCpLayerPath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath, sourceCpLayerShp))
        sourceFpLayerPath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath, sourceFpLayerShp))

        if os.path.isfile(sourceCpLayerPath) and os.path.isfile(sourceFpLayerPath):
            self.sourceLayerCP = self.apisLayer.requestShapeFile(sourceCpLayerPath, epsg, None, "Bildkartierung", True, True)
            self.sourceLayerFP = self.apisLayer.requestShapeFile(sourceFpLayerPath, epsg, None, "Bildkartierung", True, True)
            self.uiCenterPointFootprintSourceEdit.setText(os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, monoplotPath)))
            self.uiImportBtn.setEnabled(True)
        else:
            self.uiImportBtn.setEnabled(False)
            res = QMessageBox.warning(self, "Daten wurden nicht gefunden.", f"Monoplot/ins2cam/imu Daten wurden nicht im angegebenen Verzeichnis gefunden. Wählen Sie bitte ein Verzeichnis aus, in dem die {sourceCpLayerShp} und {sourceFpLayerShp} Dateien für den Film {self.parent.currentFilmNumber} gespeichert sind.")
            # active open monoplot dir
            if res:
                self.getSourceDir()

    def autodetectSourcesOriental(self, sourceDir=None):
        imageBasePath = self.settings.value("APIS/image_dir")
        orientalPath = self.settings.value("APIS/oriental_dir")
        self.orientalSourcePath = None
        self.orientalTargetPath = None
        if sourceDir:
            self.orientalSourcePath = sourceDir
            self.uiCopyToOrientalDirChk.setEnabled(True)
            self.orientalTargetPath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, orientalPath))
        else:
            self.orientalSourcePath = os.path.normpath(os.path.join(imageBasePath, self.parent.currentFilmNumber, orientalPath))
            self.uiCopyToOrientalDirChk.setEnabled(False)

        if os.path.isdir(self.orientalSourcePath):
            self.uiOrientalSourceEdit.setText(self.orientalSourcePath)

            orientalFileNames = glob.glob(os.path.normpath(self.orientalSourcePath + "\\{0}_[0-9][0-9][0-9].shp".format(self.parent.currentFilmNumber)))
            # QMessageBox.information(None, "info", ",".join(orientalFileNames))
            if orientalFileNames:
                # activate Import Button!
                self.uiImportBtn.setEnabled(True)
            else:
                self.uiImportBtn.setEnabled(False)
                # cannot find ... getSourceDir
                # deactivate
                self.uiCopyToOrientalDirChk.setEnabled(False)
        else:
            self.uiImportBtn.setEnabled(False)
            QMessageBox.warning(self, "", "")


    def getSourceDir(self):
        sourceDirName = QFileDialog.getExistingDirectory(self, u"Ziel Ordner auswählen", self.settings.value("APIS/working_dir"), QFileDialog.DontUseNativeDialog)
        if sourceDirName:
            if self.importMode == 0:
                self.autodetectSourcesIns2Cam(sourceDirName)
            elif self.importMode == 1:
                self.autodetectSourcesOriental(sourceDirName)

        #sourceCpLayer = self.apisLayer.requestShapeFile(sourceCpLayerPath, epsg, None, "Bildkartierung", True, True)
        #sourceFpLayer = self.apisLayer.requestShapeFile(sourceFpLayerPath, epsg, None, "Bildkartierung", True, True)

        # if sources are sufficient, check already mapped and compare to new infomration
        # if not valid sources: prompt to manually define sources with file dialog (on add check if sources are suffieicnet like above)

    def areSourceLayerMonoplot(self):
        if self.sourceLayerCP.featureCount() == 0 or self.sourceLayerFP.featureCount() == 0:
            return False, u"Zumindest einer der Layer hat keine Features (Centerpoint: {0}, Footprint: {1})".format(self.sourceLayerCP.featureCount(), self.sourceLayerFP.featureCount())
        if self.sourceLayerCP.featureCount() != self.sourceLayerFP.featureCount():
            return False, u"Die Feature Anzahl stimmt nicht überein (Centerpoint: {0}, Footprint: {1})".format(self.sourceLayerCP.featureCount(), self.sourceLayerFP.featureCount())

        provCP = self.sourceLayerCP.dataProvider()
        fieldNamesCP = set([field.name() for field in provCP.fields()])
        if "Image" not in fieldNamesCP:
            return False, u"Der Centerpoint Layer hat kein Attribut 'Image'."
        # if "ERROR" not in fieldNamesCP:
        #     return False, u"Der Centerpoint Layer hat kein Attribut 'ERROR'."

        provFP = self.sourceLayerFP.dataProvider()
        fieldNamesFP = set([field.name() for field in provFP.fields()])
        if "Image" not in fieldNamesFP:
            return False, u"Der Footprint Layer hat kein Attribut 'Image'."


        numOfImagesCPSet = set([feature["Image"] for feature in self.sourceLayerCP.getFeatures()])
        numOfImagesFPSet = set([feature["Image"] for feature in self.sourceLayerFP.getFeatures()])

        if numOfImagesCPSet != numOfImagesFPSet:
            return False, u"Die Werte des Attributes 'Image' stimmen zwischen den Layern nicht überein."

        filmNumberCP = set([feature["Image"].split('_')[0] for feature in self.sourceLayerCP.getFeatures()])
        if len(filmNumberCP) != 1:
            return False, u"Im Centerpoint Layer gibt es Bilder von mehr als einem Film ({0}).".format(u', '.join(list(filmNumberCP)))

        filmNumber = list(filmNumberCP)[0]
        if len(filmNumber) == 8:
            #old Id
            mil =u""
            if filmNumber[:2] == u"01":
                mil = u"19"
            elif filmNumber[:2] == u"02":
                mil = u"20"
            else:
                return False, u"Die Filmnummer im Centerpoint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format()
            filmNumber = u"01{0}{1}".format(mil,filmNumber[2:])
        elif len(filmNumber) == 10:
            #new Id
            pass
        else:
            return False, u"Die Filmnummer im Centerpoint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format()

        if filmNumber != self.filmId:
            return False, u"Im Centerpoint Layer sind Bilder eines anderen Films ({0}).".format(list(filmNumberCP)[0])

        filmNumberFP = set([feature["Image"].split('_')[0]for feature in self.sourceLayerFP.getFeatures()])
        if len(filmNumberFP) != 1:
            return False, u"Im Footprint Layer gibt es Bilder von mehr als einem Film ({0}).".format(u', '.join(list(filmNumberFP)))

        filmNumber = list(filmNumberFP)[0]
        if len(filmNumber) == 8:
            #old Id
            mil =u""
            if filmNumber[:2] == u"01":
                mil = u"19"
            elif filmNumber[:2] == u"02":
                mil = u"20"
            else:
                return False, u"Die Filmnummer im Footprint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format()
            filmNumber = u"01{0}{1}".format(mil, filmNumber[2:])
        elif len(filmNumber) == 10:
            #new Id
            pass
        else:
            return False, u"Die Filmnummer im Footprint Layer entspricht weder dem alten (8-stellig) noch dem neuen (10-stellig) Filmnummernschema ({0}).".format()

        if filmNumber != self.filmId:
            return False, u"Im Footprint Layer sind Bilder eines anderen Films ({0}).".format(list(filmNumberFP)[0])


        return True, u"MonoplotLayer"

    def checkIfTargetIsClean(self):
        if self.targetLayerCP.featureCount() != self.targetLayerFP.featureCount():
            return False, u"Die Feature Anzahl bereits kartierter Bilder stimmt nicht überein (Centerpoint: {0}, Footprint: {1})".format(self.targetLayerCP.featureCount(), self.targetLayerFP.featureCount())

        existingFeaturesCP = set(QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0])
        existingFeaturesFP = set(QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0])
        CPwoFP = list(set(existingFeaturesCP) - set(existingFeaturesFP))
        FPwoCP = list(set(existingFeaturesFP) - set(existingFeaturesCP))

        if len(CPwoFP) > 0 or len(FPwoCP) > 0:
            errorMsg = u"Bitte beheben Sie folgende Probleme vor dem Import. Centerpoints ohne Footprints oder umgekehrt"
            if len(CPwoFP) > 0:
                errorMsg += u"\n{0}".format(u", ".join(CPwoFP))
            if len(FPwoCP) > 0:
                errorMsg += u"\n{0}".format(u", ".join(FPwoCP))
            return False, errorMsg

        return True, u"TargetIsClean"

    def getCountryCode(self, p):
        query = QSqlQuery(self.dbm.db)
        #qryStr = "SELECT code FROM osm_boundaries WHERE within(MakePoint({0}, {1}, 4312), Geometry)".format(p.x(),p.y())
        qryStr = "SELECT code FROM osm_boundaries WHERE intersects(Transform(MakePoint({0}, {1}, 4312), 4326), geometry)  AND ROWID IN (SELECT ROWID FROM SpatialIndex WHERE f_table_name = 'osm_boundaries' AND search_frame = Transform(MakePoint({0}, {1}, 4312), 4326))".format(p.x(),p.y())

        query.exec_(qryStr)
        query.first()
        if query.value(0) is None:
            return 'INT'
        else:
            return query.value(0)

    # # TODO remove
    # def _get_if_exist(self, data, key):
    #     return data[key] if key in data else None
    #
    # # TODO remove
    # def _convert_to_degress(self, value):
    #     """
    #     Helper function to convert the GPS coordinates stored in the EXIF to degress in float format
    #     :param value:
    #     :type value: exifread.utils.Ratio
    #     :rtype: float
    #     """
    #     return float(value.values[0].num) / float(value.values[0].den) + (float(value.values[1].num) / float(value.values[1].den) / 60.0) + (float(value.values[2].num) / float(value.values[2].den) / 3600.0)

    # # TODO remove
    # def getExifForImage(self, imageNumber):
    #     exif = [None, None, None, None, None, None]
    #
    #     dirName = self.settings.value("APIS/image_dir")
    #     imageName = imageNumber.replace('.', '_') + '.jpg'
    #     image = os.path.normpath(dirName + '\\' + self.filmId + '\\' + imageName)
    #     if os.path.isfile(image):
    #         with open(image, 'rb') as f:
    #             tags = exifread.process_file(f, details=False)
    #
    #             gps_altitude = self._get_if_exist(tags, 'GPS GPSAltitude')
    #             gps_altitude_ref = self._get_if_exist(tags, 'GPS GPSAltitudeRef')
    #             if gps_altitude and gps_altitude_ref:
    #                 alt = float(gps_altitude.values[0].num / gps_altitude.values[0].den)
    #                 if gps_altitude_ref.values[0] == 1:
    #                     alt *= -1
    #                 exif[0] = alt
    #
    #             gps_longitude = self._get_if_exist(tags, 'GPS GPSLongitude')
    #             gps_longitude_ref = self._get_if_exist(tags, 'GPS GPSLongitudeRef')
    #             if gps_longitude and gps_longitude_ref:
    #                 lon = self._convert_to_degress(gps_longitude)
    #                 if gps_longitude_ref.values[0] != 'E':
    #                     lon = 0 - lon
    #                 exif[1] = lon
    #
    #             gps_latitude = self._get_if_exist(tags, 'GPS GPSLatitude')
    #             gps_latitude_ref = self._get_if_exist(tags, 'GPS GPSLatitudeRef')
    #             if gps_latitude and gps_latitude_ref:
    #                 lat = self._convert_to_degress(gps_latitude)
    #                 if gps_latitude_ref.values[0] != 'N':
    #                     lat = 0 - lat
    #                 exif[2] = lat
    #
    #             exif_exposure_time = self._get_if_exist(tags, 'EXIF ExposureTime')
    #             if exif_exposure_time:
    #                 exif[3] = float(exif_exposure_time.values[0].num / exif_exposure_time.values[0].den)
    #
    #             exif_focal_length = self._get_if_exist(tags, 'EXIF FocalLength')
    #             if exif_focal_length:
    #                 exif[4] = float(exif_focal_length.values[0].num / exif_focal_length.values[0].den)
    #
    #             exif_fnumber = self._get_if_exist(tags, 'EXIF FNumber')
    #             if exif_fnumber:
    #                 exif[5] = float(exif_fnumber.values[0].num / exif_fnumber.values[0].den)
    #
    #     return exif
    #
    # # TODO remove
    # def OLDgetExifForImage(self, imageNumber):
    #     exif = [None, None, None, None, None, None]
    #     dirName = self.settings.value("APIS/image_dir")
    #     imageName = imageNumber.replace('.', '_') + '.jpg'
    #     image = os.path.normpath(dirName+'\\'+self.filmId+'\\'+imageName)
    #
    #     if os.path.isfile(image):
    #         md = exiv.ImageMetadata(image)
    #         md.read()
    #
    #         if "Exif.GPSInfo.GPSAltitude" in md.exif_keys:
    #             exif[0] = float(md["Exif.GPSInfo.GPSAltitude"].value)
    #
    #         if "Exif.GPSInfo.GPSLongitude" in md.exif_keys:
    #             lon = md["Exif.GPSInfo.GPSLongitude"].value
    #             exif[1] = float(lon[0])+((float(lon[1])+(float(lon[2])/60))/60)
    #
    #         if "Exif.GPSInfo.GPSLatitude" in md.exif_keys:
    #             lat = md["Exif.GPSInfo.GPSLatitude"].value
    #             exif[2] = float(lat[0])+((float(lat[1])+(float(lat[2])/60))/60)
    #
    #         if "Exif.Photo.ExposureTime" in md.exif_keys:
    #             exif[3] = float(md["Exif.Photo.ExposureTime"].value)
    #
    #         if "Exif.Photo.FocalLength" in md.exif_keys:
    #             exif[4] = float(md["Exif.Photo.FocalLength"].value)
    #
    #         if "Exif.Photo.FNumber" in md.exif_keys:
    #             exif[5] = md["Exif.Photo.FNumber"].value
    #
    #     return exif

    def writeMsg(self, msg):
        self.uiReportPTxt.insertPlainText(msg)
        self.uiReportPTxt.insertPlainText(u"\n")
        #self.uiReportPTxt.ensureCursorVisible()

    def runImport(self):
        self.uiImportBtn.setEnabled(False)
        res1, msg1 = self.areSourceLayerMonoplot()
        res2, msg2 = self.checkIfTargetIsClean()
        if res1 and res2:

            iterCP = self.sourceLayerCP.getFeatures()
            iterFP = self.sourceLayerFP.getFeatures()
            existingFeaturesCP = QgsVectorLayerUtils.getValues(self.targetLayerCP, "bildnummer")[0]
            existingFeaturesFP = QgsVectorLayerUtils.getValues(self.targetLayerFP, "bildnummer")[0]

            mode = 1 #eintragen
            if self.targetLayerCP.featureCount() > 0 or self.targetLayerFP.featureCount() > 0:

                msgBox = QMessageBox()
                msgBox.setWindowTitle(u'Monoplot Import')
                msgBox.setText(u"Für den Film {0} sind kartierte Bilder vorhanden:".format(self.filmId))
                msgBox.addButton(QPushButton(u'Überschreiben'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Nicht überschreiben'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()
                if ret == 0:
                    mode = 2 #überschreiben
                    self.writeMsg(u"Bereits kartierte Bilder: überschreiben")
                elif ret == 1:
                    mode = 3 #nicht überschreiben/überspringen
                    self.writeMsg(u"Bereits kartierte Bilder: nicht überschreiben")
                else:
                    self.writeMsg(u"Vorgang wurde abgebrochen.")
                    self.uiImportBtn.setEnabled(True)
                    return

            capsCP = self.targetLayerCP.dataProvider().capabilities()
            capsFP = self.targetLayerFP.dataProvider().capabilities()
            if capsCP & QgsVectorDataProvider.AddFeatures and capsFP & QgsVectorDataProvider.AddFeatures:
                featuresCP = []
                featuresFP = []
                imagesToDelete = []
                #for sourceFeat in iterCP:
                sourceFeatCP = QgsFeature()
                sourceFeatFP = QgsFeature()
                i = 0
                while iterCP.nextFeature(sourceFeatCP):
                    i += 1
                    iterFP.nextFeature(sourceFeatFP)
                    sINCP = re.search('^(.+\d)_([0-9][0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9]\.tif|[0-9][0-9][0-9])$', sourceFeatCP["Image"])
                    sINFP = re.search('^(.+\d)_([0-9][0-9][0-9][0-9][0-9]\.tif|[0-9][0-9][0-9]\.tif|[0-9][0-9][0-9])$', sourceFeatCP["Image"])
                    if sINCP and sINFP:
                        if sINCP.group(0) == sINFP.group(0):
                            imageNumber = int(sINCP.group(0).split('_')[1].split('.')[0])
                            imageNumberFP = int(sINFP.group(0).split('_')[1].split('.')[0])
                        else:
                            self.writeMsg(u"SKIP: Die fortlaufende Bildnummer in Reihe {0} stimmen im Centerpoint ({1}) und Footprint ({2}) Layer nicht überein.".format(i, imageNumber, imageNumberFP))
                            continue
                    else:
                        self.writeMsg(u"SKIP: Die Eintrag in Reihe {0} hat keine entsprechende Bildnummer (Filmnummer + fortlaufende Bildnummer)".format(i))
                        continue

                    bn = '{0}.{1:03d}'.format(self.filmId, imageNumber)

                    # errorCP = int(sourceFeatCP["ERROR"])
                    # errorFP = int(sourceFeatFP["ERROR"])
                    # if errorCP > 0 or errorFP > 0:
                    #     self.writeMsg(u"SKIP: {0}: Zumindest in einem Layer ist der ERROR Wert > 0 (CP: {1}, FP: {2})".format(bn, errorCP, errorFP))
                    #     continue

                    if bn in existingFeaturesCP or bn in existingFeaturesFP:
                        if mode == 2:
                            # überschreiben
                            #QMessageBox.warning(None, u"Bild Nummern", u"Ein Bild mit der Nummer {0} wurde bereits kartiert".format(imageNumber))
                            self.writeMsg(u"UPDATE: {0}: wird überschrieben.".format(bn))
                            imagesToDelete.append(bn)

                        elif mode == 3:
                            # nicht überschreiben
                            self.writeMsg(u"SKIP: {0}: wurde bereits kartiert.".format(bn))
                            continue
                    else:
                        self.writeMsg(u"NEW: {0}: wird erstellt.".format(bn))

                    # CENTERPOINT

                    targetFeatCP = QgsFeature(self.targetLayerCP.fields())
                    targetGeometryCP = TransformGeometry(QgsGeometry(sourceFeatCP.geometry()), self.sourceLayerCP.crs(), self.targetLayerCP.crs())
                    targetFeatCP.setGeometry(targetGeometryCP)

                    # From Film Table
                    # filmFields = ["form1", "form2", "weise", "kammerkonstante"]
                    targetFeatCP.setAttribute('filmnummer_hh_jjjj_mm', self.parent.currentFilmInfoDict["filmnummer_hh_jjjj_mm"])
                    targetFeatCP.setAttribute('filmnummer_nn', self.parent.currentFilmInfoDict["filmnummer_nn"])
                    targetFeatCP.setAttribute('filmnummer', self.parent.currentFilmNumber)

                    targetFeatCP.setAttribute('bildnummer_nn', imageNumber)
                    targetFeatCP.setAttribute('bildnummer', bn)

                    # Date TODAY
                    now = QDate.currentDate()
                    targetFeatCP.setAttribute('datum_ersteintrag', now.toString("yyyy-MM-dd"))
                    targetFeatCP.setAttribute('datum_aenderung', now.toString("yyyy-MM-dd"))

                    targetFeatCP.setAttribute('copyright', self.parent.currentFilmInfoDict["copyright"])
                    targetFeatCP.setAttribute('etikett', 0)  # By Default Fix Value of 0

                    # Calculated/Derived
                    cp = targetFeatCP.geometry().asPoint()
                    targetFeatCP.setAttribute('longitude', cp.x())
                    targetFeatCP.setAttribute('latitude', cp.y())

                    countryCode = self.getCountryCode(cp)
                    targetFeatCP.setAttribute('land', countryCode)

                    if countryCode == 'AUT':
                        # get meridian and epsg Code
                        meridian, epsgGK = GetMeridianAndEpsgGK(cp.x())

                        # get KG Coordinates
                        gk = TransformGeometry(QgsGeometry(targetFeatCP.geometry()), self.targetLayerCP.crs(), QgsCoordinateReferenceSystem(epsgGK, QgsCoordinateReferenceSystem.EpsgCrsId))
                        gkx = gk.asPoint().y()  # Hochwert
                        gky = gk.asPoint().x()  # Rechtswert
                    else:
                        meridian = None
                        gkx = None
                        gky = None

                    targetFeatCP.setAttribute('meridian', meridian)
                    targetFeatCP.setAttribute('gkx', gkx)  # Hochwert
                    targetFeatCP.setAttribute('gky', gky)  # Rechtswert

                    image = os.path.normpath(self.settings.value("APIS/image_dir") + '\\' + self.filmId + '\\' + bn.replace('.', '_') + '.jpg')
                    exif = GetExifForImage(image, altitude=True, longitude=True, latitude=True, exposure_time=True, focal_length=True, fnumber=True)

                    targetFeatCP.setAttribute('hoehe', exif["altitude"] if exif["altitude"] else 450)  # TODO: Is this the best way to set hight to 0 if no image is there? 436 is the average hight of all oblique images
                    targetFeatCP.setAttribute('gps_longitude', exif["longitude"] if exif["longitude"] is not None else None)
                    targetFeatCP.setAttribute('gps_latitude', exif["latitude"] if exif["latitude"] is not None else None)
                    targetFeatCP.setAttribute('kappa', QgsPointXY(exif["longitude"], exif["latitude"]).azimuth(cp) if exif["longitude"] and exif["latitude"] else None)
                    targetFeatCP.setAttribute('belichtungszeit', exif["exposure_time"] if exif["exposure_time"] is not None else None)
                    targetFeatCP.setAttribute('fokus', exif["focal_length"] if exif["focal_length"] is not None else None)  # FocalLength
                    targetFeatCP.setAttribute('blende', exif["focal_length"]/exif["fnumber"] if exif["focal_length"] and exif["fnumber"] else None) # effecitve aperture (diameter of entrance pupil) = focalLength / fNumber

                    # FOOTPRINT
                    targetFeatFP = QgsFeature(self.targetLayerFP.fields())

                    #self.writeMsg('source FP: ' + sourceFeatFP.geometry().asWkt())
                    sourceGeometryFP = QgsGeometry(sourceFeatFP.geometry())
                    if sourceGeometryFP.isMultipart():
                        sourceGeometryFP.convertToSingleType()

                    pointCP = sourceFeatCP.geometry()
                    polyline = sourceGeometryFP.asPolygon()[0]
                    points = [QgsGeometry.fromPointXY(point) for point in polyline[:-1]]
                    # self.writeMsg(pointCP.asWkt() + '||' + ', '.join(p.asWkt() for p in points))
                    dists = [point.distance(pointCP) for point in points]
                    r = int((sorted(dists)[0] + sorted(dists)[1]) / 2.0)
                    targetFeatCP.setAttribute('radius', r if r > 175 else 175)

                    targetGeometryFP = TransformGeometry(sourceGeometryFP, self.sourceLayerFP.crs(), self.targetLayerFP.crs())
                    targetFeatFP.setGeometry(targetGeometryFP)

                    targetFeatFP.setAttribute('filmnummer', self.parent.currentFilmNumber)
                    targetFeatFP.setAttribute('bildnummer', bn)
                    da = QgsDistanceArea()
                    da.setEllipsoid(self.targetLayerFP.crs().ellipsoidAcronym())
                    targetFeatFP.setAttribute('shape_length', da.measurePerimeter(targetGeometryFP))
                    targetFeatFP.setAttribute('shape_area', da.measureArea(targetGeometryFP))
                    targetFeatFP.setAttribute('source', 'imu')

                    featuresCP.append(targetFeatCP)
                    featuresFP.append(targetFeatFP)

                if imagesToDelete:
                    request = QgsFeatureRequest().setFilterExpression(u'"bildnummer" IN ({0})'.format(u', '.join(u'\'{0}\''.format(img) for img in imagesToDelete)))
                    featureIdsCPToDelete = []
                    featureIdsFPToDelete = []

                    for f in self.targetLayerCP.getFeatures(request):
                        featureIdsCPToDelete.append(f.id())

                    for f in self.targetLayerFP.getFeatures(request):
                        featureIdsFPToDelete.append(f.id())

                    res = self.targetLayerCP.dataProvider().deleteFeatures(featureIdsCPToDelete)
                    res = self.targetLayerFP.dataProvider().deleteFeatures(featureIdsFPToDelete)

                if featuresCP:
                    (res, outFeats) = self.targetLayerCP.dataProvider().addFeatures(featuresCP)
                    self.targetLayerCP.updateExtents()

                if featuresFP:
                    (res, outFeats) = self.targetLayerFP.dataProvider().addFeatures(featuresFP)
                    self.targetLayerFP.updateExtents()

                if self.iface.mapCanvas().isCachingEnabled():
                    self.targetLayerCP.triggerRepaint()
                    self.targetLayerFP.triggerRepaint()
                else:
                    self.iface.mapCanvas().refresh()

            else:
                QMessageBox.warning(None, u"Layer Capabilities!" u"Probleme mit Layer Capabilities!")

        else:
            if not res1:
                QMessageBox.warning(None, "MonoplotImport", u"Die Ausgewählten Centerpoint und Footprint Layer sind für den MONOPLOT Import ungeeignet:\n{0}".format(msg1))

            if not res2:
                QMessageBox.warning(None, "MonoplotImport", u"Es sind Probleme bei bereits kartierten Bildern vorhanden:\n{0}".format(msg2))

    def onClose(self):
        SetWindowSize("image_digital_auto_import", self.size())