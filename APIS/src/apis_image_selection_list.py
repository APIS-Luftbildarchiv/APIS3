# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import glob

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QAbstractItemView, QHeaderView, QPushButton, QFileDialog, QProgressDialog, QMenu
from PyQt5.QtCore import QSettings, Qt, QFileInfo, QDateTime, QDir, QFile, QVariant, QDate
from PyQt5.QtGui import QDoubleValidator, QStandardItemModel, QStandardItem, QColor, QFont, QIcon
from PyQt5.QtSql import QSqlQuery

from qgis.core import (QgsRasterLayer, QgsProject, QgsVectorFileWriter,
                       QgsFields, QgsField, QgsFeature, QgsGeometry,
                       QgsCoordinateReferenceSystem, QgsWkbTypes)

from APIS.src.apis_utils import OpenFileOrFolder, VersionToCome, SetExportPath, GetExportPath
from APIS.src.apis_thumb_viewer import QdContactSheet
from APIS.src.apis_printer import APISPrinterQueue, APISListPrinter, APISLabelPrinter, OutputMode
from APIS.src.apis_printing_options import APISPrintingOptions
from APIS.src.apis_image2xmp import Image2Xmp

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_image_selection_list.ui'), resource_suffix='')


class APISImageSelectionList(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, imageRegistry, parent=None):
        """Constructor."""
        super(APISImageSelectionList, self).__init__(parent)
        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.setupUi(self)

        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        mImage = QMenu()
        aImageThumbs= mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Vorschau")
        aImageThumbs.triggered.connect(self.viewAsThumbs)
        aImageCopy = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Kopieren")
        aImageCopy.triggered.connect(self.copyImages)
        aImageExif = mImage.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'exif_export.png')), "EXIF Export")
        aImageExif.triggered.connect(self.image2Xmp)
        #aImageExif.triggered.connect(lambda: VersionToCome("3.0.1"))
        self.uiImageTBtn.setMenu(mImage)
        self.uiImageTBtn.clicked.connect(self.uiImageTBtn.showMenu)

        mLayer = QMenu()
        mLayer.addSection("In QGIS laden")
        aLayerLoadOrtho = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Orthofotos")
        aLayerLoadOrtho.triggered.connect(self.loadOrthos)
        mLayer.addSection("SHP Export")
        aLayerExportFootprints = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "ExportFootprints")
        aLayerExportFootprints.triggered.connect(self.exportFootprints)
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportImageList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Bildliste")
        aPdfExportImageList.triggered.connect(self.exportListAsPdf)
        aPdfExportLabels = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Etiketten")
        aPdfExportLabels.triggered.connect(self.exportLabelsAsPdf)
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)



        self.accepted.connect(self.onAccepted)

        self.uiImageListTableV.doubleClicked.connect(self.viewImage)
        self.uiResetSelectionBtn.clicked.connect(self.uiImageListTableV.clearSelection)


        self.uiFilterGrp.toggled.connect(self.applyFilter)
        self.uiFilterVerticalChk.stateChanged.connect(self.applyFilter)
        self.uiFilterObliqueChk.stateChanged.connect(self.applyFilter)
        self.uiFilterScanChk.stateChanged.connect(self.applyFilter)
        self.uiFilterHiResChk.stateChanged.connect(self.applyFilter)
        self.uiFilterOrthoChk.stateChanged.connect(self.applyFilter)
        self.uiFilterScaleEdit.setValidator(QDoubleValidator())
        self.uiFilterScaleEdit.textEdited.connect(self.applyFilter)
        self.uiFilterScaleOperatorCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterFilmKindChk.stateChanged.connect(self.applyFilter)
        self.uiFilterFilmKindCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterScanCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterHiResCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterOrthoCombo.currentIndexChanged.connect(self.applyFilter)
        self.uiFilterFromChk.stateChanged.connect(self.applyFilter)
        self.uiFilterToChk.stateChanged.connect(self.applyFilter)

        self.printingOptionsDlg = None

    def loadImageListBySqlQuery(self, query=None):
        self.model = QStandardItemModel()

        # iterate over query result
        while query.next():
            newRow = []
            rec = query.record()
            for col in range(rec.count()):
                newCol = QStandardItem(str(rec.value(col)))
                newRow.append(newCol)

            #scan
            imageNumber = rec.value("bildnummer")
            if self.imageRegistry.hasImage(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            #ortho
            if self.imageRegistry.hasOrtho(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            #hires
            if self.imageRegistry.hasHiRes(imageNumber):
                newRow.append(QStandardItem("ja"))
            else:
                newRow.append(QStandardItem("nein"))

            self.model.appendRow(newRow)

        if self.model.rowCount() < 1:
            QMessageBox.warning(None, "Bild Auswahl", u"Es wurden keine kartierten Bilder gefunden!")
            return False

        for col in range(rec.count()):
            self.model.setHeaderData(col, Qt.Horizontal, rec.fieldName(col))

        self.model.setHeaderData(self.model.columnCount()-3, Qt.Horizontal, "scan")
        self.model.setHeaderData(self.model.columnCount()-2, Qt.Horizontal, "ortho")
        self.model.setHeaderData(self.model.columnCount()-1, Qt.Horizontal, "hires")

        self.uiImageCountLbl.setText("{0}".format(self.model.rowCount()))
        self.uiScanCountLbl.setText("{0}".format(self.conditionalRowCount(5, "ja")))
        self.uiOrthoCountLbl.setText("{0}".format(self.conditionalRowCount(6, "ja")))
        self.uiHiResCountLbl.setText("{0}".format(self.conditionalRowCount(7, "ja")))

        self.setupTable()
        self.setupFilter()
        self.applyFilter()

        return True

    def conditionalRowCount(self, section, value):
        count = 0
        for row in range(self.model.rowCount()):
           if self.model.item(row, section).text() == value:
               count += 1
        return count

    def setupTable(self):
        self.uiImageListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiImageListTableV.setModel(self.model)
        self.uiImageListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)

        self.uiImageListTableV.resizeColumnsToContents()
        self.uiImageListTableV.resizeRowsToContents()
        self.uiImageListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        self.uiImageListTableV.selectionModel().selectionChanged.connect(self.onSelectionChanged)

    def setupFilter(self):
        self.uiFilterGrp.setChecked(False)
        self.uiFilterFilmKindChk.setCheckState(Qt.Unchecked)
        self.uiFilterVerticalChk.setCheckState(Qt.Checked)
        self.uiFilterObliqueChk.setCheckState(Qt.Checked)
        self.uiFilterScaleEdit.clear()
        self.uiFilterScaleOperatorCombo.setCurrentIndex(0)
        self.uiFilterFilmKindCombo.clear()

        self.uiFilterScanChk.setCheckState(Qt.Unchecked)
        self.uiFilterHiResChk.setCheckState(Qt.Unchecked)
        self.uiFilterOrthoChk.setCheckState(Qt.Unchecked)
        self.uiFilterScanCombo.setCurrentIndex(0)
        self.uiFilterHiResCombo.setCurrentIndex(0)
        self.uiFilterOrthoCombo.setCurrentIndex(0)

        self.uiFilterFromChk.setCheckState(Qt.Unchecked)
        self.uiFilterToChk.setCheckState(Qt.Unchecked)

        minDate, maxDate = self.getMinMaxDate()
        # QMessageBox.information(None, "MinMax", "{0}, {1}".format(minDate.toString("MM.yyyy"), maxDate.toString("MM.yyyy")))

        self.uiFilterFromDate.setMinimumDate(minDate)
        self.uiFilterFromDate.setMaximumDate(maxDate)
        self.uiFilterFromDate.setDate(minDate)

        self.uiFilterToDate.setMinimumDate(minDate)
        self.uiFilterToDate.setMaximumDate(maxDate)
        self.uiFilterToDate.setDate(maxDate)

        self.uiFilterFromDate.dateChanged.connect(self.updateToDate)
        self.uiFilterToDate.dateChanged.connect(self.updateFromDate)

        filmKinds = []
        for row in range(self.model.rowCount()):
            filmKinds.append(self.model.item(row, 4).text())

        for filmKind in set(filmKinds):
            self.uiFilterFilmKindCombo.addItem(filmKind)
        self.uiFilterFilmKindCombo.setCurrentIndex(0)

    def updateToDate(self, date):
        self.uiFilterToDate.setMinimumDate(date)
        self.applyFilter()

    def updateFromDate(self, date):
        self.uiFilterFromDate.setMaximumDate(date)
        self.applyFilter()

    def getImageList(self, getAll=False, filterSection=None, filterValue=None):
        imageList = []
        if self.uiImageListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiImageListTableV.selectionModel().selectedRows()
            for row in rows:
                #get imagenummer
                if not self.uiImageListTableV.isRowHidden(row.row()):
                    if filterSection and filterValue:
                        if self.model.item(row.row(), filterSection).text() == filterValue:
                            imageList.append(self.model.item(row.row(), 0).text())
                    else:
                        imageList.append(self.model.item(row.row(), 0).text())
                    #imageList.append(self.model.record(row.row()).value("bildnummer"))#(self.model.createIndex(row.row(), self.model.fieldIndex("filmnummer"))))
        else:
            for row in range(self.model.rowCount()):
                if not self.uiImageListTableV.isRowHidden(row):
                    if filterSection and filterValue:
                        if self.model.item(row, filterSection).text() == filterValue:
                            imageList.append(self.model.item(row, 0).text())
                    else:
                        imageList.append(self.model.item(row, 0).text())
                   #imageList.append(self.model.record(row).value("bildnummer"))#(self.model.createIndex(row, self.model.fieldIndex("filmnummer"))))

        return imageList

    def getImageListWithRows(self, getAll=False, filterSection=None, filterValue=None):
        imageList = []
        if self.uiImageListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiImageListTableV.selectionModel().selectedRows()
            for row in rows:
                #get imagenummer
                if not self.uiImageListTableV.isRowHidden(row.row()):
                    rowContent = []
                    if filterSection and filterValue:
                        if self.model.item(row.row(), filterSection).text() == filterValue:
                            for col in range(self.model.columnCount()):
                                rowContent.append(self.model.item(row.row(), col).text())
                            imageList.append(rowContent)
                    else:
                        for col in range(self.model.columnCount()):
                            rowContent.append(self.model.item(row.row(), col).text())
                        imageList.append(rowContent)
        else:
            for row in range(self.model.rowCount()):
                if not self.uiImageListTableV.isRowHidden(row):
                    rowContent = []
                    if filterSection and filterValue:
                        if self.model.item(row, filterSection).text() == filterValue:
                            for col in range(self.model.columnCount()):
                                rowContent.append(self.model.item(row, col).text())
                            imageList.append(rowContent)
                    else:
                        for col in range(self.model.columnCount()):
                            rowContent.append(self.model.item(row, col).text())
                        imageList.append(rowContent)
        return imageList

    def viewImage(self):
        r = self.uiImageListTableV.currentIndex().row()
        imageDir = self.settings.value("APIS/image_dir")
        #TODO RM fileName = imageDir + "\\{0}\\{1}.jpg".format(IdToIdLegacy(self.model.item(r, 1).text()), IdToIdLegacy(self.model.item(r, 0).text()).replace('.','_'))
        fileName = imageDir + "\\{0}\\{1}.jpg".format(self.model.item(r, 1).text(), self.model.item(r, 0).text().replace('.','_'))
        if os.path.isfile(os.path.normpath(fileName)):
            OpenFileOrFolder(fileName)
        else:
            QMessageBox.warning(None, "Bild", u"Bild unter {0} nicht vorhanden".format(fileName))
        #get Path to Image
        #open with standard

        # QMessageBox.warning(None, "FilmNumber", "Double")
        #filmIdx = self.model.createIndex(self.uiFilmListTableV.currentIndex().row(), self.model.fieldIndex("filmnummer"))
        #self.filmNumberToLoad = self.model.data(filmIdx)
        #self.accept()
        #QMessageBox.warning(None, "FilmNumber", unicode(self.model.data(filmIdx)))

    def viewAsThumbs(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Vorschau der Bilder')
            msgBox.setText(u'Wollen Sie die Vorschau der ausgewählten Bilder oder der gesamten Liste öffnen?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                imageList = self.getImageList(False, 5, "ja")
            elif ret == 1:
                imageList = self.getImageList(True, 5, "ja")
            else:
                return
        else:
            imageList = self.getImageList(True, 5, "ja")

        if len(imageList) == 0:
            QMessageBox.warning(None, "Bildvorschau", u"Es sind keine Bilder vorhanden!")
            return

        #imageString = ""
        #for image in imageList:
        #    imageString += "'" + image + "',"
        # use: imageString[:-1]
        #QMessageBox.warning(None, "BildNumber", "{0}".format(imageString))

        imagePathList = []
        imageList.sort()
        imageDir = self.settings.value("APIS/image_dir")

        for image in imageList:
            imagePathList.append(os.path.normpath(imageDir + "\\{0}\\{1}.jpg".format(image.split('.')[0], image.replace('.','_'))))

        #QMessageBox.warning(None, "BildNumber", "{0}".format(', '.join(imagePathList)))
        #app = QtGui.QApplication([])
        widget = QdContactSheet()
        widget.load(imagePathList)
        widget.setWindowTitle("Apis Thumb Viewer")
        widget.setModal(True)
        widget.resize(1000, 600)
        widget.show()
        if widget.exec_():
            pass

    def loadOrthos(self):
        orthoList = self.getImageList(False, 6, "ja")

        orthoPathList = []
        orthoList.sort()
        orthoDir = self.settings.value("APIS/ortho_image_dir")

        for ortho in orthoList:
            orthoFileNames = glob.glob(os.path.normpath(orthoDir + "\\{0}\\{1}_op*.*".format(ortho.split('.')[0], ortho.replace('.','_'))))
            for orthoFile in orthoFileNames:
                if os.path.splitext(orthoFile)[1] in ['.sid', '.tif', '.tiff', '.jpg']:
                    fileInfo = QFileInfo(orthoFile)
                    baseName = fileInfo.baseName()
                    rlayer = QgsRasterLayer(orthoFile, baseName)
                    if not rlayer.isValid():
                        QMessageBox.warning(None, "Ortho", "{0}".format(os.path.splitext(orthoFile)[1]))
                    else:
                        QgsProject.instance().addMapLayer(rlayer)
                    #QMessageBox.warning(None, "Ortho", "{0}".format(os.path.splitext(orthoFile)[1]))
                #if os.path.basename(orthoFile)
                #orthoPathList.append()

    def exportFootprints(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Footprints Exportieren')
            msgBox.setText(u'Wollen Sie die Footprints der ausgewählten Bilder oder der gesamten Liste exportieren?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        imageString = ""
        for image in imageList:
            imageString += "'" + image + "',"
        # use: imageString[:-1]
        #QMessageBox.warning(None, "BildNumber", "{0}".format(imageString))

        query = QSqlQuery(self.dbm.db)
        qryStr = "select filmnummer, bildnummer, AsWKT(geometry) as fpGeom, Area(geometry) as area from luftbild_senk_fp where bildnummer in ({0}) union all select filmnummer, bildnummer, AsWKT(geometry) as fpGeom, Area(geometry) as area from luftbild_schraeg_fp where bildnummer in ({0}) order by bildnummer".format(imageString[:-1])
        query.exec_(qryStr)


        # Save Dialog
        now = QDateTime.currentDateTime()
        saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
        layer = QFileDialog.getSaveFileName(self, 'Footprint Export Speichern', saveDir + "\\" + 'Footprints_{0}'.format(now.toString("yyyyMMdd_hhmmss")), '*.shp')[0]
        if layer:
            #layer = "C:\\apis\\export_footprints.shp"
            check = QFile(layer)
            if check.exists():
                if not QgsVectorFileWriter.deleteShapeFile(layer):
                    QMessageBox.warning(None, "Footprint Export", u"Es ist nicht möglich die SHP Datei {0} zu überschreiben!".format(layer))
                    return
                    #raise Exception

            #fields
            fields = QgsFields()
            fields.append(QgsField("bildnummer", QVariant.String))
            fields.append(QgsField("filmnummer", QVariant.String))
            fields.append(QgsField("area", QVariant.Double))

            writer = QgsVectorFileWriter(layer, "UTF-8", fields, QgsWkbTypes.Polygon, QgsCoordinateReferenceSystem(4312, QgsCoordinateReferenceSystem.EpsgCrsId), "ESRI Shapefile")

            for feature in self.iter_features(query):
                writer.addFeature(feature)
            del writer

            #load to canvas
            self.iface.addVectorLayer(layer, "", 'ogr')

            #open folder in file browser
            OpenFileOrFolder(os.path.split(layer)[0])

            #vlayer = QgsVectorLayer("multipolygon?crs=EPSG:4326", "export_footprints", "memory")
            # vlayer.setCrs(self.pointLayer.crs())
            #provider = vlayer.dataProvider()
            #vlayer use crs of pointLayer

            #fields = QgsFields()
            #fields.append(QgsField("area", QVariant.Double))
            #vlayer.addAttribute(QgsField("area", QVariant.Double))


            #vlayer.updateFields()

            #for feature in self.iter_features():
                #provider.addFeatures([feature])

            #while query.next():
                #rec = query.record()
                #feature = QgsFeature()
                #feature.setFields(fields)
                #feature.setGeometry(QgsGeometry.fromWkt(rec.value(rec.indexOf("mp"))))
                #feature.setAttribute("area",rec.value(rec.indexOf("area")))
               # vlayer.addFeature(feature)
                #geom.fromPolygon()
                #QMessageBox.warning(None, "BildNumber", "{0}".format(geom.asWkt()))

            #vlayer.updateExtents()
            #QgsMapLayerRegistry.instance().addMapLayer(vlayer)

    def iter_features(self, query):
        """Iterate over the features of the input layer.

        Yields pairs of the form (QgsPoint, attributeMap).
        Each time a vertice is read hook is called.

        """

        while query.next():
            rec = query.record()
            attributes = [rec.value(rec.indexOf("bildnummer")), rec.value(rec.indexOf("filmnummer")), str(rec.value(rec.indexOf("weise"))), rec.value(rec.indexOf("area"))]
            feature = QgsFeature()
            feature.setGeometry(QgsGeometry.fromWkt(rec.value(rec.indexOf("fpGeom"))))
            feature.setAttributes(attributes)
            yield feature

    def copyImages(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Bilder Kopieren')
            msgBox.setText(u'Wollen Sie die ausgewählten Bilder oder die gesamte Liste kopieren?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                imageList = self.getImageList(False, 5, "ja")
                hiResImageList = self.getImageList(False, 7, "ja")
            elif ret == 1:
                imageList = self.getImageList(True, 5, "ja")
                hiResImageList = self.getImageList(True, 7, "ja")
            else:
                return
        else:
            imageList = self.getImageList(True, 5, "ja")
            hiResImageList = self.getImageList(True, 7, "ja")

        if len(imageList) == 0:
            QMessageBox.warning(None, "Bilder kopieren", u"Es sind keine Bilder vorhanden!")
            return

        selectedDirName = QFileDialog.getExistingDirectory(None, u"Ziel Ordner auswählen", GetExportPath())

        if selectedDirName:
            SetExportPath(os.path.dirname(os.path.abspath(selectedDirName)))
            loRes = True
            hiRes = False
            if len(hiResImageList) > 0:
                #ask if normal, hires, oder beides?
                msgBox = QMessageBox()
                msgBox.setWindowTitle(u'Bilder Kopieren')
                msgBox.setText(u'Neben Bildern mit normaler Auflösung stehen Bilder mit hoher Auflösung zur Verfügung. Welche wollen Sie kopieren?')
                msgBox.addButton(QPushButton(u'Normale Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Hohe Auflösung'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Alle Auflösungen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
                ret = msgBox.exec_()

                if ret == 0:
                    loRes = True
                    hiRes = False
                elif ret == 1:
                    loRes = False
                    hiRes = True
                elif ret == 2:
                    loRes = True
                    hiRes = True
                else:
                    return

            destinationDir = QDir(selectedDirName)
            now = QDateTime.currentDateTime()
            newDirName = "apis_bild_export_{0}".format(now.toString("yyyyMMdd_hhmmss"))
            if destinationDir.mkdir(newDirName):
                destinationDirName = selectedDirName + '\\' + newDirName
                destinationDir = QDir(destinationDirName)
                #QMessageBox.warning(None, "Bilder kopieren", u"ZielVZ: {0}".format(destinationDirName))
                imageDir = self.settings.value("APIS/image_dir")
                for image in imageList:
                    if loRes or hiRes:
                        filmDirName = image.split('.')[0]
                        if not destinationDir.exists(filmDirName):
                            destinationDir.mkdir(filmDirName)

                        if loRes:
                            sourceFileName = os.path.normpath(imageDir + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.','_')))
                            destinationFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}.jpg".format(filmDirName, image.replace('.','_')))
                            #MessageBox.warning(None, "Bilder kopieren", u"SourceVZ: {0}, DestVZ: {1}".format(sourceFileName, destinationFileName))
                            sourceFile = QFile(sourceFileName)
                            sourceFile.copy(destinationFileName)

                        #HiRes Kopieren
                        #QMessageBox.warning(None, "Bilder kopieren", u"{0}, {1}".format(hiRes, ', '.join(hiResImageList)))
                        if hiRes and image in hiResImageList:
                            #copy hi res image files
                            filmDirPathName = imageDir + "\\" + filmDirName
                            filmDir = QDir(filmDirPathName)
                            hiResDirs = filmDir.entryList(["highres*", "mrsid", "raw"], QDir.Dirs)
                            if len(hiResDirs) > 0:
                                for hiResDirName in hiResDirs:
                                    filmDestDirName = destinationDirName + "\\" + filmDirName
                                    filmDestDir = QDir(filmDestDirName)
                                    if not filmDestDir.exists(hiResDirName):
                                        filmDestDir.mkdir(hiResDirName)
                                    hiResDir = QDir(filmDirPathName + "\\" + hiResDirName)
                                    hiResFiles = hiResDir.entryList([image.replace('.','_')+"*"], QDir.Files)
                                    if len(hiResFiles) > 0:
                                        for hiResFile in hiResFiles:
                                            sourceHiResFileName = os.path.normpath("{0}\\{1}\\{2}".format(filmDirPathName, hiResDirName, hiResFile))
                                            destinationHiResFileName = os.path.normpath(destinationDirName + "\\{0}\\{1}\\{2}".format(filmDirName, hiResDirName, hiResFile))
                                            #QMessageBox.warning(None, "Bilder kopieren", u"SourceVZ: {0}, DestVZ: {1}".format(sourceHiResFileName, destinationHiResFileName))
                                            sourceHiResFile = QFile(sourceHiResFileName)
                                            sourceHiResFile.copy(destinationHiResFileName)
                                        #QMessageBox.warning(None, "Bild", u"{0}".format(', '.join(hiResFiles)))

                OpenFileOrFolder(destinationDirName)

            else:
                QMessageBox.warning(None, "Bilder kopieren", u"Das Ziel Verzeichnis {0} konnte in {1} nicht erstellt werden".format(newDirName, selectedDirName))

    def image2Xmp(self):

        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage Footprints der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Schreibe EXIF/IPTC')
            msgBox.setText(u'Wollen Sie die Metadaten der ausgewählten Bilder oder der gesamten Liste exportieren?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return
        else:
            imageList = self.getImageList(True)

        imageString = "'" + "','".join(imageList) + "'"

        query = QSqlQuery(self.dbm.db)
        qryStr = u"SELECT * FROM (SELECT bildnummer, hoehe, longitude, latitude,  (SELECT group_concat(fundortnummer, ';' ) FROM fundort, luftbild_senk_fp WHERE luftbild_senk_fp.bildnummer = lb.bildnummer AND Intersects(fundort.geometry, luftbild_senk_fp.geometry) AND fundort.rowid IN (SELECT rowid FROM spatialindex WHERE f_table_name='fundort' AND search_frame=luftbild_senk_fp.geometry) ORDER BY fundortnummer_nn) AS fundorte, NULL AS keyword, NULL AS description, lb.projekt, lb.copyright, land, militaernummer, militaernummer_alt, archiv, kamera, kalibrierungsnummer, kammerkonstante, fokus, fotograf, flugdatum, flugzeug FROM luftbild_senk_cp AS lb, film AS f WHERE lb.filmnummer = f.filmnummer AND lb.bildnummer IN ({0}) UNION ALL SELECT bildnummer, hoehe, longitude, latitude, (SELECT group_concat(fundortnummer, ';' ) FROM fundort, luftbild_schraeg_fp WHERE luftbild_schraeg_fp.bildnummer = lb.bildnummer AND Intersects(fundort.geometry, luftbild_schraeg_fp.geometry) AND fundort.rowid IN (SELECT rowid FROM spatialindex WHERE f_table_name='fundort' AND search_frame=luftbild_schraeg_fp.geometry) ORDER BY fundortnummer_nn) as fundorte, keyword, description, lb.projekt, lb.copyright, land, militaernummer, militaernummer_alt, archiv, kamera, kalibrierungsnummer, kammerkonstante, fokus, fotograf, flugdatum, flugzeug FROM luftbild_schraeg_cp AS lb, film AS f WHERE lb.filmnummer = f.filmnummer AND lb.bildnummer IN ({0})) ORDER BY bildnummer".format(imageString)
        query.prepare(qryStr)
        query.exec_()

        imageDir = self.settings.value("APIS/image_dir")

        query.seek(-1)
        count = 0
        while query.next():
            count += 1

        progressDlg = QProgressDialog("XMP Metadaten werden geschrieben...", "Abbrechen", 0, count, self)
        progressDlg.setWindowModality(Qt.WindowModal)
        progressDlg.show()
        query.seek(-1)
        counting = 0
        while query.next():
            progressDlg.setValue(counting)
            if progressDlg.wasCanceled():
                break

            rec = query.record()
            metadataDict = {}
            for i in range(rec.count()):
                val = u"{0}".format(rec.value(i))
                if val.replace(" ", "") == '' or val == 'NULL':
                    val = u"---"
                metadataDict["APIS_" + rec.fieldName(i)] = val

            if self.imageRegistry.hasImage(metadataDict["APIS_bildnummer"]):
                imagePath = imageDir + "\\" + metadataDict["APIS_bildnummer"][:10] + "\\" + metadataDict["APIS_bildnummer"].replace('.','_') + ".jpg"
                if os.path.isfile(imagePath):
                    #QMessageBox.information(None, "Image", u"{0}".format(imagePath))
                    Image2Xmp(metadataDict, imagePath)
                    counting += 1
                else:
                    QMessageBox.information(None, "Image", u"Die Bilddatei für {0} wurde nicht gefunden (FileSystem: {1}).".format(metadataDict["APIS_bildnummer"], imagePath))
            else:
                QMessageBox.information(None, "Image", u"Die Bilddatei für {0} wurde nicht gefunden (ImageRegistry).".format(metadataDict["APIS_bildnummer"]))
            #imagePath = self.settings.value("APIS/image_dir") + "\\02140301\\02140301_003.jpg"
        progressDlg.setValue(count)

    def exportListAsPdf(self):

        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)
        self.printingOptionsDlg.setWindowTitle("Druck Optionen: Bildliste")

        if self.uiImageListTableV.model().rowCount() == 1:
            self.printingOptionsDlg.configure(False, False)
        elif not self.uiImageListTableV.selectionModel().hasSelection():
            self.printingOptionsDlg.configure(False, False)
        else:
            if len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
                self.printingOptionsDlg.configure(True, False)
            elif len(self.uiImageListTableV.selectionModel().selectedRows()) == self.uiImageListTableV.model().rowCount():
                self.printingOptionsDlg.configure(False, False)
            else:
                self.printingOptionsDlg.configure(True, False)

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():

            selectionModeIsAll = self.printingOptionsDlg.selectionModeIsAll()
            outputMode = self.printingOptionsDlg.outputMode()

            imageList = self.getImageList(selectionModeIsAll)
            if imageList:
                pdfsToPrint = []
                pdfsToPrint.append({'type': APISListPrinter.IMAGE, 'idList': imageList})
                APISPrinterQueue(pdfsToPrint,
                                 OutputMode.MergeNone,
                                 openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                 openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                 dbm=self.dbm,
                                 imageRegistry=self.imageRegistry,
                                 parent=self)

    def askForImageList(self):
        if self.uiImageListTableV.selectionModel().hasSelection():
            #Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Bildliste als PDF speichern')
            msgBox.setText(u'Wollen Sie die ausgewählten Bilder oder die gesamte Liste als PDF speichern?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                imageList = self.getImageList(False)
            elif ret == 1:
                imageList = self.getImageList(True)
            else:
                return None
        else:
            imageList = self.getImageList(True)

        return imageList


    def exportLabelsAsPdf(self):
        imageListOblique = self.getImageList(True, 3, u"schräg")
        imageListVertical = self.getImageList(True, 3, u"senk.")
        pdfsToPrint = []
        if imageListOblique:
            pdfsToPrint.append({'type': APISLabelPrinter.Oblique, 'idList': imageListOblique})

        if imageListVertical:
            pdfsToPrint.append({'type': APISLabelPrinter.Vertical, 'idList': imageListVertical})

        if pdfsToPrint:
            APISPrinterQueue(pdfsToPrint, OutputMode.MergeNone, dbm=self.dbm, parent=self)

    def onSelectionChanged(self, current, previous):
        # Filter ortho = ja
        if self.uiImageListTableV.selectionModel().hasSelection() and len(self.getImageList(False, 6, "ja")) > 0:
            pass
            #self.uiLoadOrthoBtn.setEnabled(True)
        else:
            pass
            #self.uiLoadOrthoBtn.setEnabled(False)
        #if self.uiImageListTableV.selectionModel().hasSelection() and len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
        #    self.uiLoadOrthoBtn.setEnabled(True)
        #else:
        #    self.uiLoadOrthoBtn.setEnabled(False)
        #QMessageBox.warning(None, "FilmNumber", "selection Changed")

    def applyFilter(self):
        self.uiImageListTableV.selectionModel().clear()
        if self.uiFilterGrp.isChecked():
            count = 0
            for row in range(self.model.rowCount()):
                show = True
                # Weise
                if (self.uiFilterVerticalChk.checkState() == Qt.Unchecked and self.model.item(row, 3).text() == u'senk.') or (self.uiFilterObliqueChk.checkState() == Qt.Unchecked and self.model.item(row, 3).text() == u'schräg'):
                    show = False
                # Images
                if show and ((self.uiFilterScanChk.checkState() == Qt.Checked and self.model.item(row,5).text() != self.uiFilterScanCombo.currentText()) or (self.uiFilterOrthoChk.checkState() == Qt.Checked and self.model.item(row,6).text() != self.uiFilterOrthoCombo.currentText()) or (self.uiFilterHiResChk.checkState() == Qt.Checked and self.model.item(row,7).text() != self.uiFilterHiResCombo.currentText())):
                    show = False
                # Scale
                if show and self.uiFilterScaleEdit.text().strip() != '':
                    imageScaleNumber = float(self.model.item(row, 2).text())
                    scaleNumber = float(self.uiFilterScaleEdit.text().replace(',', '.'))
                    operator = self.uiFilterScaleOperatorCombo.currentText()
                    if operator == '=':
                        if imageScaleNumber != scaleNumber:
                            show = False
                    elif operator == '>=':
                        if imageScaleNumber < scaleNumber:
                            show = False
                    elif operator == '<=':
                        if imageScaleNumber > scaleNumber:
                            show = False
                # filmart
                if show and self.uiFilterFilmKindChk.checkState() == Qt.Checked and self.uiFilterFilmKindCombo.currentText() != self.model.item(row,4).text():
                    show = False

                # year
                if show and self.uiFilterFromChk.checkState() == Qt.Checked and int(self.model.item(row,1).text()[2:6]) < self.uiFilterFromDate.date().year():
                    show = False
                if show and self.uiFilterToChk.checkState() == Qt.Checked and int(self.model.item(row,1).text()[2:6]) > self.uiFilterToDate.date().year():
                    show = False

                if show:
                    self.uiImageListTableV.showRow(row)
                    count += 1
                else:
                    self.uiImageListTableV.hideRow(row)

            self.uiImageFilterCountLbl.setText('({0})'.format(count))
            self.uiScanFilterCountLbl.setText('({0})'.format(len(self.getImageList(True,5,"ja"))))
            self.uiHiResFilterCountLbl.setText('({0})'.format(len(self.getImageList(True,7,"ja"))))
            self.uiOrthoFilterCountLbl.setText('({0})'.format(len(self.getImageList(True,6,"ja"))))

            self.onSelectionChanged(None, None)
            if count == 0:
                pass
                #self.uiLoadOrthoBtn.setEnabled(False)
                #self.uiImageThumbsBtn.setEnabled(False)
                #self.uiExportFootprintsBtn.setEnabled(False)
                #self.uiCopyImagesBtn.setEnabled(False)
                #self.uiPdfExportTBtn.setEnabled(False)
            else:
                pass
                #if self.uiImageListTableV.selectionModel().hasSelection() and len(self.uiImageListTableV.selectionModel().selectedRows()) == 1:
                #    self.uiLoadOrthoBtn.setEnabled(True)
                #self.uiImageThumbsBtn.setEnabled(True)
                #self.uiExportFootprintsBtn.setEnabled(True)
                #self.uiCopyImagesBtn.setEnabled(True)
                #self.uiPdfExportTBtn.setEnabled(True)
        else:
            # show all rows
            for row in range(self.model.rowCount()):
                self.uiImageListTableV.showRow(row)
            self.uiImageFilterCountLbl.setText('(-)')
            self.uiScanFilterCountLbl.setText('(-)')
            self.uiHiResFilterCountLbl.setText('(-)')
            self.uiOrthoFilterCountLbl.setText('(-)')

            #self.uiImageThumbsBtn.setEnabled(True)
            #self.uiExportFootprintsBtn.setEnabled(True)
            #self.uiCopyImagesBtn.setEnabled(True)
            #self.uiPdfExportTBtn.setEnabled(True)

            self.uiFilterScanChk.setChecked(False)
            self.uiFilterHiResChk.setChecked(False)
            self.uiFilterOrthoChk.setChecked(False)

    def getMinMaxDate(self):
        years = []
        for row in range(self.model.rowCount()):
            years.append(int(self.model.item(row, 1).text()[2:6]))
        return QDate(min(years), 1, 1), QDate(max(years), 1, 1)

    def onAccepted(self):
        self.accept()