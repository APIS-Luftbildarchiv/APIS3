# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from functools import partial

from PyQt5.QtCore import pyqtSignal, QSettings, Qt, QDate, QTime, QDateTime, QDir
from PyQt5.QtGui import QValidator, QIntValidator, QDoubleValidator, QColor, QIcon
from PyQt5.QtSql import QSqlRelationalTableModel, QSqlQuery, QSqlRelationalDelegate, QSqlQueryModel, QSqlRecord
from PyQt5.QtWidgets import QDialog, QDataWidgetMapper, QTableView, QAbstractItemView, QComboBox, QHeaderView, \
    QMessageBox, QPushButton, QFileDialog, QMenu
from PyQt5.uic import loadUiType
from qgis.core import (QgsProject, QgsVectorLayer, QgsDataSourceUri, QgsFeature)

from APIS.src.apis_findingtype_detail import APISFindingTypeDetail
from APIS.src.apis_sharding_selection_list import APISShardingSelectionList
from APIS.src.apis_text_editor import APISTextEditor
from APIS.src.apis_utils import OpenFileOrFolder, ApisLogger

# QgsGeometry, QgsCoordinateReferenceSystem, QgsMapSettings, QgsUnitTypes, QgsProject, QgsVectorLayer,
# QgsRasterLayer, QgsRectangle, QgsDataSourceUri, QgsFillSymbol, QgsFeature, QgsMarkerSymbol,
# QgsCentroidFillSymbolLayer, QgsSimpleLineSymbolLayer, QgsSingleSymbolRenderer, Qgis)

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_findspot.ui'), resource_suffix='')


class APISFindspot(QDialog, FORM_CLASS):

    findspotEditsSaved = pyqtSignal(bool)
    findspotDeleted = pyqtSignal(bool)

    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISFindspot, self).__init__(parent)

        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer

        self.setupUi(self)

        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)

        self.editMode = False
        self.addMode = False
        self.initalLoad = True
        self.geometryEditing = False
        self.isGeometryEditingSaved = False
        # Signals/Slot Connections
        self.rejected.connect(self.onReject)
        #self.uiButtonBox.rejected.connect(self.onReject)
        self.uiOkBtn.clicked.connect(self.onAccept)
        self.uiCancelBtn.clicked.connect(self.cancelEdit)
        self.uiSaveBtn.clicked.connect(self.saveEdits)

        self.uiPlotNumberBtn.clicked.connect(lambda: self.openTextEditor("Parzellennummer", self.uiPlotNumberEdit))
        self.uiCommentBtn.clicked.connect(lambda: self.openTextEditor("Bemerkung zur Lage", self.uiCommentEdit))
        self.uiFindingTypeDetailBtn.clicked.connect(self.openFindingTypeDetailDialog)

        self.uiLoadFindspotInQGisBtn.clicked.connect(self.loadFindspotInQGis)

        self.uiViewSiteBtn.clicked.connect(self.openSiteDialog)

        self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)

        mSharding = QMenu()
        aShardingOverview = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'footprints.png')), "Begehungen Übersicht")
        aShardingOverview.triggered.connect(self.openShardingSelectionListDialog)
        aShardingImages = mSharding.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'images.png')), "Fotos der Begehungen")
        # aShardingImages.triggered.connect(self.openShardingSelectionListDialog)
        self.uiShardingTBtn.setMenu(mSharding)
        self.uiShardingTBtn.clicked.connect(self.uiShardingTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        aPdfExportFindspot.triggered.connect(self.exportDetailsPdf) #TODO: use lambda: to send mode
        aPdfExportFindspotAndSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle und Fundort")
        aPdfExportFindspotAndSite.triggered.connect(self.exportDetailsPdf) #TODO: use lambda: to send mode
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        mFindspot = QMenu()
        aFindspotClone = mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'findspot_clone.png')), "Fundstelle klonen")
        aFindspotClone.triggered.connect(self.cloneFindspot)
        # TODO: implement MoveFindspotToSite
        # aFindspotMoveToSite.mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        # aFindspotMoveToSite.triggered.connect(self.exportDetailsPdf)
        aFindspotDelete = mFindspot.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'findspot_delete.png')), "Fundstelle löschen")
        aFindspotDelete.triggered.connect(self.deleteFindspot)
        self.uiFindspotTBtn.setMenu(mFindspot)
        self.uiFindspotTBtn.clicked.connect(self.uiFindspotTBtn.showMenu)

        # Setup Sub-Dialogs

        self.initalLoad = False

    def openInViewMode(self, siteNumber, findspotNumber):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.findspotNumber = findspotNumber

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundstelle")
        self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(self.siteNumber, self.findspotNumber))
        res = self.model.select()

        #QMessageBox.warning(None, "Funstellen Row Count", u"{0}".format(self.model.rowCount()))
        self.setupMapper()
        self.mapper.toFirst()

        #QMessageBox.warning(None, "Mapper", u"period detail: {0}".format(self.uiDatingPeriodDetailCombo.lineEdit().text()))

        query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)

        self.initalLoad = False

        #self.setupFindspotList()

    def openInAddMode(self, siteNumber, findspotNumber):
        self.initalLoad = True
        self.siteNumber = siteNumber
        self.findspotNumber = findspotNumber

        # Setup site model
        self.model = QSqlRelationalTableModel(self, self.dbm.db)
        self.model.setTable("fundstelle")
        self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(self.siteNumber, self.findspotNumber))
        res = self.model.select()

        #QMessageBox.warning(None, "Funstellen Row Count", u"{0}".format(self.model.rowCount()))
        self.setupMapper()
        self.mapper.toFirst()

        #QMessageBox.warning(None, "Mapper", u"period detail: {0}".format(self.uiDatingPeriodDetailCombo.lineEdit().text()))

        query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)

        self.addMode = True
        self.startEditMode()

        self.initalLoad = False

    # def openInEditMode(self, siteNumber, kgCode, kgName, siteArea):
    #     self.initalLoad = True
    #     self.siteNumber = siteNumber
    #     self.geometryEditing = True
    #
    #     # Setup site model
    #     self.model = QSqlRelationalTableModel(self, self.dbm.db)
    #     self.model.setTable("fundort")
    #     self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
    #     res = self.model.select()
    #     self.setupMapper()
    #     self.mapper.toFirst()
    #
    #     self.startEditMode()
    #     self.initalLoad = False
    #
    #     #update Editors
    #     if self.uiCadastralCommunityNumberEdit.text() != kgCode:
    #         self.uiCadastralCommunityNumberEdit.setText(kgCode)
    #     if self.uiCadastralCommunityEdit.text() != kgName:
    #         self.uiCadastralCommunityEdit.setText(kgName)
    #     if self.uiAreaEdit.text() != siteArea:
    #         self.uiAreaEdit.setText(unicode(siteArea))


    # def openInAddMode(self, siteNumber):
    #     self.initalLoad = True
    #     self.siteNumber = siteNumber
    #
    #     # Setup site model
    #     self.model = QSqlRelationalTableModel(self, self.dbm.db)
    #     self.model.setTable("fundort")
    #     self.model.setFilter("fundortnummer='{0}'".format(self.siteNumber))
    #     res = self.model.select()
    #     self.setupMapper()
    #     self.mapper.toFirst()
    #
    #     self.addMode = True
    #     self.startEditMode()
    #
    #     self.initalLoad = False



    def setupMapper(self):
        self.mapper = QDataWidgetMapper(self)
        self.mapper.setSubmitPolicy(QDataWidgetMapper.ManualSubmit)
        self.mapper.setItemDelegate(FindspotDelegate())

        self.mapper.setModel(self.model)

        self.mandatoryEditors = [self.uiCaseWorkerEdit, self.uiFindspotCreationCombo, self.uiSiteReliabilityCombo, self.uiDatingTimeCombo, self.uiDatingPeriodCombo, self.uiFindingTypeCombo]

        # LineEdits & PlainTextEdits
        self.intValidator = QIntValidator()
        self.doubleValidator = QDoubleValidator()

        self.uiFindspotNumberEdit.setText("{0}.{1}".format(self.siteNumber, self.findspotNumber))
        # From fundort: KG Nummer, KG Name, Flurname
        query = QSqlQuery(self.dbm.db)
        query.prepare("SELECT katastralgemeindenummer, katastralgemeinde, flurname FROM fundort WHERE fundortnummer = '{0}'".format(self.siteNumber))
        query.exec_()
        query.first()

        self.uiCadastralCommunityNumberEdit.setText(str(query.value(0)))
        self.uiCadastralCommunityEdit.setText(str(query.value(1)))
        self.uiFieldNameEdit.setText(str('' if query.isNull(2) else query.value(2)))


        self.lineEditMaps = {
            "bearbeiter": {
                "editor": self.uiCaseWorkerEdit
            },
            "erstmeldung_jahr": {
                "editor": self.uiFirstReportYearEdit,
                "validator": self.intValidator
            },
            "erhaltung": {
                "editor": self.uiPreservationStateEdit
            },
            "parzellennummern": {
                "editor": self.uiPlotNumberEdit
            },
            "bdanummer": {
                "editor": self.uiBdaNumberEdit
            },
            "kommentar_lage": {
                "editor": self.uiCommentEdit
            },
            "flaeche": {
                "editor": self.uiAreaEdit,
                "validator": self.doubleValidator
            },
            "datum_abs_1": {
               "editor": self.uiAbsoluteDatingFromEdit
            },
            "datum_abs_2": {
                "editor": self.uiAbsoluteDatingToEdit
            },
            "fundart_detail":{
                "editor": self.uiFindingTypeDetailEdit
            },
            "literatur":{
                "editor": self.uiLiteraturePTxt
            },
            "fundbeschreibung":{
                "editor": self.uiFindingsPTxt
            },
            "fundverbleib": {
                "editor": self.uiFindingsStoragePTxt
            },
            "sonstiges": {
                "editor": self.uiMiscellaneousPTxt
            },
            "fundgeschichte": {
                "editor": self.uiFindingsHistoryPTxt
            },
            "befund": {
                "editor": self.uiFindingsInterpretationPTxt
            }
        }
        for key, item in self.lineEditMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            if "validator" in item:
                item["editor"].setValidator(item["validator"])
            #item["editor"].textChanged.connect(partial(self.onLineEditChanged, item["editor"]))
            item["editor"].textChanged.connect(self.onLineEditChanged)

        # Date and Times
        self.mapper.addMapping(self.uiInitalEntryDate, self.model.fieldIndex("datum_ersteintrag"))
        self.mapper.addMapping(self.uiLastChangesDate, self.model.fieldIndex("datum_aenderung"))

        # ComboBox without Model
        self.mapper.addMapping(self.uiSiteReliabilityCombo, self.model.fieldIndex("sicherheit"))
        self.uiSiteReliabilityCombo.editTextChanged.connect(self.onLineEditChanged)
        # FIXME Pyqt5 AutoCompletion
        #self.uiSiteReliabilityCombo.setAutoCompletion(True)
        self.uiSiteReliabilityCombo.lineEdit().setValidator(InListValidator([self.uiSiteReliabilityCombo.itemText(i) for i in range(self.uiSiteReliabilityCombo.count())], self.uiSiteReliabilityCombo.lineEdit(), None, self))

        # ComboBox with Model
        self.comboBoxMaps = {
            "fundgewinnung_quelle": {
                "editor": self.uiFindspotCreationCombo,
                "table": "fundgewinnung_quelle",
                "modelcolumn": 0,
                "justshowcolumn": True,
                "depend": None
            },
            # "datierung_zeit": {
            #     "editor": self.uiDatingTimeCombo,
            #     "table": "zeit",
            #     "modelcolumn": 0,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "datierung_periode": {
            #     "editor": self.uiDatingPeriodCombo,
            #     "table": "zeit",
            #     "modelcolumn": 1,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "datierung_periode_detail": {
            #     "editor": self.uiDatingPeriodDetailCombo,
            #     "table": "zeit",
            #     "modelcolumn": 2,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            "phase_von": {
                "editor": self.uiFineDatingFromCombo,
                "table": "phase",
                "modelcolumn": 1,
                "justshowcolumn": True,
                "depend": None
            },
            "phase_bis": {
                 "editor": self.uiFineDatingToCombo,
                 "table": "phase",
                 "modelcolumn": 1,
                 "justshowcolumn": True,
                 "depend": None
            },
            "datierungsbasis": {
                "editor": self.uiDatingSourceCombo,
                "table": "datierung_quelle",
                "modelcolumn": 0,
                "justshowcolumn": True,
                "depend": None
            },
            "kultur": {
                "editor": self.uiCultureCombo,
                "table": "kultur",
                "modelcolumn": 0,
                "justshowcolumn": False,
                "depend": None
            }#,
            # "fundart": {
            #     "editor": self.uiFindingTypeCombo,
            #     "table": "fundart",
            #     "modelcolumn": 0,
            #     "justshowcolumn": True,
            #     "depend": None
            # },
            # "fundart_detail": {
            #     "editor": self.uiFindingTypeDetailCombo,
            #     "table": "fundart",
            #     "modelcolumn": 0,
            #     "justshowcolumn": False,
            #     "depend": None
            # }
        }
        for key, item in self.comboBoxMaps.items():
            self.mapper.addMapping(item["editor"], self.model.fieldIndex(key))
            self.setupComboBox(item["editor"], item["table"], item["modelcolumn"], item["justshowcolumn"], item["depend"])
            item["editor"].editTextChanged.connect(self.onLineEditChanged)


        #fundart
        self.mapper.addMapping(self.uiFindingTypeCombo, self.model.fieldIndex("fundart"))
        query = u"SELECT DISTINCT {0} FROM {0}".format("fundart")
        self.setupComboBoxByQuery(self.uiFindingTypeCombo, query)
        self.uiFindingTypeCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiFindingTypeCombo.currentIndexChanged.connect(self.resetFindingTypeDetail)


        #datierung
        self.mapper.addMapping(self.uiDatingTimeCombo, self.model.fieldIndex("datierung_zeit"))
        self.mapper.addMapping(self.uiDatingPeriodCombo, self.model.fieldIndex("datierung_periode"))
        self.mapper.addMapping(self.uiDatingPeriodDetailCombo, self.model.fieldIndex("datierung_periode_detail"))



        #query = u"SELECT DISTINCT {0} FROM {0}".format("zeit")
        #self.setupComboBoxByQuery(self.uiDatingTimeCombo, query)
        #self.uiDatingTimeCombo.setCurrentIndex(-1)

        #txt = self.uiDatingTimeCombo.lineEdit().text()
        #idx = self.uiDatingTimeCombo.findText(txt)
        #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}, {1}".format(txt, idx))
        #self.loadPeriodContent(0)
        #self.loadPeriodDetailsContent(0)

        #self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        #self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)
        # self.uiDatingCombo.currentIndexChanged.connect(self.joinRowValues)

    def loadPeriodContent(self, row):
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"TimeCombo Chagned: {0}".format(row))
        #pass
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"P: {0}".format(self.sender()))

        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}, {1}".format(time, period))
        #if time != "":
        #time = self.uiDatingTimeCombo.lineEdit().text()
        #period = self.uiDatingPeriodCombo.lineEdit().text()
        #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}".format(time))
        self.setupComboBoxByQuery(self.uiDatingPeriodCombo, u"SELECT DISTINCT periode FROM zeit WHERE zeit ='{0}'".format(time))

        index = self.uiDatingPeriodCombo.findText(period)
        if index < 0 and self.uiDatingPeriodCombo.count() == 1:
            self.uiDatingPeriodCombo.setCurrentIndex(0)
        #else:
        #    self.uiDatingPeriodCombo.setCurrentIndex(index)


    def loadPeriodDetailsContent(self, row):
        #QMessageBox.warning(None, self.tr(u"Datierung Sender"), u"PD: {0}".format(self.sender()))
        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        periodDetail = self.uiDatingPeriodDetailCombo.lineEdit().text()

            #QMessageBox.warning(None, self.tr(u"Datierung"), u"{0}".format(periodDetail))
        self.setupComboBoxByQuery(self.uiDatingPeriodDetailCombo, u"SELECT DISTINCT periode_detail FROM zeit WHERE zeit = '{0}' AND periode = '{1}'".format(time, period))

        index = self.uiDatingPeriodDetailCombo.findText(periodDetail)
        if index < 0 and self.uiDatingPeriodDetailCombo.count() == 1:
            self.uiDatingPeriodDetailCombo.setCurrentIndex(0)
        #else:
        #        self.uiDatingPeriodDetailCombo.setCurrentIndex(index)

    def resetFindingTypeDetail(self, row):
        self.uiFindingTypeDetailEdit.clear()

    #def setupComboBoxByQuery(self, editor, query):
    def setupComboBoxByQuery(self, editor, query, modelcolumn=0):
        currentText = editor.lineEdit().text()
        model = QSqlQueryModel(self)
        #model.setQuery("SELECT DISTINCT {0} FROM {1} ORDER BY {2}".format(column, table, order), self.dbm.db)
        model.setQuery(query, self.dbm.db)

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)
        tv.setWordWrap(True)

        editor.setModel(model)

        editor.setModelColumn(modelcolumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)
        tv.setMinimumWidth(tv.horizontalHeader().length()+100)
        tv.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # FIXME Pyqt5 AutoCompletion
        #editor.setAutoCompletion(True)
        editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), None, self))

        editor.setCurrentIndex(editor.findText(currentText))
        #editor.setCurrentIndex(-1)

    def setupComboBox(self, editor, table, modelColumn, justShowColumn, depend):
        model = QSqlRelationalTableModel(self, self.dbm.db)
        model.setTable(table)
        model.removeColumn(0)
        model.select()

        tv = QTableView()
        editor.setView(tv)

        tv.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        tv.setSelectionMode(QAbstractItemView.SingleSelection)
        tv.setSelectionBehavior(QAbstractItemView.SelectRows)
        tv.setAutoScroll(False)
        tv.setWordWrap(True)

        editor.setModel(model)
        if justShowColumn:
            cCount = model.columnCount()
            for i in range(cCount):
                if i != modelColumn:
                    tv.hideColumn(i)

        editor.setModelColumn(modelColumn)
        editor.setInsertPolicy(QComboBox.NoInsert)

        tv.resizeColumnsToContents()
        tv.resizeRowsToContents()
        tv.verticalHeader().setVisible(False)
        tv.horizontalHeader().setVisible(True)

        #tv.setMinimumWidth(500)

        tv.setMinimumWidth(tv.horizontalHeader().length()+100)
        tv.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # FIXME Pyqt5 AutoCompletion
        #editor.setAutoCompletion(True)
        editor.lineEdit().setValidator(InListValidator([editor.itemText(i) for i in range(editor.count())], editor.lineEdit(), depend, self))

        if depend:
            editor.currentIndexChanged.connect(partial(self.updateDepends, editor, depend))


    def updateDepends(self, editor, depend):
         for dep in depend:
            for key, value in dep.iteritems():
                idx = editor.model().createIndex(editor.currentIndex(), editor.model().fieldIndex(key))
                value.setText(str(editor.model().data(idx)))
                #QMessageBox.warning(None, "Test", str(idx))

    # def joinRowValues(self, row):
    #     editor = self.sender()
    #     #QMessageBox.warning(None, self.tr(u"Katastralgemeinde"), u"{0}".format(editor))
    #     record = editor.model().record(row)
    #     values = []
    #     for i in range(record.count()):
    #         values.append(record.value(i))
    #     editor.lineEdit().setText(", ".join(values))


    def enableItemsInLayout(self, layout, enable):
        for i in range(layout.count()):
            if layout.itemAt(i).widget():
                layout.itemAt(i).widget().setEnabled(enable)


    def onLineEditChanged(self):
        sender = self.sender()
        if not self.editMode and not self.initalLoad:
            self.startEditMode()
        if not self.initalLoad:
            sender.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(sender.metaObject().className()))
            self.editorsEdited.append(sender)



    def openTextEditor(self, title, editor):
        textEditorDlg = APISTextEditor()
        textEditorDlg.setWindowTitle(title)
        textEditorDlg.setText(editor.text())
        if textEditorDlg.exec_():
            editor.setText(textEditorDlg.getText())

    def openFindingTypeDetailDialog(self):
        findingTypeDetailDlg = APISFindingTypeDetail(self.iface, self.dbm)
        res = findingTypeDetailDlg.loadList(self.uiFindingTypeCombo.currentText(), self.uiFindingTypeDetailEdit.text())
        if res and findingTypeDetailDlg.exec_():
            self.uiFindingTypeDetailEdit.setText(findingTypeDetailDlg.getFindingTypeDetailText())

    def onAccept(self):
        '''
        Check DB
        Save options when pressing OK button
        Update Plugin Status
        '''

        # Save Settings

        self.accept()

    def onReject(self):
        '''
        Run some actions when
        the user closes the dialog
        '''
        if self.editMode:
            res = self.cancelEdit()
            if res:
                self.close()
                return "ABC"
            else:
                self.show()
        else:
            self.close()


    def loadFindspotInQGis(self):

        polygon, point = self.askForGeometryType()
        if polygon or point:
            # get PolygonLayer
            findspotNumber = self.uiFindspotNumberEdit.text()
            subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" = "{0}"'.format(findspotNumber)
            findspotLayer = self.getSpatialiteLayer(u"fundstelle", subsetString, u"fundstelle polygon {0}".format(findspotNumber))

            if polygon:
                # load PolygonLayer
                QgsProject.instance().addMapLayer(findspotLayer)

            if point:
                # generate PointLayer
                centerPointLayer = self.generateCenterPointLayer(findspotLayer, u"fundstelle punkt {0}".format(findspotNumber))
                # load PointLayer
                QgsProject.instance().addMapLayer(centerPointLayer)

    def askForGeometryType(self):
        # Abfrage ob Fundstellen der selektierten Bilder Exportieren oder alle
        msgBox = QMessageBox()
        msgBox.setWindowTitle(u'Fundstellen')
        msgBox.setText(u'Wollen Sie für die Fundstelle Polygone, Punkte oder beide Layer verwenden?')
        msgBox.addButton(QPushButton(u'Polygon'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Punkt'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Polygon und Punkt'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
        ret = msgBox.exec_()

        if ret == 0:
            polygon = True
            point = False
        elif ret == 1:
            polygon = False
            point = True
        elif ret == 2:
            polygon = True
            point = True
        else:
            return None, None

        return polygon, point

    def getSpatialiteLayer(self, layerName, subsetString=None, displayName=None):
        if not displayName:
            displayName = layerName
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbm.db.databaseName())
        uri.setDataSource('', layerName, 'geometry')
        layer = QgsVectorLayer(uri.uri(), displayName, 'spatialite')
        if subsetString:
            layer.setSubsetString(subsetString)

        return layer

    def generateCenterPointLayer(self, polygonLayer, displayName=None):
        if not displayName:
            displayName = polygonLayer.name()
        epsg = polygonLayer.crs().authid()
        # QMessageBox.warning(None, "EPSG", u"{0}".format(epsg))
        layer = QgsVectorLayer("Point?crs={0}".format(epsg), displayName, "memory")
        layer.setCrs(polygonLayer.crs())
        provider = layer.dataProvider()
        provider.addAttributes(polygonLayer.dataProvider().fields())

        layer.updateFields()

        pointFeatures = []
        for polygonFeature in polygonLayer.getFeatures():
            polygonGeom = polygonFeature.geometry()
            pointGeom = polygonGeom.centroid()
            # if center point is not on polygon get the nearest Point
            if not polygonGeom.contains(pointGeom):
                pointGeom = polygonGeom.pointOnSurface()

            pointFeature = QgsFeature()
            pointFeature.setGeometry(pointGeom)
            pointFeature.setAttributes(polygonFeature.attributes())
            pointFeatures.append(pointFeature)

        provider.addFeatures(pointFeatures)

        layer.updateExtents()

        return layer

    def openShardingSelectionListDialog(self):
        #if self.shardingDlg == None:
        shardingDlg = APISShardingSelectionList(self.iface, self.dbm)
        shardingDlg.loadShardingListBySiteNumber(self.siteNumber)
        if shardingDlg.exec_():
            pass
            #self.shardingDlg = None


    def cloneFindspot(self):
        self.initalLoad = True
        currentRecord = QSqlRecord(self.model.record(self.mapper.currentIndex()))
        siteNumber = currentRecord.value('fundortnummer')
        findspotNumberSource = currentRecord.value('fundstellenummer')
        findspotNumber = self.getNextFindspotNumber(siteNumber)
        currentRecord.setValue('ogc_fid', None)
        currentRecord.setValue('fundstellenummer', findspotNumber)
        now = QDate.currentDate()
        currentRecord.setValue('datum_ersteintrag', now.toString("yyyy-MM-dd"))
        currentRecord.setValue('datum_aenderung', now.toString("yyyy-MM-dd"))

        import getpass
        currentRecord.setValue('aktion', 'clone')
        currentRecord.setValue('aktionsdatum', now.toString("yyyy-MM-dd"))
        currentRecord.setValue('aktionsuser', getpass.getuser())

        res = self.model.insertRowIntoTable(currentRecord)
        if not res:
            QMessageBox.information(None, "SqlError", "{0}, {1}".format(self.model.lastError().text(), self.model.query().executedQuery()))

        self.model.setFilter("fundortnummer='{0}' AND fundstellenummer={1}".format(siteNumber, findspotNumber))
        res = self.model.select()
        #self.mapper.setModel(self.model)
        self.mapper.toFirst()
        self.uiFindspotNumberEdit.setText("{0}.{1}".format(siteNumber, findspotNumber))

        self.findspotNumber = findspotNumber
        self.siteNumber = siteNumber

        self.findspotEditsSaved.emit(True)

        # in log eintragen
        # TODO remove
        # self.apisLogger(u"clone", u"fundstelle", u"fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))
        ApisLogger(self.dbm.db, "clone", "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

        QMessageBox.information(None, u"Fundstelle Klonen", u"Die Fundstelle {0}.{1} wurde geklont und gespeichert: {0}.{2}".format(siteNumber, findspotNumberSource, findspotNumber))
        self.initalLoad = False

    def deleteFindspot(self):
        # Abfrage wirklich löschen
        header = u"Fundstelle löschen"
        question = u"Möchten Sie die Fundstelle wirklich aus der Datenbank löschen?"
        result = QMessageBox.question(None,
                                      header,
                                      question,
                                      QMessageBox.Yes | QMessageBox.No,
                                      QMessageBox.Yes)

        # save or not save

        if result == QMessageBox.Yes:
            # TODO: remove
            # self.apisLogger(u"delete", u"fundstelle", u"fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))
            ApisLogger(self.dbm.db, "delete", "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

            # löschen
            self.model.deleteRowFromTable(self.mapper.currentIndex())

            self.findspotDeleted.emit(True)
            self.iface.mapCanvas().refreshAllLayers()
            self.done(1)

    def apisLogger(self, action, fromTable, primaryKeysWhere):
        toTable = fromTable + u"_log"
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"INSERT INTO {0} SELECT * FROM {1} WHERE {2}".format(toTable, fromTable, primaryKeysWhere))

        res = query.exec_()
        #QMessageBox.information(None, "SqlQuery", query.executedQuery())
        if not res:
            QMessageBox.information(None, "SqlError", "{0}, {1}".format(query.lastError().text(), query.executedQuery()))
        import getpass
        query.prepare(u"UPDATE {0} SET aktion = '{1}', aktionsdatum = '{2}', aktionsuser = '{3}' WHERE rowid = (SELECT max(rowid) FROM {0})".format(toTable, action, QDateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss"), getpass.getuser(), primaryKeysWhere))
        res = query.exec_()
        #QMessageBox.information(None, "SqlQuery", query.executedQuery())
        if not res:
            QMessageBox.information(None, "SqlError", query.lastError().text())

    def getNextFindspotNumber(self, siteNumber):
        query = QSqlQuery(self.dbm.db)
        query.prepare(u"SELECT CASE WHEN max(fundstellenummer) IS NULL THEN 1 ELSE max(fundstellenummer)+1 END AS nextFindspot FROM fundstelle WHERE fundortnummer = '{0}'".format(siteNumber))
        res = query.exec_()
        query.first()
        return query.value(0)

    def exportDetailsPdf(self):
        saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
        timeStamp = QDateTime.currentDateTime().toString("yyyyMMdd_hhmmss")
        saveDialogTitle = u"Fundstelle"
        targetFileNameTemplate = u"Fundstelle_{0}.{1}_{2}".format(self.siteNumber, self.findspotNumber, timeStamp)
        targetFileName = QFileDialog.getSaveFileName(self, saveDialogTitle, os.path.join(saveDir, targetFileNameTemplate), "*.pdf")[0]

        if targetFileName:
            fsDetailsPrinter = ApisFindspotPrinter(self, self.dbm, self.imageRegistry)

            # print file
            pdfFiles = fsDetailsPrinter.exportDetailsPdf([u"{0}.{1}".format(self.siteNumber, self.findspotNumber)], targetFileName, timeStamp, False)

            # open file, open location?
            for key in pdfFiles:
                for pdfFile in pdfFiles[key]:
                    OpenFileOrFolder(pdfFile)

    #
    # def exportDetailsPdf(self):
    #     saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
    #     fileName = QFileDialog.getSaveFileName(self, 'Fundstelle Details', saveDir + "\\" + 'FundstelleDetails_{0}.{1}_{2}'.format(self.siteNumber, self.findspotNumber,QDateTime.currentDateTime().toString("yyyyMMdd_hhmmss")),'*.pdf')
    #
    #     if fileName:
    #         queryStr = u"SELECT katastralgemeinde, katastralgemeindenummer, fundstelle.* FROM fundstelle, fundort WHERE fundstelle.fundortnummer = fundort.fundortnummer AND fundstelle.fundortnummer = '{0}' AND fundstelle.fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber)
    #
    #         query = QSqlQuery(self.dbm.db)
    #         query.prepare(queryStr)
    #         query.exec_()
    #
    #         query.seek(-1)
    #         while query.next():
    #             findspotDict = {}
    #             rec = query.record()
    #
    #             #Replace
    #             for col in range(rec.count()-1): #-1 geometry wird nicht benötigt!
    #                 val = u"{0}".format(rec.value(col))
    #                 if val.replace(" ", "") == '' or val == 'NULL':
    #                     val = u"---"
    #                 findspotDict[unicode(rec.fieldName(col))] = val
    #
    #             findspotDict['datum_druck'] = QDate.currentDate().toString("dd.MM.yyyy")
    #             findspotDict['datum_ersteintrag'] = QDate.fromString(findspotDict['datum_ersteintrag'], "yyyy-MM-dd").toString("dd.MM.yyyy")
    #             findspotDict['datum_aenderung'] = QDate.fromString(findspotDict['datum_aenderung'], "yyyy-MM-dd").toString("dd.MM.yyyy")
    #
    #
    #             if findspotDict['sicherheit'] == u"1":
    #                 findspotDict['sicherheit'] = u"sicher"
    #             elif findspotDict['sicherheit'] == u"2":
    #                 findspotDict['sicherheit'] = u"wahrscheinlich"
    #             elif findspotDict['sicherheit'] == u"3":
    #                 findspotDict['sicherheit'] = u"fraglich"
    #             elif findspotDict['sicherheit'] == u"4":
    #                 findspotDict['sicherheit'] = u"keine Fundstelle"
    #
    #             # MapSettings
    #             mapSettings = QgsMapSettings()
    #             mapSettings.setMapUnits(QGis.UnitType(0))
    #             mapSettings.setOutputDpi(300)
    #
    #             # Template
    #             template = os.path.dirname(__file__) + "/composer/templates/FundstelleDetail.qpt"  # map_print_test.qpt"
    #             templateDom = QDomDocument()
    #             templateDom.setContent(QFile(template), False)
    #
    #             # Composition
    #             composition = QgsComposition(mapSettings)
    #             composition.setPlotStyle(QgsComposition.Print)
    #             composition.setPrintResolution(300)
    #             composition.loadFromTemplate(templateDom, findspotDict)
    #
    #             # Composer Items
    #
    #             pageCount = 1
    #
    #             adjustItems = ["kommentar_lage", "fundbeschreibung", "fundverbleib", "befund", "fundgeschichte", "literatur", "sonstiges"]
    #             bottomBorder = 30.0
    #             topBorder = 27.0
    #             i = 0
    #             for itemId in adjustItems:
    #
    #                 itemTxt = composition.getComposerItemById(itemId + "Txt")
    #                 itemLbl = composition.getComposerItemById(itemId +"Lbl")
    #                 itemBox = composition.getComposerItemById(itemId + "Box")
    #
    #                 if itemTxt and itemLbl:
    #
    #                     #textWidth = QgsComposerUtils.textWidthMM(itemTxt.font(), itemTxt.displayText())
    #                     fontHeight = QgsComposerUtils.fontHeightMM(itemTxt.font())
    #                     oldHeight = itemTxt.rectWithFrame().height()
    #                     displayText = itemTxt.displayText()
    #                     boxWidth = itemTxt.rectWithFrame().width() - 2 * itemTxt.marginX()
    #                     lineCount = 0
    #                     for line in displayText.splitlines():
    #                         textWidth = max(1.0, QgsComposerUtils.textWidthMM(itemTxt.font(), line))
    #                         lineCount += math.ceil(textWidth / boxWidth)
    #
    #                     newHeight = fontHeight * (lineCount + 1)
    #                     newHeight += 2 * itemTxt.marginY() + 2
    #
    #                     x = itemTxt.pos().x()
    #                     if i == 0:
    #                         y = itemTxt.pos().y()
    #                     else:
    #                         y = newY
    #                     w = itemTxt.rectWithFrame().width()
    #                     newY = y + newHeight
    #                     if newY > composition.paperHeight() - bottomBorder:
    #                         pageCount += 1
    #                         y = topBorder
    #                         newY = y + newHeight
    #                         #copy Header
    #                         header = 1
    #                         while composition.getComposerItemById("header_{0}".format(header)):
    #                             self.cloneLabel(composition, composition.getComposerItemById("header_{0}".format(header)), pageCount)
    #                             header += 1
    #                         #copyFooter
    #                         footer = 1
    #                         while composition.getComposerItemById("footer_{0}".format(footer)):
    #                             self.cloneLabel(composition, composition.getComposerItemById("footer_{0}".format(footer)),pageCount)
    #                             footer += 1
    #
    #                     itemTxt.setItemPosition(x, y, w, newHeight, QgsComposerItem.UpperLeft, True, pageCount)
    #                     itemLbl.setItemPosition(itemLbl.pos().x(), y, itemLbl.rectWithFrame().width(), itemLbl.rectWithFrame().height(), QgsComposerItem.UpperLeft, True, pageCount)
    #
    #                     i += 1
    #
    #                     if itemBox:
    #                         h = (itemBox.rectWithFrame().height() - oldHeight) + newHeight
    #                         itemBox.setItemPosition(itemBox.pos().x(), itemBox.pos().y(), itemBox.rectWithFrame().width(), h, QgsComposerItem.UpperLeft, True, pageCount)
    #
    #
    #             #QMessageBox.information(None, "info", u"w: {0}, h: {1}, w: {2}, h: {3}, , x: {4}, y: {5}".format(width, height, l.rectWithFrame().width(), l.rectWithFrame().height(), l.pos().x(), l.pos().y()))
    #
    #             composition.setNumPages(pageCount)
    #
    #             # Create PDF
    #             composition.exportAsPDF(fileName)
    #
    #             # Open PDF
    #             OpenFileOrFolder(fileName)
    #
    def cloneLabel(self, comp, l, pageCount):
        label = QgsComposerLabel(comp)
        label.setItemPosition(l.pos().x(), l.pos().y(), l.rectWithFrame().width(), l.rectWithFrame().height(), QgsComposerItem.UpperLeft, True, pageCount)
        label.setBackgroundEnabled(True)
        label.setBackgroundColor(QColor("#CCCCCC"))
        label.setText(l.text())
        label.setVAlign(l.vAlign())
        label.setHAlign(l.hAlign())
        label.setMarginX(l.marginX())
        label.setMarginY(l.marginY())
        label.setFont(l.font())
        comp.addItem(label)

    def openSiteDialog(self):
        from APIS.src.apis_site import APISSite
        # if parent is instance of ApisSiteDialog then just close
        # if parent is ApisFindspotSelectionListDialog then open ApisSiteDialog and close ApisFindspotDialog
        if isinstance(self.parentWidget(), APISSite):
            #QMessageBox.warning(None, "Test", u"{0}".format(self.parentWidget()))
            self.close()
        else:
            siteDlg = APISSite(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self.parentWidget())
            siteDlg.openInViewMode(self.siteNumber)
            self.close()
            siteDlg.show()
            if siteDlg.exec_():
                pass
            siteDlg.removeSitesFromSiteMapCanvas()


    def removeNewFindspot(self):
        self.initalLoad = True
        row = self.mapper.currentIndex()
        self.model.removeRow(row)
        self.model.submitAll()
        self.initalLoad = False

    def saveEdits(self):
        # Check Mandatory fields
        flag = False
        for mEditor in self.mandatoryEditors:
            cName = mEditor.metaObject().className()
            if cName == 'QLineEdit':
                value = mEditor.text()
            elif cName == 'QComboBox':
                if mEditor.isEditable():
                    value = mEditor.lineEdit().text()
                else:
                    if mEditor.currentIndex == -1:
                        value = ''
                    else:
                        value = '1'
            if value.strip() == "":
                flag = True
                # ROT wenn Plichtfeld leer
                mEditor.setStyleSheet("{0} {{background-color: rgb(240, 160, 160);}}".format(cName))
                if mEditor not in self.editorsEdited:
                    self.editorsEdited.append(mEditor)
            else:
                if mEditor in self.editorsEdited:
                    # BLAU wenn Pflichtfeld nicht leer und editiert
                    mEditor.setStyleSheet("{0} {{background-color: rgb(153, 204, 255);}}".format(cName))
                #else:
                    #mEditor.setStyleSheet("")
        if flag:
            QMessageBox.warning(None, self.tr(u"Benötigte Felder Ausfüllen"), self.tr(u"Füllen Sie bitte alle Felder aus, die mit * gekennzeichnet sind."))
            return False

        #saveToModel
        currIdx = self.mapper.currentIndex()
        now = QDate.currentDate()
        self.uiLastChangesDate.setDate(now)

        if self.addMode:
            action = u"new"
        else:
            action = u"editA"
            #Update AKTION only in EDIT Mode
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktion")), u"editAG" if self.geometryEditing else u"editA")
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsdatum")), now.toString("yyyy-MM-dd"))
            import getpass
            self.model.setData(self.model.createIndex(currIdx, self.model.fieldIndex("aktionsuser")), getpass.getuser())

        self.mapper.submit()

        #emit signal
        self.findspotEditsSaved.emit(True)

        #log
        # TODO remove
        #self.apisLogger(action, u"fundstelle", u"fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))
        ApisLogger(self.dbm.db, action, "fundstelle", "fundortnummer = '{0}' AND fundstellenummer = {1}".format(self.siteNumber, self.findspotNumber))

        self.mapper.setCurrentIndex(currIdx)
        self.endEditMode()

        self.iface.mapCanvas().refreshAllLayers()
        #
        if not self.isGeometryEditingSaved:
            self.isGeometryEditingSaved = True
        return True



    def cancelEdit(self):
        currIdx = self.mapper.currentIndex()
        if self.editMode:
            if self.addMode:
                header = self.tr(u"Neue Fundstelle wurden hinzugefügt!")
                question = self.tr(u"Möchten Sie die neue Fundstelle speichern?")
            elif self.geometryEditing:
                header = self.tr(u"Änderungen an der Fundstellen Geometrie wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änderungen der Geometrie und Attribute speichern?")
            else:
                header = self.tr(u"Änderungen wurden vorgenommen!")
                question = self.tr(u"Möchten Sie die Änderungen der Attribute speichern?")
            result = QMessageBox.question(None,
                                          header,
                                          question,
                                          QMessageBox.Yes | QMessageBox.No ,
                                          QMessageBox.Yes)

            #save or not save
            if result == QMessageBox.Yes:
                res = self.saveEdits()
                if res:
                    return True
                else:
                    return False
            elif result == QMessageBox.No:
                self.geometryEditing = False
                if self.addMode:
                    self.removeNewFindspot()
                    self.endEditMode(False)
                    self.close()
                    return True
                else:
                    self.mapper.setCurrentIndex(currIdx)
                    self.endEditMode(False)
                    return True

    def startEditMode(self):
        self.editMode = True
        #self.setWindowModality(Qt.ApplicationModal)
        #self.setModal(True)
        #geomHelper = self.saveGeometry()
        #self.hide()
        #self.show()
        #self.restoreGeometry(geomHelper)
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, False)
        self.uiOkBtn.setEnabled(False)
        self.uiSaveBtn.setEnabled(True)
        self.uiCancelBtn.setEnabled(True)
        self.editorsEdited = []

    def endEditMode(self, modalityFlag=True):
        self.editMode = False
        self.addMode = False
        self.enableItemsInLayout(self.uiBottomHorizontalLayout, True)
        self.uiOkBtn.setEnabled(True)
        self.uiSaveBtn.setEnabled(False)
        self.uiCancelBtn.setEnabled(False)
        for editor in self.editorsEdited:
            cName = editor.metaObject().className()
            if (cName == "QLineEdit" or cName == "QDateEdit") and editor.isReadOnly():
                editor.setStyleSheet("{0} {{background-color: rgb(218, 218, 218);}}".format(cName))
            else:
                editor.setStyleSheet("")
        self.editorsEdited = []



        #self.uiDatingTimeCombo.editTextChanged.disconnect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.disconnect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.disconnect(self.onLineEditChanged)
        self.initalLoad = True
        self.uiDatingTimeCombo.currentIndexChanged.disconnect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.loadPeriodDetailsContent)
        #self.loadPeriodContent(0)
        #self.loadPeriodDetailsContent(0)
        time = self.uiDatingTimeCombo.lineEdit().text()
        period = self.uiDatingPeriodCombo.lineEdit().text()
        periodDetail = self.uiDatingPeriodDetailCombo.lineEdit().text()
        #QMessageBox.warning(None, "Test", u"{0}, {1}, {2}".format(time, period, periodDetail))

        self.uiDatingTimeCombo.setCurrentIndex(self.uiDatingTimeCombo.findText(time))
        self.loadPeriodContent(0)
        self.loadPeriodDetailsContent(0)
        #self.setupComboBoxByQuery(self.uiDatingPeriodCombo, u"SELECT DISTINCT periode FROM zeit WHERE zeit ='{0}'".format(time))
        #self.uiDatingPeriodCombo.setCurrentIndex(self.uiDatingPeriodCombo.findText(period))
        #self.setupComboBoxByQuery(self.uiDatingPeriodDetailCombo, u"SELECT DISTINCT periode_detail FROM zeit WHERE zeit = '{0}' AND periode = '{1}'".format(time, period))
        #self.uiDatingPeriodDetailCombo.setCurrentIndex(self.uiDatingPeriodDetailCombo.findText(periodDetail))

        #self.uiDatingTimeCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodCombo.editTextChanged.connect(self.onLineEditChanged)
        #self.uiDatingPeriodDetailCombo.editTextChanged.connect(self.onLineEditChanged)
        self.uiDatingTimeCombo.currentIndexChanged.connect(self.loadPeriodContent)
        self.uiDatingPeriodCombo.currentIndexChanged.connect(self.loadPeriodDetailsContent)
        self.initalLoad = False
        #self.setWindowModality(Qt.NonModal)
        #self.setModal(False)
        #if modalityFlag:
        #    self.hide()
        #    self.show()

    def isGeometrySaved(self):
        return self.isGeometryEditingSaved and self.geometryEditing

class FindspotDelegate(QSqlRelationalDelegate):
    def __init__(self):
       QSqlRelationalDelegate.__init__(self)

    def createEditor(self, parent, option, index):
        pass

    def setEditorData(self, editor, index):
        #QMessageBox.warning(None, "Test", str(editor.metaObject().className(index))()) + str
        value = str(index.model().data(index, Qt.EditRole))

        if value == 'NULL':
            value = ''

        if editor.metaObject().className() == 'QTimeEdit' and value == '':
            editor.setTime(QTime(0,0,0))
            #if value == '':
                #value ="00:00:00"

        elif editor.metaObject().className() == 'QLineEdit':
            editor.setText(value)

        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 3: #3 - sicherheit
                #if value == '':
                #    editor.setCurrentIndex(-1)
                #else:
                #    editor.setCurrentIndex(int(value) - 1)
                try:
                    editor.setCurrentIndex(int(value) - 1)
                except ValueError:
                    editor.setCurrentIndex(-1)

            else:
                editor.setEditText(value)

        elif editor.metaObject().className() == 'QListWidget':
            #QMessageBox.warning(None, "Test", unicode(index.model().data(index, Qt.EditRole)))
            editor.clear()
            editor.addItems(str.split(value, ";"))
        else:
            QSqlRelationalDelegate.setEditorData(self, editor, index)

    def setModelData(self, editor, model, index):
        #if editor.metaObject().className() == 'QLineEdit':
            #QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #if unicode(index.data(Qt.DisplayRole)) != unicode(editor.text()):
            #    QMessageBox.warning(None, "Test", unicode(index.data(Qt.DisplayRole)) + ',' + unicode(editor.text()))
            #    model.setData(index, editor.text())

        # if index.column() == 0: #0 ... filmnummer, 1 ... filmnummer_legacy, 2 ... filmnummer_hh_jjjj_mm, 3 ... filmnummer_nn
        #     #QMessageBox.warning(None, "Test", unicode(index.column()) + editor.text())
        #     filmnummer = str(editor.text())
        #     model.setData(model.createIndex(index.row(), 2), filmnummer[:8]) # filmnummer_hh_jjjj_mm
        #     model.setData(model.createIndex(index.row(), 3), int(filmnummer[-2:])) # filmnummer_nn
        #     model.setData(model.createIndex(index.row(), 0), filmnummer) #filmnummer
        #     mil = ""
        #     if filmnummer[2:4] == "19":
        #         mil = "01"
        #     elif filmnummer[2:4] == "20":
        #         mil = "02"
        #     model.setData(model.createIndex(index.row(), 1), mil + filmnummer[4:]) # filmnummer_legacy

        # elif editor.metaObject().className() == 'QDateEdit':
        if editor.metaObject().className() == 'QDateEdit':
            model.setData(index, editor.date().toString("yyyy-MM-dd"))
        elif editor.metaObject().className() == 'QTimeEdit':
            model.setData(index, editor.time().toString("HH:mm:ss"))
        elif editor.metaObject().className() == 'QListWidget':
            items = []
            for j in range(editor.count()):
                items.append(editor.item(j))
            model.setData(index, ";".join([i.text() for i in items]))
        #elif (editor.metaObject().className() == 'QLineEdit' and editor.text()==''):
        #    model.setData(model.createIndex(index.row(), 0), None)
        elif editor.metaObject().className() == 'QComboBox':
            if index.column() == 3: #3 - sicherheit
                model.setData(index, editor.currentIndex()+1)
            else:
                model.setData(index, editor.currentText())
        else:
            QSqlRelationalDelegate.setModelData(self, editor, model, index)

class InListValidator(QValidator):
        def __init__(self, itemList, editor, depend, parent):
            QValidator.__init__(self, parent)

            self.itemList = itemList
            self.editor = editor
            self.depend = depend

        def validate(self, s, pos):

            if str(s) in self.itemList or str(s).strip()=='':
                if self.depend and str(s).strip()=='':
                    for dep in self.depend:
                        for key, value in dep.iteritems():
                            value.setText("")
                return (QValidator.Acceptable, s, pos)

            return (QValidator.Invalid, "", pos)


        def fixup(self, s):
            #QMessageBox.warning(None, "Test", unicode(s))
            self.editor.setText("")
