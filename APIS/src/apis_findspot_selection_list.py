# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QAbstractItemView, QHeaderView, QMenu  # QFileDialog, QPushButton
from PyQt5.QtCore import QSettings, QDateTime  # Qt, QDir, QFile
from PyQt5.QtGui import QIcon  # QStandardItemModel, QStandardItem

# from qgis.core import (QgsProject, QgsVectorLayer, QgsDataSourceUri, QgsFeature, QgsVectorFileWriter)

from APIS.src.apis_findspot import APISFindspot
from APIS.src.apis_utils import (GetWindowSize,
                                 GetWindowPos,
                                 SetWindowSizeAndPos,
                                 SelectionOrAll,
                                 PolygonOrPoint, )  # FileOrFolder, OpenFileOrFolder
from APIS.src.apis_printer import APISPrinterQueue, APISListPrinter, APISTemplatePrinter  # OutputMode
from APIS.src.apis_printing_options import APISPrintingOptions

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_findspot_selection_list.ui'), resource_suffix='')


class APISFindspotSelectionList(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISFindspotSelectionList, self).__init__(parent)
        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer
        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)
        self.setupUi(self)

        # Initial window size/pos last saved. Use default values for first time
        if GetWindowSize("findspot_selection_list"):
            self.resize(GetWindowSize("findspot_selection_list"))
        if GetWindowPos("findspot_selection_list"):
            self.move(GetWindowPos("findspot_selection_list"))

        self.query = None

        self.accepted.connect(self.onClose)
        self.rejected.connect(self.onClose)

        self.uiFindspotListTableV.doubleClicked.connect(self.openFindspotDialog)

        self.uiResetSelectionBtn.clicked.connect(self.uiFindspotListTableV.clearSelection)

        mLayer = QMenu()
        mLayer.addSection("In QGIS laden")
        aLayerLoadFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n)")
        aLayerLoadFindspot.triggered.connect(self.loadFindspotInQgis)
        aLayerLoadFindspotAndSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n) und Fundort(e)")
        aLayerLoadFindspotAndSite.triggered.connect(lambda: self.loadFindspotInQgis(loadSites=True))
        mLayer.addSection("SHP Export")
        aLayerExportFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "Fundstelle(n)")
        aLayerExportFindspot.triggered.connect(self.exportFindspotAsShp)
        aLayerExportFindspotAndSite = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "Fundstelle(n) und Fundort(e)")
        aLayerExportFindspotAndSite.triggered.connect(lambda: self.exportFindspotAsShp(exportSites=True))
        mLayer.addSection("In QGIS anzeigen")
        aLayerShowFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle(n) zoomen")
        aLayerShowFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=False))
        aLayerSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n) selektieren")
        aLayerSelectFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=False, select=True))
        aLayerShowAndSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle(n) zoomen und selektieren")
        aLayerShowAndSelectFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=True))
        mLayer.addSeparator()
        aLayerShowFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundort(e) zoomen")
        aLayerShowFindspot.triggered.connect(lambda: self.showSiteInQgis(zoomTo=True, select=False))
        aLayerSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundort(e) selektieren")
        aLayerSelectFindspot.triggered.connect(lambda: self.showSiteInQgis(zoomTo=False, select=True))
        aLayerShowAndSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundort(e) zoomen und selektieren")
        aLayerShowAndSelectFindspot.triggered.connect(lambda: self.showSiteInQgis(zoomTo=True, select=True))
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportFindspotList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstellenliste")
        aPdfExportFindspotList.triggered.connect(lambda: self.exportAsPdf(tab_list=True))
        aPdfExportFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        aPdfExportFindspot.triggered.connect(lambda: self.exportAsPdf(detail=True))
        aPdfExportFindspotAndSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle und Fundort")
        aPdfExportFindspotAndSite.triggered.connect(lambda: self.exportAsPdf(detail=True, parentDetail=True))
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        self.findspotDlg = None
        self.printingOptionsDlg = None

    def hideEvent(self, event):
        self.query = None

    def loadFindspotListBySpatialQuery(self, query=None, info=None, update=False):
        if self.query is None:
            self.query = query

        self.model = self.dbm.queryToQStandardItemModel(self.query)

        if self.model is None or self.model.rowCount() < 1:
            if not update:
                QMessageBox.warning(self, "Fundstellen Auswahl", "Es wurden keine Fundstellen gefunden!")
            self.query = None
            self.done(1)
            return False

        self.setupTable()

        self.uiItemCountLbl.setText(str(self.model.rowCount()))
        if info is not None:
            self.uiInfoLbl.setText(info)

        return True

    def setupTable(self):
        self.uiFindspotListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiFindspotListTableV.setModel(self.model)
        self.uiFindspotListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.uiFindspotListTableV.resizeColumnsToContents()
        self.uiFindspotListTableV.resizeRowsToContents()
        self.uiFindspotListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.uiFindspotListTableV.selectionModel().selectionChanged.connect(self.onSelectionChanged)

    def onSelectionChanged(self):
        self.uiSelectionCountLbl.setText("{0}".format(len(self.uiFindspotListTableV.selectionModel().selectedRows())))

    def openFindspotDialog(self, idx):
        findspotNumber = self.model.item(idx.row(), 1).text()
        siteNumber = self.model.item(idx.row(), 0).text()
        if self.findspotDlg is None:
            self.findspotDlg = APISFindspot(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self)
            self.findspotDlg.findspotEditsSaved.connect(self.reloadTable)
            self.findspotDlg.findspotDeleted.connect(self.reloadTable)
        self.findspotDlg.openInViewMode(siteNumber, findspotNumber)
        self.findspotDlg.show()
        # Run the dialog event loop

        if self.findspotDlg.exec_():
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        self.findspotDlg.uiDatingTimeCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodContent)
        self.findspotDlg.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodDetailsContent)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"For Site: {0}".format(siteNumber)))

    def reloadTable(self, editsSaved):
        self.query.exec_()
        self.loadFindspotListBySpatialQuery(self.query, None, True)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"Reload Table Now"))

    def showFindspotInQgis(self, zoomTo=True, select=False):
        layer = self.apisLayer.requestFindspotLayer()
        expression = "\"fundortnummer\" || '.' || \"fundstellenummer\" IN ({})".format(','.join(["'{}'".format(fsN) for fsN in self.getFindspotList(False)]))
        self.apisLayer.selectFeaturesByExpression(layer, expression)
        if zoomTo:
            self.apisLayer.zoomToSelection(layer)
        if not select:
            layer.removeSelection()

    def showSiteInQgis(self, zoomTo=True, select=False):
        layer = self.apisLayer.requestSiteLayer()
        expression = "\"fundortnummer\" IN ({})".format(','.join(["'{}'".format(sN) for sN in self.getSiteList(False)]))
        self.apisLayer.selectFeaturesByExpression(layer, expression)
        if zoomTo:
            self.apisLayer.zoomToSelection(layer)
        if not select:
            layer.removeSelection()

    def getSiteNumberFromFindspotNumber(self, fsNumber):
        fsNumberElements = fsNumber.split(".")
        return f'{fsNumberElements[0]}.{fsNumberElements[1]}'

    def loadFindspotInQgis(self, loadSites=False):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = PolygonOrPoint(parent=self)
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))
                subsetString = '"fundortnummer"  || \'.\' || "fundstellenummer" IN (' + ','.join(['\'{0}\''.format(findspotNumber) for findspotNumber in findspotList]) + ')'
                findspotLayer = self.apisLayer.getSpatialiteLayer('fundstelle', subsetString)

                if loadSites:
                    subsetString = '"fundortnummer" IN (' + ','.join(['\'{0}\''.format(siteNumber) for siteNumber in list(set([self.getSiteNumberFromFindspotNumber(findspotNumber) for findspotNumber in findspotList]))]) + ')'
                    siteLayer = self.apisLayer.getSpatialiteLayer('fundort', subsetString)

                if polygon and findspotLayer:
                    findspotLayerMemory = self.apisLayer.createMemoryLayer(findspotLayer, "fundstelle polygon")
                    findspotLayerMemory.loadNamedStyle(self.apisLayer.getStylePath("find_spots_fp"))
                    # load PolygonLayer
                    self.apisLayer.addLayerToCanvas(findspotLayerMemory, "Temp")

                    if loadSites and siteLayer:
                        siteLayerMemory = self.apisLayer.createMemoryLayer(siteLayer, "fundort polygon")
                        siteLayerMemory.loadNamedStyle(self.apisLayer.getStylePath("sites_fp"))
                        # load PolygonLayer
                        self.apisLayer.addLayerToCanvas(siteLayerMemory, "Temp")

                if point and findspotLayer:
                    # generate PointLayer
                    centerPointLayer = self.apisLayer.generateCenterPointMemoryLayer(findspotLayer, "fundstelle punkt")
                    centerPointLayer.loadNamedStyle(self.apisLayer.getStylePath("find_spots_cp"))
                    # load PointLayer
                    self.apisLayer.addLayerToCanvas(centerPointLayer, "Temp")

                    if loadSites and siteLayer:
                        siteCenterPointLayerMemory = self.apisLayer.generateCenterPointMemoryLayer(siteLayer, "fundort punkt")
                        siteCenterPointLayerMemory.loadNamedStyle(self.apisLayer.getStylePath("sites_cp"))
                        # load PolygonLayer
                        self.apisLayer.addLayerToCanvas(siteCenterPointLayerMemory, "Temp")

                self.close()

    def exportFindspotAsShp(self, exportSites=False):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = PolygonOrPoint(parent=self)
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))
                subsetString = '"fundortnummer"  || \'.\' || "fundstellenummer" IN (' + ','.join(['\'{0}\''.format(findspotNumber) for findspotNumber in findspotList]) + ')'
                findspotLayer = self.apisLayer.getSpatialiteLayer('fundstelle', subsetString)

                if exportSites:
                    subsetString = '"fundortnummer" IN (' + ','.join(['\'{0}\''.format(siteNumber) for siteNumber in list(set([self.getSiteNumberFromFindspotNumber(findspotNumber) for findspotNumber in findspotList]))]) + ')'
                    siteLayer = self.apisLayer.getSpatialiteLayer('fundort', subsetString)

                now = QDateTime.currentDateTime()
                time = now.toString("yyyyMMdd_hhmmss")
                if polygon and findspotLayer:
                    # save PolygonLayer
                    self.apisLayer.exportLayerAsShp(findspotLayer, time, name="Fundstelle_Polygon", groupName="Temp", styleName="find_spots_fp", parent=self)
                    if exportSites and siteLayer:
                        self.apisLayer.exportLayerAsShp(siteLayer, time, name="Fundort_Polygon", groupName="Temp", styleName="sites_fp", parent=self)

                if point and findspotLayer:
                    # generate PointLayer
                    centerPointLayer = self.apisLayer.generateCenterPointMemoryLayer(findspotLayer)
                    # save PointLayer
                    self.apisLayer.exportLayerAsShp(centerPointLayer, time, name="Fundstelle_Punkt", groupName="Temp", styleName="find_spots_cp", parent=self)
                    if exportSites and siteLayer:
                        siteCenterPointLayer = self.apisLayer.generateCenterPointMemoryLayer(siteLayer)
                        self.apisLayer.exportLayerAsShp(siteCenterPointLayer, time, name="Fundort_Punkt", groupName="Temp", styleName="sites_cp", parent=self)

    def exportAsPdf(self, tab_list=False, detail=False, parentDetail=False):
        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)

        if tab_list and not detail and not parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstellenliste")
            personalData = False
            filmProject = False
        elif detail and not tab_list and not parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle")
            personalData = True
            filmProject = False
        elif detail and parentDetail and not tab_list:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle und Fundort")
            personalData = True
            filmProject = True
        else:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstellen Auswahl")
            personalData = False
            filmProject = False

        if self.uiFindspotListTableV.model().rowCount() == 1:
            self.printingOptionsDlg.configure(False, False, visPersonalDataChk=personalData, visFilmProjectChk=filmProject)
        elif not self.uiFindspotListTableV.selectionModel().hasSelection():
            self.printingOptionsDlg.configure(False, detail, visPersonalDataChk=personalData, visFilmProjectChk=filmProject)
        else:
            if len(self.uiFindspotListTableV.selectionModel().selectedRows()) == 1:
                self.printingOptionsDlg.configure(True, detail, visPersonalDataChk=personalData, visFilmProjectChk=filmProject)
            elif len(self.uiFindspotListTableV.selectionModel().selectedRows()) == self.uiFindspotListTableV.model().rowCount():
                self.printingOptionsDlg.configure(False, detail, visPersonalDataChk=personalData, visFilmProjectChk=filmProject)
            else:
                self.printingOptionsDlg.configure(True, detail, visPersonalDataChk=personalData, visFilmProjectChk=filmProject)

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():
            # get settings from dialog
            printPersonalData = self.printingOptionsDlg.printPersonalData()
            printFilmProject = self.printingOptionsDlg.printFilmProject()
            selectionModeIsAll = self.printingOptionsDlg.selectionModeIsAll()
            outputMode = self.printingOptionsDlg.outputMode()

            findspotList = self.getFindspotList(selectionModeIsAll)
            if findspotList:
                pdfsToPrint = []
                if tab_list:
                    pdfsToPrint.append({'type': APISListPrinter.FINDSPOT, 'idList': findspotList})

                if detail:
                    for findspot in findspotList:
                        if parentDetail:
                            pdfsToPrint.append({'type': APISTemplatePrinter.SITE, 'idList': [findspot.rsplit(".", 1)[0]], 'options': {'filmProject': printFilmProject}})
                        pdfsToPrint.append({'type': APISTemplatePrinter.FINDSPOT, 'idList': [findspot], 'options': {'personalData': printPersonalData}})

                if pdfsToPrint:
                    APISPrinterQueue(pdfsToPrint,
                                     outputMode,
                                     openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                     openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                     dbm=self.dbm,
                                     parent=self)

    def askForFindspotList(self):
        if self.uiFindspotListTableV.selectionModel().hasSelection():
            # Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
            ret = SelectionOrAll(parent=self)
            if ret == 0:
                return self.getFindspotList(False)
            elif ret == 1:
                return self.getFindspotList(True)
            else:
                return None
        else:
            return self.getFindspotList(True)

    def getFindspotList(self, getAll):
        findspotList = []
        if self.uiFindspotListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiFindspotListTableV.selectionModel().selectedRows()
            for row in rows:
                if not self.uiFindspotListTableV.isRowHidden(row.row()):
                    findspotList.append(f"{self.model.item(row.row(), 0).text()}.{self.model.item(row.row(), 1).text()}")
        else:
            for row in range(self.model.rowCount()):
                if not self.uiFindspotListTableV.isRowHidden(row):
                    findspotList.append(f"{self.model.item(row, 0).text()}.{self.model.item(row, 1).text()}")

        return findspotList

    def getSiteList(self, getAll):
        siteList = []
        if self.uiFindspotListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiFindspotListTableV.selectionModel().selectedRows()
            for row in rows:
                if not self.uiFindspotListTableV.isRowHidden(row.row()):
                    siteList.append(f"{self.model.item(row.row(), 0).text()}")
        else:
            for row in range(self.model.rowCount()):
                if not self.uiFindspotListTableV.isRowHidden(row):
                    siteList.append(f"{self.model.item(row, 0).text()}")

        return list(set(siteList))

    def onClose(self):
        SetWindowSizeAndPos("findspot_selection_list", self.size(), self.pos())
