# -*- coding: utf-8 -*-
"""
/***************************************************************************
 APISDialog
                                 A QGIS plugin
 APIS - Archaeological Prospection Information System - A QGIS Plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-04-10
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Johannes Liem (digitalcartography.org) and Aerial Archive of the University of Vienna
        email                : johannes.liem@digitalcartography.org
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from PyQt5.uic import loadUiType
from PyQt5.QtWidgets import QDialog, QMessageBox, QAbstractItemView, QHeaderView, QFileDialog, QPushButton, QMenu
from PyQt5.QtCore import QSettings, Qt, QDateTime, QDir, QFile
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QIcon

from qgis.core import (QgsProject, QgsVectorLayer, QgsDataSourceUri, QgsFeature, QgsVectorFileWriter)

from APIS.src.apis_findspot import APISFindspot
from APIS.src.apis_utils import OpenFileOrFolder
from APIS.src.apis_printer import APISPrinterQueue, APISListPrinter, APISTemplatePrinter, OutputMode
from APIS.src.apis_printing_options import APISPrintingOptions

FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(os.path.dirname(__file__)), 'ui', 'apis_findspot_selection_list.ui'), resource_suffix='')


class APISFindspotSelectionList(QDialog, FORM_CLASS):
    def __init__(self, iface, dbm, imageRegistry, apisLayer, parent=None):
        """Constructor."""
        super(APISFindspotSelectionList, self).__init__(parent)
        self.iface = iface
        self.dbm = dbm
        self.imageRegistry = imageRegistry
        self.apisLayer = apisLayer
        self.settings = QSettings(QSettings().value("APIS/config_ini"), QSettings.IniFormat)
        self.setupUi(self)

        self.query = None

        self.uiFindspotListTableV.doubleClicked.connect(self.openFindspotDialog)

        self.uiResetSelectionBtn.clicked.connect(self.uiFindspotListTableV.clearSelection)

        mLayer = QMenu()
        mLayer.addSection("In QGIS laden")
        aLayerLoadFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n)")
        aLayerLoadFindspot.triggered.connect(self.loadFindspotInQgis)
        mLayer.addSection("SHP Export")
        aLayerExportFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'shp_export.png')), "Fundstelle(n)")
        aLayerExportFindspot.triggered.connect(self.exportFindspotAsShp)
        mLayer.addSection("In QGIS anzeigen")
        aLayerShowFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle(n) zoomen")
        aLayerShowFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=False))
        aLayerSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Fundstelle(n) selektieren")
        aLayerSelectFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=False, select=True))
        aLayerShowAndSelectFindspot = mLayer.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'layer.png')), "Zu Fundstelle(n) zoomen und selektieren")
        aLayerShowAndSelectFindspot.triggered.connect(lambda: self.showFindspotInQgis(zoomTo=True, select=True))
        self.uiLayerTBtn.setMenu(mLayer)
        self.uiLayerTBtn.clicked.connect(self.uiLayerTBtn.showMenu)

        mPdfExport = QMenu()
        aPdfExportFindspotList = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstellenliste")
        aPdfExportFindspotList.triggered.connect(lambda: self.exportAsPdf(tab_list=True))
        aPdfExportFindspot = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle")
        aPdfExportFindspot.triggered.connect(lambda: self.exportAsPdf(detail=True))
        aPdfExportFindspotAndSite = mPdfExport.addAction(QIcon(os.path.join(QSettings().value("APIS/plugin_dir"), 'ui', 'icons', 'pdf_export.png')), "Fundstelle und Fundort")
        aPdfExportFindspotAndSite.triggered.connect(lambda: self.exportAsPdf(detail=True, parentDetail=True))
        self.uiPdfExportTBtn.setMenu(mPdfExport)
        self.uiPdfExportTBtn.clicked.connect(self.uiPdfExportTBtn.showMenu)

        self.findspotDlg = None
        self.printingOptionsDlg = None

    def hideEvent(self,event):
        self.query = None

    def loadFindspotListBySpatialQuery(self, query=None, info=None, update=False):
        if self.query == None:
            self.query = query

        self.model = self.dbm.queryToQStandardItemModel(self.query)

        if self.model is None or self.model.rowCount() < 1:
            if not update:
                QMessageBox.warning(None, "Fundstellen Auswahl", u"Es wurden keine Fundstellen gefunden!")
            self.query = None
            self.done(1)
            return False

        self.setupTable()

        self.uiItemCountLbl.setText(str(self.model.rowCount()))
        if info != None:
            self.uiInfoLbl.setText(info)

        return True

    def setupTable(self):
        self.uiFindspotListTableV.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.uiFindspotListTableV.setModel(self.model)
        self.uiFindspotListTableV.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.uiFindspotListTableV.resizeColumnsToContents()
        self.uiFindspotListTableV.resizeRowsToContents()
        self.uiFindspotListTableV.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.uiFindspotListTableV.selectionModel().selectionChanged.connect(self.onSelectionChanged)

    def onSelectionChanged(self):
        self.uiSelectionCountLbl.setText("{0}".format(len(self.uiFindspotListTableV.selectionModel().selectedRows())))

    def openFindspotDialog(self, idx):
        findspotNumber = self.model.item(idx.row(), 1).text()
        siteNumber = self.model.item(idx.row(), 0).text()
        if self.findspotDlg == None:
            self.findspotDlg = APISFindspot(self.iface, self.dbm, self.imageRegistry, self.apisLayer, self)
            self.findspotDlg.findspotEditsSaved.connect(self.reloadTable)
            self.findspotDlg.findspotDeleted.connect(self.reloadTable)
        self.findspotDlg.openInViewMode(siteNumber, findspotNumber)
        self.findspotDlg.show()
        # Run the dialog event loop

        if self.findspotDlg.exec_():
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        self.findspotDlg.uiDatingTimeCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodContent)
        self.findspotDlg.uiDatingPeriodCombo.currentIndexChanged.disconnect(self.findspotDlg.loadPeriodDetailsContent)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"For Site: {0}".format(siteNumber)))

    def reloadTable(self, editsSaved):
        self.query.exec_()
        self.loadFindspotListBySpatialQuery(self.query, None, True)
        #QMessageBox.warning(None, self.tr(u"Load Site"), self.tr(u"Reload Table Now"))

    def showFindspotInQgis(self, zoomTo=True, select=False):
        layer = self.apisLayer.requestFindspotLayer()
        expression = "\"fundortnummer\" || '.' || \"fundstellenummer\" IN ({})".format(','.join(["'{}'".format(fsN) for fsN in self.getFindspotList(False)]))
        self.apisLayer.selectFeaturesByExpression(layer, expression)
        if zoomTo:
            self.apisLayer.zoomToSelection(layer)
        if not select:
            layer.removeSelection()

    def loadFindspotInQgis(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = self.askForGeometryType()
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))

                # get PolygonLayer
                subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" IN ('
                for findspotNumber in findspotList:
                    subsetString += u'\'{0}\','.format(findspotNumber)
                subsetString = subsetString[:-1]
                subsetString += u')'
                findspotLayer = self.getSpatialiteLayer('fundstelle', subsetString)

                if polygon:
                    # load PolygonLayer
                    self.loadLayer(findspotLayer)

                if point:
                    # generate PointLayer
                    centerPointLayer = self.generateCenterPointLayer(findspotLayer)
                    # load PointLayer
                    self.loadLayer(centerPointLayer)

                self.close()

    def exportFindspotAsShp(self):
        findspotList = self.askForFindspotList()
        if findspotList:
            # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}".format(u", ".join(siteList)))
            polygon, point = self.askForGeometryType()
            if polygon or point:
                # QMessageBox.warning(None, self.tr(u"SiteList"), u"{0}, {1}".format(polygon, point))

                # get PolygonLayer
                subsetString = u'"fundortnummer"  || \'.\' || "fundstellenummer" IN ('
                for findspotNumber in findspotList:
                    subsetString += u'\'{0}\','.format(findspotNumber)
                subsetString = subsetString[:-1]
                subsetString += u')'
                findspotLayer = self.getSpatialiteLayer('fundstelle', subsetString)

                now = QDateTime.currentDateTime()
                time = now.toString("yyyyMMdd_hhmmss")
                if polygon:
                    # save PolygonLayer
                    self.exportLayer(findspotLayer, time)

                if point:
                    # generate PointLayer
                    centerPointLayer = self.generateCenterPointLayer(findspotLayer)
                    # save PointLayer
                    self.exportLayer(centerPointLayer, time)

    def exportAsPdf(self, tab_list=False, detail=False, parentDetail=False):
        if self.printingOptionsDlg is None:
            self.printingOptionsDlg = APISPrintingOptions(self)

        if tab_list and not detail and not parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstellenliste")
        elif detail and not tab_list and not parentDetail:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle")
        elif detail and parentDetail and not tab_list:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstelle und Fundort")
        else:
            self.printingOptionsDlg.setWindowTitle("Druck Optionen: Fundstellen Auswahl")

        if self.uiFindspotListTableV.model().rowCount() == 1:
            self.printingOptionsDlg.configure(False, False)
        elif not self.uiFindspotListTableV.selectionModel().hasSelection():
            self.printingOptionsDlg.configure(False, detail)
        else:
            if len(self.uiFindspotListTableV.selectionModel().selectedRows()) == 1:
                self.printingOptionsDlg.configure(True, detail)
            elif len(self.uiFindspotListTableV.selectionModel().selectedRows()) == self.uiFindspotListTableV.model().rowCount():
                self.printingOptionsDlg.configure(False, detail)
            else:
                self.printingOptionsDlg.configure(True, detail)

        self.printingOptionsDlg.show()

        if self.printingOptionsDlg.exec_():
            # get settings from dialog
            selectionModeIsAll = self.printingOptionsDlg.selectionModeIsAll()
            outputMode = self.printingOptionsDlg.outputMode()

            findspotList = self.getFindspotList(selectionModeIsAll)
            if findspotList:
                pdfsToPrint = []
                if tab_list:
                    pdfsToPrint.append({'type': APISListPrinter.FINDSPOT, 'idList': findspotList})

                if detail:
                    for findspot in findspotList:
                        if parentDetail:
                            pdfsToPrint.append({'type': APISTemplatePrinter.SITE, 'idList': [findspot[:8]]})
                        pdfsToPrint.append({'type': APISTemplatePrinter.FINDSPOT, 'idList': [findspot]})

                if pdfsToPrint:
                    APISPrinterQueue(pdfsToPrint,
                                     outputMode,
                                     openFile=self.printingOptionsDlg.uiOpenFilesChk.isChecked(),
                                     openFolder=self.printingOptionsDlg.uiOpenFolderChk.isChecked(),
                                     dbm=self.dbm,
                                     parent=self)

    def askForFindspotList(self):
        if self.uiFindspotListTableV.selectionModel().hasSelection():
            # Abfrage ob Fundorte der selektierten Bilder Exportieren oder alle
            msgBox = QMessageBox()
            msgBox.setWindowTitle(u'Fundstellen')
            msgBox.setText(u'Wollen Sie die ausgewählten Funstellen oder die gesamte Liste verwenden?')
            msgBox.addButton(QPushButton(u'Auswahl'), QMessageBox.YesRole)
            msgBox.addButton(QPushButton(u'Gesamte Liste'), QMessageBox.NoRole)
            msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
            ret = msgBox.exec_()

            if ret == 0:
                findspotList = self.getFindspotList(False)
            elif ret == 1:
                findspotList = self.getFindspotList(True)
            else:
                return None
        else:
            findspotList = self.getFindspotList(True)

        return findspotList

    def getFindspotList(self, getAll):
        findspotList = []
        if self.uiFindspotListTableV.selectionModel().hasSelection() and not getAll:
            rows = self.uiFindspotListTableV.selectionModel().selectedRows()
            for row in rows:
                if not self.uiFindspotListTableV.isRowHidden(row.row()):
                    findspotList.append(u"{0}.{1}".format(self.model.item(row.row(), 0).text(), self.model.item(row.row(), 1).text()))
        else:
            for row in range(self.model.rowCount()):
                if not self.uiFindspotListTableV.isRowHidden(row):
                    findspotList.append(u"{0}.{1}".format(self.model.item(row, 0).text(), self.model.item(row, 1).text()))

        return findspotList

    def askForGeometryType(self):
        # Abfrage ob Fundstellen der selektierten Bilder Exportieren oder alle
        msgBox = QMessageBox()
        msgBox.setWindowTitle(u'Fundstellen')
        msgBox.setText(u'Wollen Sie für die Fundstellen Polygone, Punkte oder beide Layer verwenden?')
        msgBox.addButton(QPushButton(u'Polygone'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Punkte'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Polygone und Punkte'), QMessageBox.ActionRole)
        msgBox.addButton(QPushButton(u'Abbrechen'), QMessageBox.RejectRole)
        ret = msgBox.exec_()

        if ret == 0:
            polygon = True
            point = False
        elif ret == 1:
            polygon = False
            point = True
        elif ret == 2:
            polygon = True
            point = True
        else:
            return None, None

        return polygon, point

    def getSpatialiteLayer(self, layerName, subsetString=None, displayName=None):
        if not displayName:
            displayName = layerName
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbm.db.databaseName())
        uri.setDataSource('', layerName, 'geometry')
        layer = QgsVectorLayer(uri.uri(), displayName, 'spatialite')
        if subsetString:
            layer.setSubsetString(subsetString)

        return layer

        # symbol_layer = QgsSimpleLineSymbolLayerV2()
        # symbol_layer.setWidth(0.6)
        # symbol_layer.setColor(QColor(100, 50, 140, 255))
        # self.siteLayer.rendererV2().symbols()[0].changeSymbolLayer(0, symbol_layer)

    def loadLayer(self, layer):
        QgsProject.instance().addMapLayer(layer)

    def exportLayer(self, layer, time):
        geomType = "Punkt" if layer.geometryType() == 0 else "Polygon"
        saveDir = self.settings.value("APIS/working_dir", QDir.home().dirName())
        layerName = QFileDialog.getSaveFileName(self, u'Fundstellen {0} Export Speichern'.format(geomType), saveDir + "\\" + 'Fundstellen_{0}_{1}'.format(geomType, time), '*.shp')[0]
        if layerName:
            check = QFile(layerName)
            if check.exists():
                if not QgsVectorFileWriter.deleteShapeFile(layerName):
                    QMessageBox.warning(None, "Fundstelle Export",
                                        u"Es ist nicht möglich die SHP Datei {0} zu überschreiben!".format(layerName))
                    return

            error = QgsVectorFileWriter.writeAsVectorFormat(layer, layerName, "UTF-8", layer.crs(), "ESRI Shapefile")

            if error == QgsVectorFileWriter.NoError:
                # QMessageBox.information(None, "Fundorte Export", u"Die ausgewählten Fundorte wurden in eine SHP Datei exportiert.")
                msgBox = QMessageBox()
                msgBox.setWindowTitle(u'Fundtelle Export')
                msgBox.setText(u"Die ausgewählten Fundstellen wurden in eine SHP Datei exportiert.")
                msgBox.addButton(QPushButton(u'SHP Datei laden'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'Ordner öffnen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'SHP Datei laden und Ordner öffnen'), QMessageBox.ActionRole)
                msgBox.addButton(QPushButton(u'OK'), QMessageBox.AcceptRole)
                ret = msgBox.exec_()

                if ret == 0 or ret == 2:
                    # Load Shp File in QGIS
                    self.iface.addVectorLayer(layerName, "", 'ogr')

                if ret == 1 or ret == 2:
                    # Open Folder
                    OpenFileOrFolder(os.path.split(layerName)[0])

            else:
                QMessageBox.warning(None, "Fundstelle Export", u"Beim erstellen der SHP Datei ist ein Fehler aufgetreten.")

    def generateCenterPointLayer(self, polygonLayer, displayName=None):
        if not displayName:
            displayName = polygonLayer.name()
        epsg = polygonLayer.crs().authid()
        # QMessageBox.warning(None, "EPSG", u"{0}".format(epsg))
        layer = QgsVectorLayer("Point?crs={0}".format(epsg), displayName, "memory")
        layer.setCrs(polygonLayer.crs())
        provider = layer.dataProvider()
        provider.addAttributes(polygonLayer.dataProvider().fields())

        layer.updateFields()

        pointFeatures = []
        for polygonFeature in polygonLayer.getFeatures():
            polygonGeom = polygonFeature.geometry()
            pointGeom = polygonGeom.centroid()
            # if center point is not on polygon get the nearest Point
            if not polygonGeom.contains(pointGeom):
                pointGeom = polygonGeom.pointOnSurface()

            pointFeature = QgsFeature()
            pointFeature.setGeometry(pointGeom)
            pointFeature.setAttributes(polygonFeature.attributes())
            pointFeatures.append(pointFeature)

        provider.addFeatures(pointFeatures)

        layer.updateExtents()

        return layer